(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["COS"] = factory();
	else
		root["COS"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var COS = __webpack_require__(/*! ./src/cos */ "./src/cos.js");
module.exports = COS;

/***/ }),

/***/ "./lib/base64.js":
/*!***********************!*\
  !*** ./lib/base64.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */

var Base64 = function (global) {
  global = global || {};
  'use strict';
  // existing version for noConflict()
  var _Base64 = global.Base64;
  var version = "2.1.9";
  // if node.js, we use Buffer
  var buffer;
  // constants
  var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var b64tab = function (bin) {
    var t = {};
    for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
    return t;
  }(b64chars);
  var fromCharCode = String.fromCharCode;
  // encoder stuff
  var cb_utob = function cb_utob(c) {
    if (c.length < 2) {
      var cc = c.charCodeAt(0);
      return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
    } else {
      var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
      return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);
    }
  };
  var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
  var utob = function utob(u) {
    return u.replace(re_utob, cb_utob);
  };
  var cb_encode = function cb_encode(ccc) {
    var padlen = [0, 2, 1][ccc.length % 3],
      ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),
      chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];
    return chars.join('');
  };
  var btoa = global.btoa ? function (b) {
    return global.btoa(b);
  } : function (b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
  };
  var _encode = buffer ? function (u) {
    return (u.constructor === buffer.constructor ? u : new buffer(u)).toString('base64');
  } : function (u) {
    return btoa(utob(u));
  };
  var encode = function encode(u, urisafe) {
    return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function (m0) {
      return m0 == '+' ? '-' : '_';
    }).replace(/=/g, '');
  };
  var encodeURI = function encodeURI(u) {
    return encode(u, true);
  };
  // decoder stuff
  var re_btou = new RegExp(['[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]{2}', '[\xF0-\xF7][\x80-\xBF]{3}'].join('|'), 'g');
  var cb_btou = function cb_btou(cccc) {
    switch (cccc.length) {
      case 4:
        var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),
          offset = cp - 0x10000;
        return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);
      case 3:
        return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));
      default:
        return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));
    }
  };
  var btou = function btou(b) {
    return b.replace(re_btou, cb_btou);
  };
  var cb_decode = function cb_decode(cccc) {
    var len = cccc.length,
      padlen = len % 4,
      n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
      chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];
    chars.length -= [0, 0, 2, 1][padlen];
    return chars.join('');
  };
  var atob = global.atob ? function (a) {
    return global.atob(a);
  } : function (a) {
    return a.replace(/[\s\S]{1,4}/g, cb_decode);
  };
  var _decode = buffer ? function (a) {
    return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString();
  } : function (a) {
    return btou(atob(a));
  };
  var decode = function decode(a) {
    return _decode(String(a).replace(/[-_]/g, function (m0) {
      return m0 == '-' ? '+' : '/';
    }).replace(/[^A-Za-z0-9\+\/]/g, ''));
  };
  var noConflict = function noConflict() {
    var Base64 = global.Base64;
    global.Base64 = _Base64;
    return Base64;
  };
  // export Base64
  var Base64 = {
    VERSION: version,
    atob: atob,
    btoa: btoa,
    fromBase64: decode,
    toBase64: encode,
    utob: utob,
    encode: encode,
    encodeURI: encodeURI,
    btou: btou,
    decode: decode,
    noConflict: noConflict
  };
  return Base64;
}();
module.exports = Base64;

/***/ }),

/***/ "./lib/crypto.js":
/*!***********************!*\
  !*** ./lib/crypto.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/*
 CryptoJS v3.1.2
 code.google.com/p/crypto-js
 (c) 2009-2013 by Jeff Mott. All rights reserved.
 code.google.com/p/crypto-js/wiki/License
 */
var CryptoJS = CryptoJS || function (g, l) {
  var e = {},
    d = e.lib = {},
    m = function m() {},
    k = d.Base = {
      extend: function extend(a) {
        m.prototype = this;
        var c = new m();
        a && c.mixIn(a);
        c.hasOwnProperty("init") || (c.init = function () {
          c.$super.init.apply(this, arguments);
        });
        c.init.prototype = c;
        c.$super = this;
        return c;
      },
      create: function create() {
        var a = this.extend();
        a.init.apply(a, arguments);
        return a;
      },
      init: function init() {},
      mixIn: function mixIn(a) {
        for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
        a.hasOwnProperty("toString") && (this.toString = a.toString);
      },
      clone: function clone() {
        return this.init.prototype.extend(this);
      }
    },
    p = d.WordArray = k.extend({
      init: function init(a, c) {
        a = this.words = a || [];
        this.sigBytes = c != l ? c : 4 * a.length;
      },
      toString: function toString(a) {
        return (a || n).stringify(this);
      },
      concat: function concat(a) {
        var c = this.words,
          q = a.words,
          f = this.sigBytes;
        a = a.sigBytes;
        this.clamp();
        if (f % 4) for (var b = 0; b < a; b++) c[f + b >>> 2] |= (q[b >>> 2] >>> 24 - 8 * (b % 4) & 255) << 24 - 8 * ((f + b) % 4);else if (65535 < q.length) for (b = 0; b < a; b += 4) c[f + b >>> 2] = q[b >>> 2];else c.push.apply(c, q);
        this.sigBytes += a;
        return this;
      },
      clamp: function clamp() {
        var a = this.words,
          c = this.sigBytes;
        a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
        a.length = g.ceil(c / 4);
      },
      clone: function clone() {
        var a = k.clone.call(this);
        a.words = this.words.slice(0);
        return a;
      },
      random: function random(a) {
        for (var c = [], b = 0; b < a; b += 4) c.push(4294967296 * g.random() | 0);
        return new p.init(c, a);
      }
    }),
    b = e.enc = {},
    n = b.Hex = {
      stringify: function stringify(a) {
        var c = a.words;
        a = a.sigBytes;
        for (var b = [], f = 0; f < a; f++) {
          var d = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;
          b.push((d >>> 4).toString(16));
          b.push((d & 15).toString(16));
        }
        return b.join("");
      },
      parse: function parse(a) {
        for (var c = a.length, b = [], f = 0; f < c; f += 2) b[f >>> 3] |= parseInt(a.substr(f, 2), 16) << 24 - 4 * (f % 8);
        return new p.init(b, c / 2);
      }
    },
    j = b.Latin1 = {
      stringify: function stringify(a) {
        var c = a.words;
        a = a.sigBytes;
        for (var b = [], f = 0; f < a; f++) b.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));
        return b.join("");
      },
      parse: function parse(a) {
        for (var c = a.length, b = [], f = 0; f < c; f++) b[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);
        return new p.init(b, c);
      }
    },
    h = b.Utf8 = {
      stringify: function stringify(a) {
        try {
          return decodeURIComponent(escape(j.stringify(a)));
        } catch (c) {
          throw Error("Malformed UTF-8 data");
        }
      },
      parse: function parse(a) {
        return j.parse(unescape(encodeURIComponent(a)));
      }
    },
    r = d.BufferedBlockAlgorithm = k.extend({
      reset: function reset() {
        this._data = new p.init();
        this._nDataBytes = 0;
      },
      _append: function _append(a) {
        "string" == typeof a && (a = h.parse(a));
        this._data.concat(a);
        this._nDataBytes += a.sigBytes;
      },
      _process: function _process(a) {
        var c = this._data,
          b = c.words,
          f = c.sigBytes,
          d = this.blockSize,
          e = f / (4 * d),
          e = a ? g.ceil(e) : g.max((e | 0) - this._minBufferSize, 0);
        a = e * d;
        f = g.min(4 * a, f);
        if (a) {
          for (var k = 0; k < a; k += d) this._doProcessBlock(b, k);
          k = b.splice(0, a);
          c.sigBytes -= f;
        }
        return new p.init(k, f);
      },
      clone: function clone() {
        var a = k.clone.call(this);
        a._data = this._data.clone();
        return a;
      },
      _minBufferSize: 0
    });
  d.Hasher = r.extend({
    cfg: k.extend(),
    init: function init(a) {
      this.cfg = this.cfg.extend(a);
      this.reset();
    },
    reset: function reset() {
      r.reset.call(this);
      this._doReset();
    },
    update: function update(a) {
      this._append(a);
      this._process();
      return this;
    },
    finalize: function finalize(a) {
      a && this._append(a);
      return this._doFinalize();
    },
    blockSize: 16,
    _createHelper: function _createHelper(a) {
      return function (b, d) {
        return new a.init(d).finalize(b);
      };
    },
    _createHmacHelper: function _createHmacHelper(a) {
      return function (b, d) {
        return new s.HMAC.init(a, d).finalize(b);
      };
    }
  });
  var s = e.algo = {};
  return e;
}(Math);
(function () {
  var g = CryptoJS,
    l = g.lib,
    e = l.WordArray,
    d = l.Hasher,
    m = [],
    l = g.algo.SHA1 = d.extend({
      _doReset: function _doReset() {
        this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
      },
      _doProcessBlock: function _doProcessBlock(d, e) {
        for (var b = this._hash.words, n = b[0], j = b[1], h = b[2], g = b[3], l = b[4], a = 0; 80 > a; a++) {
          if (16 > a) m[a] = d[e + a] | 0;else {
            var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
            m[a] = c << 1 | c >>> 31;
          }
          c = (n << 5 | n >>> 27) + l + m[a];
          c = 20 > a ? c + ((j & h | ~j & g) + 1518500249) : 40 > a ? c + ((j ^ h ^ g) + 1859775393) : 60 > a ? c + ((j & h | j & g | h & g) - 1894007588) : c + ((j ^ h ^ g) - 899497514);
          l = g;
          g = h;
          h = j << 30 | j >>> 2;
          j = n;
          n = c;
        }
        b[0] = b[0] + n | 0;
        b[1] = b[1] + j | 0;
        b[2] = b[2] + h | 0;
        b[3] = b[3] + g | 0;
        b[4] = b[4] + l | 0;
      },
      _doFinalize: function _doFinalize() {
        var d = this._data,
          e = d.words,
          b = 8 * this._nDataBytes,
          g = 8 * d.sigBytes;
        e[g >>> 5] |= 128 << 24 - g % 32;
        e[(g + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
        e[(g + 64 >>> 9 << 4) + 15] = b;
        d.sigBytes = 4 * e.length;
        this._process();
        return this._hash;
      },
      clone: function clone() {
        var e = d.clone.call(this);
        e._hash = this._hash.clone();
        return e;
      }
    });
  g.SHA1 = d._createHelper(l);
  g.HmacSHA1 = d._createHmacHelper(l);
})();
(function () {
  var g = CryptoJS,
    l = g.enc.Utf8;
  g.algo.HMAC = g.lib.Base.extend({
    init: function init(e, d) {
      e = this._hasher = new e.init();
      "string" == typeof d && (d = l.parse(d));
      var g = e.blockSize,
        k = 4 * g;
      d.sigBytes > k && (d = e.finalize(d));
      d.clamp();
      for (var p = this._oKey = d.clone(), b = this._iKey = d.clone(), n = p.words, j = b.words, h = 0; h < g; h++) n[h] ^= 1549556828, j[h] ^= 909522486;
      p.sigBytes = b.sigBytes = k;
      this.reset();
    },
    reset: function reset() {
      var e = this._hasher;
      e.reset();
      e.update(this._iKey);
    },
    update: function update(e) {
      this._hasher.update(e);
      return this;
    },
    finalize: function finalize(e) {
      var d = this._hasher;
      e = d.finalize(e);
      d.reset();
      return d.finalize(this._oKey.clone().concat(e));
    }
  });
})();
(function () {
  // Shortcuts
  var C = CryptoJS;
  var C_lib = C.lib;
  var WordArray = C_lib.WordArray;
  var C_enc = C.enc;

  /**
   * Base64 encoding strategy.
   */
  var Base64 = C_enc.Base64 = {
    /**
     * Converts a word array to a Base64 string.
     *
     * @param {WordArray} wordArray The word array.
     *
     * @return {string} The Base64 string.
     *
     * @static
     *
     * @example
     *
     *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
     */
    stringify: function stringify(wordArray) {
      // Shortcuts
      var words = wordArray.words;
      var sigBytes = wordArray.sigBytes;
      var map = this._map;

      // Clamp excess bits
      wordArray.clamp();

      // Convert
      var base64Chars = [];
      for (var i = 0; i < sigBytes; i += 3) {
        var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
        var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
        var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
        var triplet = byte1 << 16 | byte2 << 8 | byte3;
        for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
          base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
        }
      }

      // Add padding
      var paddingChar = map.charAt(64);
      if (paddingChar) {
        while (base64Chars.length % 4) {
          base64Chars.push(paddingChar);
        }
      }
      return base64Chars.join('');
    },
    /**
     * Converts a Base64 string to a word array.
     *
     * @param {string} base64Str The Base64 string.
     *
     * @return {WordArray} The word array.
     *
     * @static
     *
     * @example
     *
     *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
     */
    parse: function parse(base64Str) {
      // Shortcuts
      var base64StrLength = base64Str.length;
      var map = this._map;

      // Ignore padding
      var paddingChar = map.charAt(64);
      if (paddingChar) {
        var paddingIndex = base64Str.indexOf(paddingChar);
        if (paddingIndex != -1) {
          base64StrLength = paddingIndex;
        }
      }

      // Convert
      var words = [];
      var nBytes = 0;
      for (var i = 0; i < base64StrLength; i++) {
        if (i % 4) {
          var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;
          var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;
          words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
          nBytes++;
        }
      }
      return WordArray.create(words, nBytes);
    },
    _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
  };
})();
if (( false ? undefined : _typeof(module)) === 'object') {
  module.exports = CryptoJS;
} else {
  window.CryptoJS = CryptoJS;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./lib/json2xml.js":
/*!*************************!*\
  !*** ./lib/json2xml.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
//copyright Ryan Day 2010 <http://ryanday.org>, Joscha Feth 2013 <http://www.feth.com> [MIT Licensed]

var element_start_char = "a-zA-Z_\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FFF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
var element_non_start_char = "-.0-9\xB7\u0300-\u036F\u203F\u2040";
var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;
var objKeys = function objKeys(obj) {
  var l = [];
  if (obj instanceof Object) {
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        l.push(k);
      }
    }
  }
  return l;
};
var process_to_xml = function process_to_xml(node_data, options) {
  var makeNode = function makeNode(name, content, attributes, level, hasSubNodes) {
    var indent_value = options.indent !== undefined ? options.indent : "\t";
    var indent = options.prettyPrint ? '\n' + new Array(level).join(indent_value) : '';
    if (options.removeIllegalNameCharacters) {
      name = name.replace(element_replace, '_');
    }
    var node = [indent, '<', name, attributes || ''];
    if (content && content.length > 0) {
      node.push('>');
      node.push(content);
      hasSubNodes && node.push(indent);
      node.push('</');
      node.push(name);
      node.push('>');
    } else {
      node.push('/>');
    }
    return node.join('');
  };
  return function fn(node_data, node_descriptor, level) {
    var type = _typeof(node_data);
    if (Array.isArray ? Array.isArray(node_data) : node_data instanceof Array) {
      type = 'array';
    } else if (node_data instanceof Date) {
      type = 'date';
    }
    switch (type) {
      //if value is an array create child nodes from values
      case 'array':
        var ret = [];
        node_data.map(function (v) {
          ret.push(fn(v, 1, level + 1));
          //entries that are values of an array are the only ones that can be special node descriptors
        });

        options.prettyPrint && ret.push('\n');
        return ret.join('');
        break;
      case 'date':
        // cast dates to ISO 8601 date (soap likes it)
        return node_data.toJSON ? node_data.toJSON() : node_data + '';
        break;
      case 'object':
        var nodes = [];
        for (var name in node_data) {
          if (node_data.hasOwnProperty(name)) {
            if (node_data[name] instanceof Array) {
              for (var j = 0; j < node_data[name].length; j++) {
                if (node_data[name].hasOwnProperty(j)) {
                  nodes.push(makeNode(name, fn(node_data[name][j], 0, level + 1), null, level + 1, objKeys(node_data[name][j]).length));
                }
              }
            } else {
              nodes.push(makeNode(name, fn(node_data[name], 0, level + 1), null, level + 1));
            }
          }
        }
        options.prettyPrint && nodes.length > 0 && nodes.push('\n');
        return nodes.join('');
        break;
      case 'function':
        return node_data();
        break;
      default:
        return options.escape ? esc(node_data) : '' + node_data;
    }
  }(node_data, 0, 0);
};
var xml_header = function xml_header(standalone) {
  var ret = ['<?xml version="1.0" encoding="UTF-8"'];
  if (standalone) {
    ret.push(' standalone="yes"');
  }
  ret.push('?>');
  return ret.join('');
};
function esc(str) {
  return ('' + str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/"/g, '&quot;').replace(not_safe_in_xml, '');
}
module.exports = function (obj, options) {
  if (!options) {
    options = {
      xmlHeader: {
        standalone: true
      },
      prettyPrint: true,
      indent: "  ",
      escape: true
    };
  }
  if (typeof obj == 'string') {
    try {
      obj = JSON.parse(obj.toString());
    } catch (e) {
      return false;
    }
  }
  var xmlheader = '';
  var docType = '';
  if (options) {
    if (_typeof(options) == 'object') {
      // our config is an object

      if (options.xmlHeader) {
        // the user wants an xml header
        xmlheader = xml_header(!!options.xmlHeader.standalone);
      }
      if (typeof options.docType != 'undefined') {
        docType = '<!DOCTYPE ' + options.docType + '>';
      }
    } else {
      // our config is a boolean value, so just add xml header
      xmlheader = xml_header();
    }
  }
  options = options || {};
  var ret = [xmlheader, options.prettyPrint && docType ? '\n' : '', docType, process_to_xml(obj, options)];
  return ret.join('').replace(/\n{2,}/g, '\n').replace(/\s+$/g, '');
};

/***/ }),

/***/ "./lib/md5.js":
/*!********************!*\
  !*** ./lib/md5.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
/* https://github.com/emn178/js-md5 */
(function () {
  'use strict';

  var WINDOW = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_MD5_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object';
  if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && ( false ? undefined : _typeof(module)) === 'object' && module.exports;
  var AMD =  true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js");
  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var EXTRA = [128, 32768, 8388608, -2147483648];
  var SHIFT = [0, 8, 16, 24];
  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  var blocks = [],
    buffer8;
  if (ARRAY_BUFFER) {
    var buffer = new ArrayBuffer(68);
    buffer8 = new Uint8Array(buffer);
    blocks = new Uint32Array(buffer);
  }
  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }
  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return _typeof(obj) === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  /**
   * @method hex
   * @memberof md5
   * @description Output hash as hex string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} Hex string
   * @example
   * md5.hex('The quick brown fox jumps over the lazy dog');
   * // equal to
   * md5('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method digest
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.digest('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method array
   * @memberof md5
   * @description Output hash as bytes array
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Array} Bytes array
   * @example
   * md5.array('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method arrayBuffer
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof md5
   * @description Output hash as ArrayBuffer
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {ArrayBuffer} ArrayBuffer
   * @example
   * md5.buffer('The quick brown fox jumps over the lazy dog');
   */
  /**
   * @method base64
   * @memberof md5
   * @description Output hash as base64 string
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {String} base64 string
   * @example
   * md5.base64('The quick brown fox jumps over the lazy dog');
   */
  var createOutputMethod = function createOutputMethod(outputType) {
    return function (message, isBinStr) {
      return new Md5(true).update(message, isBinStr)[outputType]();
    };
  };

  /**
   * @method create
   * @memberof md5
   * @description Create Md5 object
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.create();
   */
  /**
   * @method update
   * @memberof md5
   * @description Create and update Md5 object
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @example
   * var hash = md5.update('The quick brown fox jumps over the lazy dog');
   * // equal to
   * var hash = md5.create();
   * hash.update('The quick brown fox jumps over the lazy dog');
   */
  var createMethod = function createMethod() {
    var method = createOutputMethod('hex');
    method.getCtx = method.create = function () {
      return new Md5();
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createOutputMethod(type);
    }
    return method;
  };

  /**
   * Md5 class
   * @class Md5
   * @description This is internal class.
   * @see {@link md5.create}
   */
  function Md5(sharedMemory) {
    if (sharedMemory) {
      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      this.blocks = blocks;
      this.buffer8 = buffer8;
    } else {
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
    }
    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
    this.finalized = this.hashed = false;
    this.first = true;
  }

  /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */
  Md5.prototype.update = function (message, isBinStr) {
    if (this.finalized) {
      return;
    }
    var code,
      index = 0,
      i,
      length = message.length,
      blocks = this.blocks;
    var buffer8 = this.buffer8;
    while (index < length) {
      if (this.hashed) {
        this.hashed = false;
        blocks[0] = blocks[16];
        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
      }
      if (ARRAY_BUFFER) {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (isBinStr || code < 0x80) {
            buffer8[i++] = code;
          } else if (code < 0x800) {
            buffer8[i++] = 0xc0 | code >> 6;
            buffer8[i++] = 0x80 | code & 0x3f;
          } else if (code < 0xd800 || code >= 0xe000) {
            buffer8[i++] = 0xe0 | code >> 12;
            buffer8[i++] = 0x80 | code >> 6 & 0x3f;
            buffer8[i++] = 0x80 | code & 0x3f;
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            buffer8[i++] = 0xf0 | code >> 18;
            buffer8[i++] = 0x80 | code >> 12 & 0x3f;
            buffer8[i++] = 0x80 | code >> 6 & 0x3f;
            buffer8[i++] = 0x80 | code & 0x3f;
          }
        }
      } else {
        for (i = this.start; index < length && i < 64; ++index) {
          code = message.charCodeAt(index);
          if (isBinStr || code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      this.bytes += i - this.start;
      if (i >= 64) {
        this.start = i - 64;
        this.hash();
        this.hashed = true;
      } else {
        this.start = i;
      }
    }
    if (this.bytes > 4294967295) {
      this.hBytes += this.bytes / 4294967296 << 0;
      this.bytes = this.bytes % 4294967296;
    }
    return this;
  };
  Md5.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex;
    blocks[i >> 2] |= EXTRA[i & 3];
    if (i >= 56) {
      if (!this.hashed) {
        this.hash();
      }
      blocks[0] = blocks[16];
      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    }
    blocks[14] = this.bytes << 3;
    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
    this.hash();
  };
  Md5.prototype.hash = function () {
    var a,
      b,
      c,
      d,
      bc,
      da,
      blocks = this.blocks;
    if (this.first) {
      a = blocks[0] - 680876937;
      a = (a << 7 | a >>> 25) - 271733879 << 0;
      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
      d = (d << 12 | d >>> 20) + a << 0;
      c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
      c = (c << 17 | c >>> 15) + d << 0;
      b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
      b = (b << 22 | b >>> 10) + c << 0;
    } else {
      a = this.h0;
      b = this.h1;
      c = this.h2;
      d = this.h3;
      a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
      a = (a << 7 | a >>> 25) + b << 0;
      d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
      d = (d << 12 | d >>> 20) + a << 0;
      c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
      c = (c << 17 | c >>> 15) + d << 0;
      b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
      b = (b << 22 | b >>> 10) + c << 0;
    }
    a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
    a = (a << 7 | a >>> 25) + b << 0;
    d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
    d = (d << 12 | d >>> 20) + a << 0;
    c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
    c = (c << 17 | c >>> 15) + d << 0;
    b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
    b = (b << 22 | b >>> 10) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
    b = (b << 20 | b >>> 12) + c << 0;
    a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
    a = (a << 5 | a >>> 27) + b << 0;
    d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
    d = (d << 9 | d >>> 23) + a << 0;
    c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
    c = (c << 14 | c >>> 18) + d << 0;
    b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
    b = (b << 20 | b >>> 12) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[5] - 378558;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[8] - 2022574463;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[11] + 1839030562;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[14] - 35309556;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[1] - 1530992060;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[4] + 1272893353;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[7] - 155497632;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[10] - 1094730640;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[13] + 681279174;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[0] - 358537222;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[3] - 722521979;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[6] + 76029189;
    b = (b << 23 | b >>> 9) + c << 0;
    bc = b ^ c;
    a += (bc ^ d) + blocks[9] - 640364487;
    a = (a << 4 | a >>> 28) + b << 0;
    d += (bc ^ a) + blocks[12] - 421815835;
    d = (d << 11 | d >>> 21) + a << 0;
    da = d ^ a;
    c += (da ^ b) + blocks[15] + 530742520;
    c = (c << 16 | c >>> 16) + d << 0;
    b += (da ^ c) + blocks[2] - 995338651;
    b = (b << 23 | b >>> 9) + c << 0;
    a += (c ^ (b | ~d)) + blocks[0] - 198630844;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[5] - 57434055;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[10] - 1051523;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[15] - 30611744;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
    b = (b << 21 | b >>> 11) + c << 0;
    a += (c ^ (b | ~d)) + blocks[4] - 145523070;
    a = (a << 6 | a >>> 26) + b << 0;
    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
    d = (d << 10 | d >>> 22) + a << 0;
    c += (a ^ (d | ~b)) + blocks[2] + 718787259;
    c = (c << 15 | c >>> 17) + d << 0;
    b += (d ^ (c | ~a)) + blocks[9] - 343485551;
    b = (b << 21 | b >>> 11) + c << 0;
    if (this.first) {
      this.h0 = a + 1732584193 << 0;
      this.h1 = b - 271733879 << 0;
      this.h2 = c - 1732584194 << 0;
      this.h3 = d + 271733878 << 0;
      this.first = false;
    } else {
      this.h0 = this.h0 + a << 0;
      this.h1 = this.h1 + b << 0;
      this.h2 = this.h2 + c << 0;
      this.h3 = this.h3 + d << 0;
    }
  };

  /**
   * @method hex
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.hex();
   */
  Md5.prototype.hex = function () {
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3;
    return HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F];
  };

  /**
   * @method toString
   * @memberof Md5
   * @instance
   * @description Output hash as hex string
   * @returns {String} Hex string
   * @see {@link md5.hex}
   * @example
   * hash.toString();
   */
  Md5.prototype.toString = Md5.prototype.hex;

  /**
   * @method digest
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.digest}
   * @example
   * hash.digest();
   */
  Md5.prototype.digest = function (format) {
    if (format === 'hex') return this.hex();
    this.finalize();
    var h0 = this.h0,
      h1 = this.h1,
      h2 = this.h2,
      h3 = this.h3;
    var res = [h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >> 24 & 0xFF];
    return res;
  };

  /**
   * @method array
   * @memberof Md5
   * @instance
   * @description Output hash as bytes array
   * @returns {Array} Bytes array
   * @see {@link md5.array}
   * @example
   * hash.array();
   */
  Md5.prototype.array = Md5.prototype.digest;

  /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */
  Md5.prototype.arrayBuffer = function () {
    this.finalize();
    var buffer = new ArrayBuffer(16);
    var blocks = new Uint32Array(buffer);
    blocks[0] = this.h0;
    blocks[1] = this.h1;
    blocks[2] = this.h2;
    blocks[3] = this.h3;
    return buffer;
  };

  /**
   * @method buffer
   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.buffer}
   * @example
   * hash.buffer();
   */
  Md5.prototype.buffer = Md5.prototype.arrayBuffer;

  /**
   * @method base64
   * @memberof Md5
   * @instance
   * @description Output hash as base64 string
   * @returns {String} base64 string
   * @see {@link md5.base64}
   * @example
   * hash.base64();
   */
  Md5.prototype.base64 = function () {
    var v1,
      v2,
      v3,
      base64Str = '',
      bytes = this.array();
    for (var i = 0; i < 15;) {
      v1 = bytes[i++];
      v2 = bytes[i++];
      v3 = bytes[i++];
      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
    }
    v1 = bytes[i];
    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + '==';
    return base64Str;
  };
  var exports = createMethod();
  if (COMMON_JS) {
    module.exports = exports;
  } else {
    /**
     * @method md5
     * @description Md5 hash function, export to global in browsers.
     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
     * @returns {String} md5 hashes
     * @example
     * md5(''); // d41d8cd98f00b204e9800998ecf8427e
     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
     *
     * // It also supports UTF-8 encoding
     * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07
     *
     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
     * md5([]); // d41d8cd98f00b204e9800998ecf8427e
     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
     */
    root.md5 = exports;
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return exports;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./lib/request.js":
/*!************************!*\
  !*** ./lib/request.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;
    case 'boolean':
      return v ? 'true' : 'false';
    case 'number':
      return isFinite(v) ? v : '';
    default:
      return '';
  }
};
var queryStringify = function queryStringify(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }
  if (_typeof(obj) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).filter(Boolean).join(sep);
  }
  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};
var xhrRes = function xhrRes(err, xhr, body) {
  var headers = {};
  var strHeaders = xhr.getAllResponseHeaders();
  if (strHeaders && strHeaders.length > 0) {
    strHeaders.trim().split('\n').forEach(function (item) {
      if (item) {
        var index = item.indexOf(':');
        var key = item.substr(0, index).trim().toLowerCase();
        var val = item.substr(index + 1).trim();
        headers[key] = val;
      }
    });
  }
  return {
    error: err,
    statusCode: xhr.status,
    statusMessage: xhr.statusText,
    headers: headers,
    body: body
  };
};
var xhrBody = function xhrBody(xhr, dataType) {
  return !dataType && dataType === 'text' ? xhr.responseText : xhr.response;
};
var request = function request(opt, callback) {
  // method
  var method = (opt.method || 'GET').toUpperCase();

  // url、qs
  var url = opt.url;
  if (opt.qs) {
    var qsStr = queryStringify(opt.qs);
    if (qsStr) {
      url += (url.indexOf('?') === -1 ? '?' : '&') + qsStr;
    }
  }

  // 创建 ajax 实例
  var xhr = new XMLHttpRequest();
  xhr.open(method, url, true);
  xhr.responseType = opt.dataType || 'text';

  // 处理 xhrFields 属性
  if (opt.xhrFields) {
    for (var xhrField in opt.xhrFields) {
      xhr[xhrField] = opt.xhrFields[xhrField];
    }
  }

  // 处理 headers
  var headers = opt.headers;
  if (headers) {
    for (var key in headers) {
      if (headers.hasOwnProperty(key) && key.toLowerCase() !== 'content-length' && key.toLowerCase() !== 'user-agent' && key.toLowerCase() !== 'origin' && key.toLowerCase() !== 'host') {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  }

  // onprogress
  if (opt.onProgress && xhr.upload) xhr.upload.onprogress = opt.onProgress;
  if (opt.onDownloadProgress) xhr.onprogress = opt.onDownloadProgress;

  // timeout
  if (opt.timeout) xhr.timeout = opt.timeout;
  xhr.ontimeout = function (event) {
    var error = new Error('timeout');
    callback(xhrRes(error, xhr));
  };

  // success 2xx/3xx/4xx
  xhr.onload = function () {
    callback(xhrRes(null, xhr, xhrBody(xhr, opt.dataType)));
  };

  // error 5xx/0 (网络错误、跨域报错、Https connect-src 限制的报错时 statusCode 为 0)
  xhr.onerror = function (err) {
    var body = xhrBody(xhr, opt.dataType);
    if (body) {
      // 5xx
      callback(xhrRes(null, xhr, body));
    } else {
      // 0
      var error = xhr.statusText;
      if (!error && xhr.status === 0) error = new Error('CORS blocked or network error');
      callback(xhrRes(error, xhr, body));
    }
  };

  // send
  xhr.send(opt.body || '');

  // 返回 ajax 实例，用于外部调用 xhr.abort
  return xhr;
};
module.exports = request;

/***/ }),

/***/ "./lib/xml2json.js":
/*!*************************!*\
  !*** ./lib/xml2json.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright 2015 William Summers, MetaTribal LLC
 * adapted from https://developer.mozilla.org/en-US/docs/JXON
 *
 * Licensed under the MIT License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @author William Summers
 * https://github.com/metatribal/xmlToJSON
 */
var DOMParser = __webpack_require__(/*! @xmldom/xmldom */ "./node_modules/@xmldom/xmldom/lib/index.js").DOMParser;
var xmlToJSON = function () {
  this.version = "1.3.5";
  var options = {
    // set up the default options
    mergeCDATA: true,
    // extract cdata and merge with text
    normalize: true,
    // collapse multiple spaces to single space
    stripElemPrefix: true // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property
  };

  var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
  var trimMatch = new RegExp(/^\s+|\s+$/g);
  this.grokType = function (sValue) {
    if (/^\s*$/.test(sValue)) {
      return null;
    }
    if (/^(?:true|false)$/i.test(sValue)) {
      return sValue.toLowerCase() === "true";
    }
    if (isFinite(sValue)) {
      return parseFloat(sValue);
    }
    return sValue;
  };
  this.parseString = function (xmlString, opt) {
    if (xmlString) {
      var xml = this.stringToXML(xmlString);
      if (xml.getElementsByTagName('parsererror').length) {
        return null;
      } else {
        return this.parseXML(xml, opt);
      }
    } else {
      return null;
    }
  };
  this.parseXML = function (oXMLParent, opt) {
    // initialize options
    for (var key in opt) {
      options[key] = opt[key];
    }
    var vResult = {},
      nLength = 0,
      sCollectedTxt = "";

    // iterate over the children
    var childNum = oXMLParent.childNodes.length;
    if (childNum) {
      for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
        oNode = oXMLParent.childNodes.item(nItem);
        if (oNode.nodeType === 4) {
          if (options.mergeCDATA) {
            sCollectedTxt += oNode.nodeValue;
          }
        } /* nodeType is "CDATASection" (4) */else if (oNode.nodeType === 3) {
          sCollectedTxt += oNode.nodeValue;
        } /* nodeType is "Text" (3) */else if (oNode.nodeType === 1) {
          /* nodeType is "Element" (1) */

          if (nLength === 0) {
            vResult = {};
          }

          // using nodeName to support browser (IE) implementation with no 'localName' property
          if (options.stripElemPrefix) {
            sProp = oNode.nodeName.replace(prefixMatch, '');
          } else {
            sProp = oNode.nodeName;
          }
          vContent = xmlToJSON.parseXML(oNode);
          if (vResult.hasOwnProperty(sProp)) {
            if (vResult[sProp].constructor !== Array) {
              vResult[sProp] = [vResult[sProp]];
            }
            vResult[sProp].push(vContent);
          } else {
            vResult[sProp] = vContent;
            nLength++;
          }
        }
      }
    }
    if (!Object.keys(vResult).length) {
      // vResult = sCollectedTxt.replace(trimMatch, '') || ''; // by carsonxu 修复 getBucket返回的 Key 是 " /" 这种场景
      vResult = sCollectedTxt || '';
    }
    return vResult;
  };

  // Convert xmlDocument to a string
  // Returns null on failure
  this.xmlToString = function (xmlDoc) {
    try {
      var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);
      return xmlString;
    } catch (err) {
      return null;
    }
  };

  // Convert a string to XML Node Structure
  // Returns null on failure
  this.stringToXML = function (xmlString) {
    try {
      var xmlDoc = null;
      if (window.DOMParser) {
        var parser = new DOMParser();
        xmlDoc = parser.parseFromString(xmlString, "text/xml");
        return xmlDoc;
      } else {
        xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async = false;
        xmlDoc.loadXML(xmlString);
        return xmlDoc;
      }
    } catch (e) {
      return null;
    }
  };
  return this;
}.call({});
var xml2json = function xml2json(xmlString) {
  return xmlToJSON.parseString(xmlString);
};
module.exports = xml2json;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime/helpers/toPropertyKey.js");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime/helpers/typeof.js")["default"];
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime/helpers/toPrimitive.js");
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/conventions.js":
/*!********************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/conventions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties, including NodeList.
 *
 * @template {unknown} T
 * @param {Array<T> | ({length:number, [number]: T})} list
 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
 * 				allows injecting a custom implementation in tests
 * @returns {T | undefined}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
function find(list, predicate, ac) {
	if (ac === undefined) {
		ac = Array.prototype;
	}
	if (list && typeof ac.find === 'function') {
		return ac.find.call(list, predicate);
	}
	for (var i = 0; i < list.length; i++) {
		if (Object.prototype.hasOwnProperty.call(list, i)) {
			var item = list[i];
			if (predicate.call(undefined, item, i, list)) {
				return item;
			}
		}
	}
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * @template T
 * @param {T} object the object to freeze
 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
 * 				allows to inject custom object constructor for tests
 * @returns {Readonly<T>}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 */
function freeze(object, oc) {
	if (oc === undefined) {
		oc = Object
	}
	return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
}

/**
 * Since we can not rely on `Object.assign` we provide a simplified version
 * that is sufficient for our needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 *
 * @returns {Object} target
 * @throws TypeError if target is not an object
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign(target, source) {
	if (target === null || typeof target !== 'object') {
		throw new TypeError('target is not an object')
	}
	for (var key in source) {
		if (Object.prototype.hasOwnProperty.call(source, key)) {
			target[key] = source[key]
		}
	}
	return target
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
 * @see DOMParser.prototype.parseFromString
 */
var MIME_TYPE = freeze({
	/**
	 * `text/html`, the only mime type that triggers treating an XML document as HTML.
	 *
	 * @see DOMParser.SupportedType.isHTML
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
	 */
	HTML: 'text/html',

	/**
	 * Helper method to check a mime type if it indicates an HTML document
	 *
	 * @param {string} [value]
	 * @returns {boolean}
	 *
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
	isHTML: function (value) {
		return value === MIME_TYPE.HTML
	},

	/**
	 * `application/xml`, the standard mime type for XML documents.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
	 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_APPLICATION: 'application/xml',

	/**
	 * `text/html`, an alias for `application/xml`.
	 *
	 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
	 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_TEXT: 'text/xml',

	/**
	 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
	 * but is parsed as an XML document.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
	 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
	 */
	XML_XHTML_APPLICATION: 'application/xhtml+xml',

	/**
	 * `image/svg+xml`,
	 *
	 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
	 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
	 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
	 */
	XML_SVG_IMAGE: 'image/svg+xml',
})

/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE = freeze({
	/**
	 * The XHTML namespace.
	 *
	 * @see http://www.w3.org/1999/xhtml
	 */
	HTML: 'http://www.w3.org/1999/xhtml',

	/**
	 * Checks if `uri` equals `NAMESPACE.HTML`.
	 *
	 * @param {string} [uri]
	 *
	 * @see NAMESPACE.HTML
	 */
	isHTML: function (uri) {
		return uri === NAMESPACE.HTML
	},

	/**
	 * The SVG namespace.
	 *
	 * @see http://www.w3.org/2000/svg
	 */
	SVG: 'http://www.w3.org/2000/svg',

	/**
	 * The `xml:` namespace.
	 *
	 * @see http://www.w3.org/XML/1998/namespace
	 */
	XML: 'http://www.w3.org/XML/1998/namespace',

	/**
	 * The `xmlns:` namespace
	 *
	 * @see https://www.w3.org/2000/xmlns/
	 */
	XMLNS: 'http://www.w3.org/2000/xmlns/',
})

exports.assign = assign;
exports.find = find;
exports.freeze = freeze;
exports.MIME_TYPE = MIME_TYPE;
exports.NAMESPACE = NAMESPACE;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom-parser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");
var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
var entities = __webpack_require__(/*! ./entities */ "./node_modules/@xmldom/xmldom/lib/entities.js");
var sax = __webpack_require__(/*! ./sax */ "./node_modules/@xmldom/xmldom/lib/sax.js");

var DOMImplementation = dom.DOMImplementation;

var NAMESPACE = conventions.NAMESPACE;

var ParseError = sax.ParseError;
var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating all of the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA
 * > 2. the two-character sequence #xD #x85
 * > 3. the single character #x85
 * > 4. the single character #x2028
 * > 5. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 */
function normalizeLineEndings(input) {
	return input
		.replace(/\r[\n\u0085]/g, '\n')
		.replace(/[\r\u0085\u2028]/g, '\n')
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {DOMHandler} [domBuilder]
 * @property {Function} [errorHandler]
 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
 * 						defaults to `normalizeLineEndings`
 * @property {Locator} [locator]
 * @property {Record<string, string>} [xmlns]
 *
 * @see normalizeLineEndings
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code
 * from a string into a DOM `Document`.
 *
 * _xmldom is different from the spec in that it allows an `options` parameter,
 * to override the default behavior._
 *
 * @param {DOMParserOptions} [options]
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser(options){
	this.options = options ||{locator:{}};
}

DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
  	var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}

	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(isHTML){
		defaultNSMap[''] = NAMESPACE.HTML;
	}
	defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
	var normalize = options.normalizeLineEndings || normalizeLineEndings;
	if (source && typeof source === 'string') {
		sax.parse(
			normalize(source),
			defaultNSMap,
			entityMap
		)
	} else {
		sax.errorHandler.error('invalid doc source')
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler
 *
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;

		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},

	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},

	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
					this.doc.doctype = dt;
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		throw new ParseError(error, this.locator);
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

exports.__DOMHandler = DOMHandler;
exports.normalizeLineEndings = normalizeLineEndings;
exports.DOMParser = DOMParser;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");

var find = conventions.find;
var NAMESPACE = conventions.NAMESPACE;

/**
 * A prerequisite for `[].filter`, to drop elements that are empty
 * @param {string} input
 * @returns {boolean}
 */
function notEmptyString (input) {
	return input !== ''
}
/**
 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 *
 * @param {string} input
 * @returns {string[]} (can be empty)
 */
function splitOnASCIIWhitespace(input) {
	// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
	return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * @param {string} element
 * @returns {Record<string, boolean | undefined>}
 */
function orderedSetReducer (current, element) {
	if (!current.hasOwnProperty(element)) {
		current[element] = true;
	}
	return current;
}

/**
 * @see https://infra.spec.whatwg.org/#ordered-set
 * @param {string} input
 * @returns {string[]}
 */
function toOrderedSet(input) {
	if (!input) return [];
	var list = splitOnASCIIWhitespace(input);
	return Object.keys(list.reduce(orderedSetReducer, {}))
}

/**
 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
 * which we can not rely on being available.
 *
 * @param {any[]} list
 * @returns {function(any): boolean}
 */
function arrayIncludes (list) {
	return function(element) {
		return list && list.indexOf(element) !== -1;
	}
}

function copy(src,dest){
	for(var p in src){
		if (Object.prototype.hasOwnProperty.call(src, p)) {
			dest[p] = src[p];
		}
	}
}

/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknown Class:"+Class)
		}
		pt.constructor = Class
	}
}

// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

/**
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)

/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0,
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
	 */
	item: function(index) {
		return index >= 0 && index < this.length ? this[index] : null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	},
	/**
	 * @private
	 * @param {function (Node):boolean} predicate
	 * @returns {Node[]}
	 */
	filter: function (predicate) {
		return Array.prototype.filter.call(this, predicate);
	},
	/**
	 * @private
	 * @param {Node} item
	 * @returns {number}
	 */
	indexOf: function (item) {
		return Array.prototype.indexOf.call(this, item);
	},
};

function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if (list._inc !== inc) {
		var ls = list._refresh(list._node);
		__set__(list,'length',ls.length);
		if (!list.$$length || ls.length < list.$$length) {
			for (var i = ls.length; i in list; i++) {
				if (Object.prototype.hasOwnProperty.call(list, i)) {
					delete list[i];
				}
			}
		}
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i] || null;
}

_extends(LiveNodeList,NodeList);

/**
 * Objects implementing the NamedNodeMap interface are used
 * to represent collections of nodes that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;


	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};

/**
 * The DOMImplementation interface represents an object providing methods
 * which are not dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * __The individual methods describe the differences compared to the specs.__
 *
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 */
function DOMImplementation() {
}

DOMImplementation.prototype = {
	/**
	 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
	 * The different implementations fairly diverged in what kind of features were reported.
	 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
	 *
	 * @deprecated It is deprecated and modern browsers return true in all cases.
	 *
	 * @param {string} feature
	 * @param {string} [version]
	 * @returns {boolean} always true
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
	 */
	hasFeature: function(feature, version) {
			return true;
	},
	/**
	 * Creates an XML Document object of the specified type with its document element.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
	 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string|null} namespaceURI
	 * @param {string} qualifiedName
	 * @param {DocumentType=null} doctype
	 * @returns {Document}
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocument: function(namespaceURI,  qualifiedName, doctype){
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype || null;
		if (doctype){
			doc.appendChild(doctype);
		}
		if (qualifiedName){
			var root = doc.createElementNS(namespaceURI, qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	/**
	 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
	 *
	 * __This behavior is slightly different from the in the specs__:
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string} qualifiedName
	 * @param {string} [publicId]
	 * @param {string} [systemId]
	 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
	 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocumentType: function(qualifiedName, publicId, systemId){
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId || '';
		node.systemId = systemId || '';

		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises
		_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
	/**
	 * Look up the prefix associated to the given namespace URI, starting from this node.
	 * **The default namespace declarations are ignored by this method.**
	 * See Namespace Prefix Lookup for details on the algorithm used by this method.
	 *
	 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
	 *
	 * @param {string | null} namespaceURI
	 * @returns {string | null}
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
	 * @see https://github.com/xmldom/xmldom/issues/322
	 */
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
						if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
							return n;
						}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(Object.prototype.hasOwnProperty.call(map, prefix)){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
	this.ownerDocument = this;
}

function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}

function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}

/**
 * Updates `el.childNodes`, updating the indexed items and it's `length`.
 * Passing `newChild` means it will be appended.
 * Otherwise it's assumed that an item has been removed,
 * and `el.firstNode` and it's `.nextSibling` are used
 * to walk the current list of child nodes.
 *
 * @param {Document} doc
 * @param {Node} el
 * @param {Node} [newChild]
 * @private
 */
function _onUpdateChild (doc, el, newChild) {
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if (newChild) {
			cs[cs.length++] = newChild;
		} else {
			var child = el.firstChild;
			var i = 0;
			while (child) {
				cs[i++] = child;
				child = child.nextSibling;
			}
			cs.length = i;
			delete cs[cs.length];
		}
	}
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 *
 * @param {Node} parentNode
 * @param {Node} child
 * @returns {Node} the child that was removed.
 * @private
 */
function _removeChild (parentNode, child) {
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if (previous) {
		previous.nextSibling = next;
	} else {
		parentNode.firstChild = next;
	}
	if (next) {
		next.previousSibling = previous;
	} else {
		parentNode.lastChild = previous;
	}
	child.parentNode = null;
	child.previousSibling = null;
	child.nextSibling = null;
	_onUpdateChild(parentNode.ownerDocument, parentNode);
	return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
	return (
		node &&
		(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
	);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
	return (
		node &&
		(isElementNode(node) ||
			isTextNode(node) ||
			isDocTypeNode(node) ||
			node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
			node.nodeType === Node.COMMENT_NODE ||
			node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
	);
}

/**
 * Returns true if `node` is a DOCTYPE node
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
	return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
	return node && node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
	return node && node.nodeType === Node.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementInsertionPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];
	if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementReplacementPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];

	function hasElementChildThatIsNotChild(node) {
		return isElementNode(node) && node !== child;
	}

	if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * @private
 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
 *
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
	// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
	if (!hasValidParentNodeType(parent)) {
		throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
	}
	// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
	// not implemented!
	// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
	if (child && child.parentNode !== parent) {
		throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
	}
	if (
		// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
		!hasInsertableNodeType(node) ||
		// 5. If either `node` is a Text node and `parent` is a document,
		// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
		// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
		// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
		(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
	) {
		throw new DOMException(
			HIERARCHY_REQUEST_ERR,
			'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
		);
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If node has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child,
		// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child, `child` is a doctype,
		// or `child` is non-null and a doctype is following `child`.
		if (!isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		// `parent` has a doctype child,
		if (find(parentChildNodes, isDocTypeNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// `child` is non-null and an element is preceding `child`,
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
		// or `child` is null and `parent` has an element child.
		if (!child && parentElementChild) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
		}
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If `node` has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child that is not `child` or a doctype is following `child`.
		if (!isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		function hasDoctypeChildThatIsNotChild(node) {
			return isDocTypeNode(node) && node !== child;
		}

		// `parent` has a doctype child that is not `child`,
		if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// or an element is preceding `child`.
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
	}
}

/**
 * @private
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
	// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
	assertPreInsertionValidity1to5(parent, node, child);

	// If parent is a document, and any of the statements below, switched on the interface node implements,
	// are true, then throw a "HierarchyRequestError" DOMException.
	if (parent.nodeType === Node.DOCUMENT_NODE) {
		(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
	}

	var cp = node.parentNode;
	if(cp){
		cp.removeChild(node);//remove and update
	}
	if(node.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = node.firstChild;
		if (newFirst == null) {
			return node;
		}
		var newLast = node.lastChild;
	}else{
		newFirst = newLast = node;
	}
	var pre = child ? child.previousSibling : parent.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = child;


	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parent.firstChild = newFirst;
	}
	if(child == null){
		parent.lastChild = newLast;
	}else{
		child.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parent;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parent.ownerDocument||parent, parent);
	//console.log(parent.lastChild.nextSibling == null)
	if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
		node.firstChild = node.lastChild = null;
	}
	return node;
}

/**
 * Appends `newChild` to `parentNode`.
 * If `newChild` is already connected to a `parentNode` it is first removed from it.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 * @param {Node} parentNode
 * @param {Node} newChild
 * @returns {Node}
 * @private
 */
function _appendSingleChild (parentNode, newChild) {
	if (newChild.parentNode) {
		newChild.parentNode.removeChild(newChild);
	}
	newChild.parentNode = parentNode;
	newChild.previousSibling = parentNode.lastChild;
	newChild.nextSibling = null;
	if (newChild.previousSibling) {
		newChild.previousSibling.nextSibling = newChild;
	} else {
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
	return newChild;
}

Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	/**
	 * The DocumentType node of the document.
	 *
	 * @readonly
	 * @type DocumentType
	 */
	doctype :  null,
	documentElement :  null,
	_inc : 1,

	insertBefore :  function(newChild, refChild){//raises
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		_insertBefore(this, newChild, refChild);
		newChild.ownerDocument = this;
		if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
			this.documentElement = newChild;
		}

		return newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	replaceChild: function (newChild, oldChild) {
		//raises
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		newChild.ownerDocument = this;
		if (oldChild) {
			this.removeChild(oldChild);
		}
		if (isElementNode(newChild)) {
			this.documentElement = newChild;
		}
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},

	/**
	 * The `getElementsByClassName` method of `Document` interface returns an array-like object
	 * of all child elements which have **all** of the given class name(s).
	 *
	 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
	 *
	 *
	 * Warning: This is a live LiveNodeList.
	 * Changes in the DOM will reflect in the array as the changes occur.
	 * If an element selected by this array no longer qualifies for the selector,
	 * it will automatically be removed. Be aware of this for iteration purposes.
	 *
	 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
	 */
	getElementsByClassName: function(classNames) {
		var classNamesSet = toOrderedSet(classNames)
		return new LiveNodeList(this, function(base) {
			var ls = [];
			if (classNamesSet.length > 0) {
				_visitNode(base.documentElement, function(node) {
					if(node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute('class')
						// can be null if the attribute does not exist
						if (nodeClassNames) {
							// before splitting and iterating just compare them for the most common case
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames)
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet))
							}
							if(matches) {
								ls.push(node);
							}
						}
					}
				});
			}
			return ls;
		});
	},

	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.localName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.nodeName = node.target = target;
		node.nodeValue = node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},

	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},

	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},

	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;

		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);

	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9 && this.documentElement || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;

	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}

function needNamespaceDefine(node, isHTML, visibleNamespaces) {
	var prefix = node.prefix || '';
	var uri = node.namespaceURI;
	// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
	// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
	// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
	// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
	// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
	// > [...] Furthermore, the attribute value [...] must not be an empty string.
	// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
	if (!uri) {
		return false;
	}
	if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
		return false;
	}

	var i = visibleNamespaces.length
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		if (ns.prefix === prefix) {
			return ns.namespace !== uri;
		}
	}
	return true;
}
/**
 * Well-formed constraint: No < in Attribute Values
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 *
 * Literal whitespace other than space that appear in attribute values
 * are serialized as their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces)
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 */
function addSerializedAttribute(buf, qualifiedName, value) {
	buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"')
}

function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if (!visibleNamespaces) {
		visibleNamespaces = [];
	}

	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}

	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;

		isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML

		var prefixedNodeName = nodeName
		if (!isHTML && !node.prefix && node.namespaceURI) {
			var defaultNS
			// lookup current default ns from `xmlns` attribute
			for (var ai = 0; ai < attrs.length; ai++) {
				if (attrs.item(ai).name === 'xmlns') {
					defaultNS = attrs.item(ai).value
					break
				}
			}
			if (!defaultNS) {
				// lookup current default ns in visibleNamespaces
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
						defaultNS = namespace.namespace
						break
					}
				}
			}
			if (defaultNS !== node.namespaceURI) {
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.namespace === node.namespaceURI) {
						if (namespace.prefix) {
							prefixedNodeName = namespace.prefix + ':' + nodeName
						}
						break
					}
				}
			}
		}

		buf.push('<', prefixedNodeName);

		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}

		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}

		// add namespace for current node
		if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}

		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					child = child.nextSibling;
				}
			}
			buf.push('</',prefixedNodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return addSerializedAttribute(buf, node.name, node.value);
	case TEXT_NODE:
		/**
		 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
		 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
		 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
		 * `&amp;` and `&lt;` respectively.
		 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
		 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
		 * when that string is not marking the end of a CDATA section.
		 *
		 * In the content of elements, character data is any string of characters
		 * which does not contain the start-delimiter of any markup
		 * and does not include the CDATA-section-close delimiter, `]]>`.
		 *
		 * @see https://www.w3.org/TR/xml/#NT-CharData
		 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
		 */
		return buf.push(node.data
			.replace(/[<&>]/g,_xmlEncoder)
		);
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC ', pubid);
			if (sysid && sysid!='.') {
				buf.push(' ', sysid);
			}
			buf.push('>');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM ', sysid, '>');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for (var n in node) {
		if (Object.prototype.hasOwnProperty.call(node, n)) {
			var v = node[n];
			if (typeof v != "object") {
				if (v != node2[n]) {
					node2[n] = v;
				}
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});

		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},

			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;

				default:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})

		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}

		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DocumentType = DocumentType;
	exports.DOMException = DOMException;
	exports.DOMImplementation = DOMImplementation;
	exports.Element = Element;
	exports.Node = Node;
	exports.NodeList = NodeList;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/entities.js":
/*!*****************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/entities.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var freeze = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").freeze;

/**
 * The entities that are predefined in every XML document.
 *
 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
 */
exports.XML_ENTITIES = freeze({
	amp: '&',
	apos: "'",
	gt: '>',
	lt: '<',
	quot: '"',
});

/**
 * A map of all entities that are detected in an HTML document.
 * They contain all entries from `XML_ENTITIES`.
 *
 * @see XML_ENTITIES
 * @see DOMParser.parseFromString
 * @see DOMImplementation.prototype.createHTMLDocument
 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
 * @see https://html.spec.whatwg.org/entities.json JSON
 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
 */
exports.HTML_ENTITIES = freeze({
	Aacute: '\u00C1',
	aacute: '\u00E1',
	Abreve: '\u0102',
	abreve: '\u0103',
	ac: '\u223E',
	acd: '\u223F',
	acE: '\u223E\u0333',
	Acirc: '\u00C2',
	acirc: '\u00E2',
	acute: '\u00B4',
	Acy: '\u0410',
	acy: '\u0430',
	AElig: '\u00C6',
	aelig: '\u00E6',
	af: '\u2061',
	Afr: '\uD835\uDD04',
	afr: '\uD835\uDD1E',
	Agrave: '\u00C0',
	agrave: '\u00E0',
	alefsym: '\u2135',
	aleph: '\u2135',
	Alpha: '\u0391',
	alpha: '\u03B1',
	Amacr: '\u0100',
	amacr: '\u0101',
	amalg: '\u2A3F',
	AMP: '\u0026',
	amp: '\u0026',
	And: '\u2A53',
	and: '\u2227',
	andand: '\u2A55',
	andd: '\u2A5C',
	andslope: '\u2A58',
	andv: '\u2A5A',
	ang: '\u2220',
	ange: '\u29A4',
	angle: '\u2220',
	angmsd: '\u2221',
	angmsdaa: '\u29A8',
	angmsdab: '\u29A9',
	angmsdac: '\u29AA',
	angmsdad: '\u29AB',
	angmsdae: '\u29AC',
	angmsdaf: '\u29AD',
	angmsdag: '\u29AE',
	angmsdah: '\u29AF',
	angrt: '\u221F',
	angrtvb: '\u22BE',
	angrtvbd: '\u299D',
	angsph: '\u2222',
	angst: '\u00C5',
	angzarr: '\u237C',
	Aogon: '\u0104',
	aogon: '\u0105',
	Aopf: '\uD835\uDD38',
	aopf: '\uD835\uDD52',
	ap: '\u2248',
	apacir: '\u2A6F',
	apE: '\u2A70',
	ape: '\u224A',
	apid: '\u224B',
	apos: '\u0027',
	ApplyFunction: '\u2061',
	approx: '\u2248',
	approxeq: '\u224A',
	Aring: '\u00C5',
	aring: '\u00E5',
	Ascr: '\uD835\uDC9C',
	ascr: '\uD835\uDCB6',
	Assign: '\u2254',
	ast: '\u002A',
	asymp: '\u2248',
	asympeq: '\u224D',
	Atilde: '\u00C3',
	atilde: '\u00E3',
	Auml: '\u00C4',
	auml: '\u00E4',
	awconint: '\u2233',
	awint: '\u2A11',
	backcong: '\u224C',
	backepsilon: '\u03F6',
	backprime: '\u2035',
	backsim: '\u223D',
	backsimeq: '\u22CD',
	Backslash: '\u2216',
	Barv: '\u2AE7',
	barvee: '\u22BD',
	Barwed: '\u2306',
	barwed: '\u2305',
	barwedge: '\u2305',
	bbrk: '\u23B5',
	bbrktbrk: '\u23B6',
	bcong: '\u224C',
	Bcy: '\u0411',
	bcy: '\u0431',
	bdquo: '\u201E',
	becaus: '\u2235',
	Because: '\u2235',
	because: '\u2235',
	bemptyv: '\u29B0',
	bepsi: '\u03F6',
	bernou: '\u212C',
	Bernoullis: '\u212C',
	Beta: '\u0392',
	beta: '\u03B2',
	beth: '\u2136',
	between: '\u226C',
	Bfr: '\uD835\uDD05',
	bfr: '\uD835\uDD1F',
	bigcap: '\u22C2',
	bigcirc: '\u25EF',
	bigcup: '\u22C3',
	bigodot: '\u2A00',
	bigoplus: '\u2A01',
	bigotimes: '\u2A02',
	bigsqcup: '\u2A06',
	bigstar: '\u2605',
	bigtriangledown: '\u25BD',
	bigtriangleup: '\u25B3',
	biguplus: '\u2A04',
	bigvee: '\u22C1',
	bigwedge: '\u22C0',
	bkarow: '\u290D',
	blacklozenge: '\u29EB',
	blacksquare: '\u25AA',
	blacktriangle: '\u25B4',
	blacktriangledown: '\u25BE',
	blacktriangleleft: '\u25C2',
	blacktriangleright: '\u25B8',
	blank: '\u2423',
	blk12: '\u2592',
	blk14: '\u2591',
	blk34: '\u2593',
	block: '\u2588',
	bne: '\u003D\u20E5',
	bnequiv: '\u2261\u20E5',
	bNot: '\u2AED',
	bnot: '\u2310',
	Bopf: '\uD835\uDD39',
	bopf: '\uD835\uDD53',
	bot: '\u22A5',
	bottom: '\u22A5',
	bowtie: '\u22C8',
	boxbox: '\u29C9',
	boxDL: '\u2557',
	boxDl: '\u2556',
	boxdL: '\u2555',
	boxdl: '\u2510',
	boxDR: '\u2554',
	boxDr: '\u2553',
	boxdR: '\u2552',
	boxdr: '\u250C',
	boxH: '\u2550',
	boxh: '\u2500',
	boxHD: '\u2566',
	boxHd: '\u2564',
	boxhD: '\u2565',
	boxhd: '\u252C',
	boxHU: '\u2569',
	boxHu: '\u2567',
	boxhU: '\u2568',
	boxhu: '\u2534',
	boxminus: '\u229F',
	boxplus: '\u229E',
	boxtimes: '\u22A0',
	boxUL: '\u255D',
	boxUl: '\u255C',
	boxuL: '\u255B',
	boxul: '\u2518',
	boxUR: '\u255A',
	boxUr: '\u2559',
	boxuR: '\u2558',
	boxur: '\u2514',
	boxV: '\u2551',
	boxv: '\u2502',
	boxVH: '\u256C',
	boxVh: '\u256B',
	boxvH: '\u256A',
	boxvh: '\u253C',
	boxVL: '\u2563',
	boxVl: '\u2562',
	boxvL: '\u2561',
	boxvl: '\u2524',
	boxVR: '\u2560',
	boxVr: '\u255F',
	boxvR: '\u255E',
	boxvr: '\u251C',
	bprime: '\u2035',
	Breve: '\u02D8',
	breve: '\u02D8',
	brvbar: '\u00A6',
	Bscr: '\u212C',
	bscr: '\uD835\uDCB7',
	bsemi: '\u204F',
	bsim: '\u223D',
	bsime: '\u22CD',
	bsol: '\u005C',
	bsolb: '\u29C5',
	bsolhsub: '\u27C8',
	bull: '\u2022',
	bullet: '\u2022',
	bump: '\u224E',
	bumpE: '\u2AAE',
	bumpe: '\u224F',
	Bumpeq: '\u224E',
	bumpeq: '\u224F',
	Cacute: '\u0106',
	cacute: '\u0107',
	Cap: '\u22D2',
	cap: '\u2229',
	capand: '\u2A44',
	capbrcup: '\u2A49',
	capcap: '\u2A4B',
	capcup: '\u2A47',
	capdot: '\u2A40',
	CapitalDifferentialD: '\u2145',
	caps: '\u2229\uFE00',
	caret: '\u2041',
	caron: '\u02C7',
	Cayleys: '\u212D',
	ccaps: '\u2A4D',
	Ccaron: '\u010C',
	ccaron: '\u010D',
	Ccedil: '\u00C7',
	ccedil: '\u00E7',
	Ccirc: '\u0108',
	ccirc: '\u0109',
	Cconint: '\u2230',
	ccups: '\u2A4C',
	ccupssm: '\u2A50',
	Cdot: '\u010A',
	cdot: '\u010B',
	cedil: '\u00B8',
	Cedilla: '\u00B8',
	cemptyv: '\u29B2',
	cent: '\u00A2',
	CenterDot: '\u00B7',
	centerdot: '\u00B7',
	Cfr: '\u212D',
	cfr: '\uD835\uDD20',
	CHcy: '\u0427',
	chcy: '\u0447',
	check: '\u2713',
	checkmark: '\u2713',
	Chi: '\u03A7',
	chi: '\u03C7',
	cir: '\u25CB',
	circ: '\u02C6',
	circeq: '\u2257',
	circlearrowleft: '\u21BA',
	circlearrowright: '\u21BB',
	circledast: '\u229B',
	circledcirc: '\u229A',
	circleddash: '\u229D',
	CircleDot: '\u2299',
	circledR: '\u00AE',
	circledS: '\u24C8',
	CircleMinus: '\u2296',
	CirclePlus: '\u2295',
	CircleTimes: '\u2297',
	cirE: '\u29C3',
	cire: '\u2257',
	cirfnint: '\u2A10',
	cirmid: '\u2AEF',
	cirscir: '\u29C2',
	ClockwiseContourIntegral: '\u2232',
	CloseCurlyDoubleQuote: '\u201D',
	CloseCurlyQuote: '\u2019',
	clubs: '\u2663',
	clubsuit: '\u2663',
	Colon: '\u2237',
	colon: '\u003A',
	Colone: '\u2A74',
	colone: '\u2254',
	coloneq: '\u2254',
	comma: '\u002C',
	commat: '\u0040',
	comp: '\u2201',
	compfn: '\u2218',
	complement: '\u2201',
	complexes: '\u2102',
	cong: '\u2245',
	congdot: '\u2A6D',
	Congruent: '\u2261',
	Conint: '\u222F',
	conint: '\u222E',
	ContourIntegral: '\u222E',
	Copf: '\u2102',
	copf: '\uD835\uDD54',
	coprod: '\u2210',
	Coproduct: '\u2210',
	COPY: '\u00A9',
	copy: '\u00A9',
	copysr: '\u2117',
	CounterClockwiseContourIntegral: '\u2233',
	crarr: '\u21B5',
	Cross: '\u2A2F',
	cross: '\u2717',
	Cscr: '\uD835\uDC9E',
	cscr: '\uD835\uDCB8',
	csub: '\u2ACF',
	csube: '\u2AD1',
	csup: '\u2AD0',
	csupe: '\u2AD2',
	ctdot: '\u22EF',
	cudarrl: '\u2938',
	cudarrr: '\u2935',
	cuepr: '\u22DE',
	cuesc: '\u22DF',
	cularr: '\u21B6',
	cularrp: '\u293D',
	Cup: '\u22D3',
	cup: '\u222A',
	cupbrcap: '\u2A48',
	CupCap: '\u224D',
	cupcap: '\u2A46',
	cupcup: '\u2A4A',
	cupdot: '\u228D',
	cupor: '\u2A45',
	cups: '\u222A\uFE00',
	curarr: '\u21B7',
	curarrm: '\u293C',
	curlyeqprec: '\u22DE',
	curlyeqsucc: '\u22DF',
	curlyvee: '\u22CE',
	curlywedge: '\u22CF',
	curren: '\u00A4',
	curvearrowleft: '\u21B6',
	curvearrowright: '\u21B7',
	cuvee: '\u22CE',
	cuwed: '\u22CF',
	cwconint: '\u2232',
	cwint: '\u2231',
	cylcty: '\u232D',
	Dagger: '\u2021',
	dagger: '\u2020',
	daleth: '\u2138',
	Darr: '\u21A1',
	dArr: '\u21D3',
	darr: '\u2193',
	dash: '\u2010',
	Dashv: '\u2AE4',
	dashv: '\u22A3',
	dbkarow: '\u290F',
	dblac: '\u02DD',
	Dcaron: '\u010E',
	dcaron: '\u010F',
	Dcy: '\u0414',
	dcy: '\u0434',
	DD: '\u2145',
	dd: '\u2146',
	ddagger: '\u2021',
	ddarr: '\u21CA',
	DDotrahd: '\u2911',
	ddotseq: '\u2A77',
	deg: '\u00B0',
	Del: '\u2207',
	Delta: '\u0394',
	delta: '\u03B4',
	demptyv: '\u29B1',
	dfisht: '\u297F',
	Dfr: '\uD835\uDD07',
	dfr: '\uD835\uDD21',
	dHar: '\u2965',
	dharl: '\u21C3',
	dharr: '\u21C2',
	DiacriticalAcute: '\u00B4',
	DiacriticalDot: '\u02D9',
	DiacriticalDoubleAcute: '\u02DD',
	DiacriticalGrave: '\u0060',
	DiacriticalTilde: '\u02DC',
	diam: '\u22C4',
	Diamond: '\u22C4',
	diamond: '\u22C4',
	diamondsuit: '\u2666',
	diams: '\u2666',
	die: '\u00A8',
	DifferentialD: '\u2146',
	digamma: '\u03DD',
	disin: '\u22F2',
	div: '\u00F7',
	divide: '\u00F7',
	divideontimes: '\u22C7',
	divonx: '\u22C7',
	DJcy: '\u0402',
	djcy: '\u0452',
	dlcorn: '\u231E',
	dlcrop: '\u230D',
	dollar: '\u0024',
	Dopf: '\uD835\uDD3B',
	dopf: '\uD835\uDD55',
	Dot: '\u00A8',
	dot: '\u02D9',
	DotDot: '\u20DC',
	doteq: '\u2250',
	doteqdot: '\u2251',
	DotEqual: '\u2250',
	dotminus: '\u2238',
	dotplus: '\u2214',
	dotsquare: '\u22A1',
	doublebarwedge: '\u2306',
	DoubleContourIntegral: '\u222F',
	DoubleDot: '\u00A8',
	DoubleDownArrow: '\u21D3',
	DoubleLeftArrow: '\u21D0',
	DoubleLeftRightArrow: '\u21D4',
	DoubleLeftTee: '\u2AE4',
	DoubleLongLeftArrow: '\u27F8',
	DoubleLongLeftRightArrow: '\u27FA',
	DoubleLongRightArrow: '\u27F9',
	DoubleRightArrow: '\u21D2',
	DoubleRightTee: '\u22A8',
	DoubleUpArrow: '\u21D1',
	DoubleUpDownArrow: '\u21D5',
	DoubleVerticalBar: '\u2225',
	DownArrow: '\u2193',
	Downarrow: '\u21D3',
	downarrow: '\u2193',
	DownArrowBar: '\u2913',
	DownArrowUpArrow: '\u21F5',
	DownBreve: '\u0311',
	downdownarrows: '\u21CA',
	downharpoonleft: '\u21C3',
	downharpoonright: '\u21C2',
	DownLeftRightVector: '\u2950',
	DownLeftTeeVector: '\u295E',
	DownLeftVector: '\u21BD',
	DownLeftVectorBar: '\u2956',
	DownRightTeeVector: '\u295F',
	DownRightVector: '\u21C1',
	DownRightVectorBar: '\u2957',
	DownTee: '\u22A4',
	DownTeeArrow: '\u21A7',
	drbkarow: '\u2910',
	drcorn: '\u231F',
	drcrop: '\u230C',
	Dscr: '\uD835\uDC9F',
	dscr: '\uD835\uDCB9',
	DScy: '\u0405',
	dscy: '\u0455',
	dsol: '\u29F6',
	Dstrok: '\u0110',
	dstrok: '\u0111',
	dtdot: '\u22F1',
	dtri: '\u25BF',
	dtrif: '\u25BE',
	duarr: '\u21F5',
	duhar: '\u296F',
	dwangle: '\u29A6',
	DZcy: '\u040F',
	dzcy: '\u045F',
	dzigrarr: '\u27FF',
	Eacute: '\u00C9',
	eacute: '\u00E9',
	easter: '\u2A6E',
	Ecaron: '\u011A',
	ecaron: '\u011B',
	ecir: '\u2256',
	Ecirc: '\u00CA',
	ecirc: '\u00EA',
	ecolon: '\u2255',
	Ecy: '\u042D',
	ecy: '\u044D',
	eDDot: '\u2A77',
	Edot: '\u0116',
	eDot: '\u2251',
	edot: '\u0117',
	ee: '\u2147',
	efDot: '\u2252',
	Efr: '\uD835\uDD08',
	efr: '\uD835\uDD22',
	eg: '\u2A9A',
	Egrave: '\u00C8',
	egrave: '\u00E8',
	egs: '\u2A96',
	egsdot: '\u2A98',
	el: '\u2A99',
	Element: '\u2208',
	elinters: '\u23E7',
	ell: '\u2113',
	els: '\u2A95',
	elsdot: '\u2A97',
	Emacr: '\u0112',
	emacr: '\u0113',
	empty: '\u2205',
	emptyset: '\u2205',
	EmptySmallSquare: '\u25FB',
	emptyv: '\u2205',
	EmptyVerySmallSquare: '\u25AB',
	emsp: '\u2003',
	emsp13: '\u2004',
	emsp14: '\u2005',
	ENG: '\u014A',
	eng: '\u014B',
	ensp: '\u2002',
	Eogon: '\u0118',
	eogon: '\u0119',
	Eopf: '\uD835\uDD3C',
	eopf: '\uD835\uDD56',
	epar: '\u22D5',
	eparsl: '\u29E3',
	eplus: '\u2A71',
	epsi: '\u03B5',
	Epsilon: '\u0395',
	epsilon: '\u03B5',
	epsiv: '\u03F5',
	eqcirc: '\u2256',
	eqcolon: '\u2255',
	eqsim: '\u2242',
	eqslantgtr: '\u2A96',
	eqslantless: '\u2A95',
	Equal: '\u2A75',
	equals: '\u003D',
	EqualTilde: '\u2242',
	equest: '\u225F',
	Equilibrium: '\u21CC',
	equiv: '\u2261',
	equivDD: '\u2A78',
	eqvparsl: '\u29E5',
	erarr: '\u2971',
	erDot: '\u2253',
	Escr: '\u2130',
	escr: '\u212F',
	esdot: '\u2250',
	Esim: '\u2A73',
	esim: '\u2242',
	Eta: '\u0397',
	eta: '\u03B7',
	ETH: '\u00D0',
	eth: '\u00F0',
	Euml: '\u00CB',
	euml: '\u00EB',
	euro: '\u20AC',
	excl: '\u0021',
	exist: '\u2203',
	Exists: '\u2203',
	expectation: '\u2130',
	ExponentialE: '\u2147',
	exponentiale: '\u2147',
	fallingdotseq: '\u2252',
	Fcy: '\u0424',
	fcy: '\u0444',
	female: '\u2640',
	ffilig: '\uFB03',
	fflig: '\uFB00',
	ffllig: '\uFB04',
	Ffr: '\uD835\uDD09',
	ffr: '\uD835\uDD23',
	filig: '\uFB01',
	FilledSmallSquare: '\u25FC',
	FilledVerySmallSquare: '\u25AA',
	fjlig: '\u0066\u006A',
	flat: '\u266D',
	fllig: '\uFB02',
	fltns: '\u25B1',
	fnof: '\u0192',
	Fopf: '\uD835\uDD3D',
	fopf: '\uD835\uDD57',
	ForAll: '\u2200',
	forall: '\u2200',
	fork: '\u22D4',
	forkv: '\u2AD9',
	Fouriertrf: '\u2131',
	fpartint: '\u2A0D',
	frac12: '\u00BD',
	frac13: '\u2153',
	frac14: '\u00BC',
	frac15: '\u2155',
	frac16: '\u2159',
	frac18: '\u215B',
	frac23: '\u2154',
	frac25: '\u2156',
	frac34: '\u00BE',
	frac35: '\u2157',
	frac38: '\u215C',
	frac45: '\u2158',
	frac56: '\u215A',
	frac58: '\u215D',
	frac78: '\u215E',
	frasl: '\u2044',
	frown: '\u2322',
	Fscr: '\u2131',
	fscr: '\uD835\uDCBB',
	gacute: '\u01F5',
	Gamma: '\u0393',
	gamma: '\u03B3',
	Gammad: '\u03DC',
	gammad: '\u03DD',
	gap: '\u2A86',
	Gbreve: '\u011E',
	gbreve: '\u011F',
	Gcedil: '\u0122',
	Gcirc: '\u011C',
	gcirc: '\u011D',
	Gcy: '\u0413',
	gcy: '\u0433',
	Gdot: '\u0120',
	gdot: '\u0121',
	gE: '\u2267',
	ge: '\u2265',
	gEl: '\u2A8C',
	gel: '\u22DB',
	geq: '\u2265',
	geqq: '\u2267',
	geqslant: '\u2A7E',
	ges: '\u2A7E',
	gescc: '\u2AA9',
	gesdot: '\u2A80',
	gesdoto: '\u2A82',
	gesdotol: '\u2A84',
	gesl: '\u22DB\uFE00',
	gesles: '\u2A94',
	Gfr: '\uD835\uDD0A',
	gfr: '\uD835\uDD24',
	Gg: '\u22D9',
	gg: '\u226B',
	ggg: '\u22D9',
	gimel: '\u2137',
	GJcy: '\u0403',
	gjcy: '\u0453',
	gl: '\u2277',
	gla: '\u2AA5',
	glE: '\u2A92',
	glj: '\u2AA4',
	gnap: '\u2A8A',
	gnapprox: '\u2A8A',
	gnE: '\u2269',
	gne: '\u2A88',
	gneq: '\u2A88',
	gneqq: '\u2269',
	gnsim: '\u22E7',
	Gopf: '\uD835\uDD3E',
	gopf: '\uD835\uDD58',
	grave: '\u0060',
	GreaterEqual: '\u2265',
	GreaterEqualLess: '\u22DB',
	GreaterFullEqual: '\u2267',
	GreaterGreater: '\u2AA2',
	GreaterLess: '\u2277',
	GreaterSlantEqual: '\u2A7E',
	GreaterTilde: '\u2273',
	Gscr: '\uD835\uDCA2',
	gscr: '\u210A',
	gsim: '\u2273',
	gsime: '\u2A8E',
	gsiml: '\u2A90',
	Gt: '\u226B',
	GT: '\u003E',
	gt: '\u003E',
	gtcc: '\u2AA7',
	gtcir: '\u2A7A',
	gtdot: '\u22D7',
	gtlPar: '\u2995',
	gtquest: '\u2A7C',
	gtrapprox: '\u2A86',
	gtrarr: '\u2978',
	gtrdot: '\u22D7',
	gtreqless: '\u22DB',
	gtreqqless: '\u2A8C',
	gtrless: '\u2277',
	gtrsim: '\u2273',
	gvertneqq: '\u2269\uFE00',
	gvnE: '\u2269\uFE00',
	Hacek: '\u02C7',
	hairsp: '\u200A',
	half: '\u00BD',
	hamilt: '\u210B',
	HARDcy: '\u042A',
	hardcy: '\u044A',
	hArr: '\u21D4',
	harr: '\u2194',
	harrcir: '\u2948',
	harrw: '\u21AD',
	Hat: '\u005E',
	hbar: '\u210F',
	Hcirc: '\u0124',
	hcirc: '\u0125',
	hearts: '\u2665',
	heartsuit: '\u2665',
	hellip: '\u2026',
	hercon: '\u22B9',
	Hfr: '\u210C',
	hfr: '\uD835\uDD25',
	HilbertSpace: '\u210B',
	hksearow: '\u2925',
	hkswarow: '\u2926',
	hoarr: '\u21FF',
	homtht: '\u223B',
	hookleftarrow: '\u21A9',
	hookrightarrow: '\u21AA',
	Hopf: '\u210D',
	hopf: '\uD835\uDD59',
	horbar: '\u2015',
	HorizontalLine: '\u2500',
	Hscr: '\u210B',
	hscr: '\uD835\uDCBD',
	hslash: '\u210F',
	Hstrok: '\u0126',
	hstrok: '\u0127',
	HumpDownHump: '\u224E',
	HumpEqual: '\u224F',
	hybull: '\u2043',
	hyphen: '\u2010',
	Iacute: '\u00CD',
	iacute: '\u00ED',
	ic: '\u2063',
	Icirc: '\u00CE',
	icirc: '\u00EE',
	Icy: '\u0418',
	icy: '\u0438',
	Idot: '\u0130',
	IEcy: '\u0415',
	iecy: '\u0435',
	iexcl: '\u00A1',
	iff: '\u21D4',
	Ifr: '\u2111',
	ifr: '\uD835\uDD26',
	Igrave: '\u00CC',
	igrave: '\u00EC',
	ii: '\u2148',
	iiiint: '\u2A0C',
	iiint: '\u222D',
	iinfin: '\u29DC',
	iiota: '\u2129',
	IJlig: '\u0132',
	ijlig: '\u0133',
	Im: '\u2111',
	Imacr: '\u012A',
	imacr: '\u012B',
	image: '\u2111',
	ImaginaryI: '\u2148',
	imagline: '\u2110',
	imagpart: '\u2111',
	imath: '\u0131',
	imof: '\u22B7',
	imped: '\u01B5',
	Implies: '\u21D2',
	in: '\u2208',
	incare: '\u2105',
	infin: '\u221E',
	infintie: '\u29DD',
	inodot: '\u0131',
	Int: '\u222C',
	int: '\u222B',
	intcal: '\u22BA',
	integers: '\u2124',
	Integral: '\u222B',
	intercal: '\u22BA',
	Intersection: '\u22C2',
	intlarhk: '\u2A17',
	intprod: '\u2A3C',
	InvisibleComma: '\u2063',
	InvisibleTimes: '\u2062',
	IOcy: '\u0401',
	iocy: '\u0451',
	Iogon: '\u012E',
	iogon: '\u012F',
	Iopf: '\uD835\uDD40',
	iopf: '\uD835\uDD5A',
	Iota: '\u0399',
	iota: '\u03B9',
	iprod: '\u2A3C',
	iquest: '\u00BF',
	Iscr: '\u2110',
	iscr: '\uD835\uDCBE',
	isin: '\u2208',
	isindot: '\u22F5',
	isinE: '\u22F9',
	isins: '\u22F4',
	isinsv: '\u22F3',
	isinv: '\u2208',
	it: '\u2062',
	Itilde: '\u0128',
	itilde: '\u0129',
	Iukcy: '\u0406',
	iukcy: '\u0456',
	Iuml: '\u00CF',
	iuml: '\u00EF',
	Jcirc: '\u0134',
	jcirc: '\u0135',
	Jcy: '\u0419',
	jcy: '\u0439',
	Jfr: '\uD835\uDD0D',
	jfr: '\uD835\uDD27',
	jmath: '\u0237',
	Jopf: '\uD835\uDD41',
	jopf: '\uD835\uDD5B',
	Jscr: '\uD835\uDCA5',
	jscr: '\uD835\uDCBF',
	Jsercy: '\u0408',
	jsercy: '\u0458',
	Jukcy: '\u0404',
	jukcy: '\u0454',
	Kappa: '\u039A',
	kappa: '\u03BA',
	kappav: '\u03F0',
	Kcedil: '\u0136',
	kcedil: '\u0137',
	Kcy: '\u041A',
	kcy: '\u043A',
	Kfr: '\uD835\uDD0E',
	kfr: '\uD835\uDD28',
	kgreen: '\u0138',
	KHcy: '\u0425',
	khcy: '\u0445',
	KJcy: '\u040C',
	kjcy: '\u045C',
	Kopf: '\uD835\uDD42',
	kopf: '\uD835\uDD5C',
	Kscr: '\uD835\uDCA6',
	kscr: '\uD835\uDCC0',
	lAarr: '\u21DA',
	Lacute: '\u0139',
	lacute: '\u013A',
	laemptyv: '\u29B4',
	lagran: '\u2112',
	Lambda: '\u039B',
	lambda: '\u03BB',
	Lang: '\u27EA',
	lang: '\u27E8',
	langd: '\u2991',
	langle: '\u27E8',
	lap: '\u2A85',
	Laplacetrf: '\u2112',
	laquo: '\u00AB',
	Larr: '\u219E',
	lArr: '\u21D0',
	larr: '\u2190',
	larrb: '\u21E4',
	larrbfs: '\u291F',
	larrfs: '\u291D',
	larrhk: '\u21A9',
	larrlp: '\u21AB',
	larrpl: '\u2939',
	larrsim: '\u2973',
	larrtl: '\u21A2',
	lat: '\u2AAB',
	lAtail: '\u291B',
	latail: '\u2919',
	late: '\u2AAD',
	lates: '\u2AAD\uFE00',
	lBarr: '\u290E',
	lbarr: '\u290C',
	lbbrk: '\u2772',
	lbrace: '\u007B',
	lbrack: '\u005B',
	lbrke: '\u298B',
	lbrksld: '\u298F',
	lbrkslu: '\u298D',
	Lcaron: '\u013D',
	lcaron: '\u013E',
	Lcedil: '\u013B',
	lcedil: '\u013C',
	lceil: '\u2308',
	lcub: '\u007B',
	Lcy: '\u041B',
	lcy: '\u043B',
	ldca: '\u2936',
	ldquo: '\u201C',
	ldquor: '\u201E',
	ldrdhar: '\u2967',
	ldrushar: '\u294B',
	ldsh: '\u21B2',
	lE: '\u2266',
	le: '\u2264',
	LeftAngleBracket: '\u27E8',
	LeftArrow: '\u2190',
	Leftarrow: '\u21D0',
	leftarrow: '\u2190',
	LeftArrowBar: '\u21E4',
	LeftArrowRightArrow: '\u21C6',
	leftarrowtail: '\u21A2',
	LeftCeiling: '\u2308',
	LeftDoubleBracket: '\u27E6',
	LeftDownTeeVector: '\u2961',
	LeftDownVector: '\u21C3',
	LeftDownVectorBar: '\u2959',
	LeftFloor: '\u230A',
	leftharpoondown: '\u21BD',
	leftharpoonup: '\u21BC',
	leftleftarrows: '\u21C7',
	LeftRightArrow: '\u2194',
	Leftrightarrow: '\u21D4',
	leftrightarrow: '\u2194',
	leftrightarrows: '\u21C6',
	leftrightharpoons: '\u21CB',
	leftrightsquigarrow: '\u21AD',
	LeftRightVector: '\u294E',
	LeftTee: '\u22A3',
	LeftTeeArrow: '\u21A4',
	LeftTeeVector: '\u295A',
	leftthreetimes: '\u22CB',
	LeftTriangle: '\u22B2',
	LeftTriangleBar: '\u29CF',
	LeftTriangleEqual: '\u22B4',
	LeftUpDownVector: '\u2951',
	LeftUpTeeVector: '\u2960',
	LeftUpVector: '\u21BF',
	LeftUpVectorBar: '\u2958',
	LeftVector: '\u21BC',
	LeftVectorBar: '\u2952',
	lEg: '\u2A8B',
	leg: '\u22DA',
	leq: '\u2264',
	leqq: '\u2266',
	leqslant: '\u2A7D',
	les: '\u2A7D',
	lescc: '\u2AA8',
	lesdot: '\u2A7F',
	lesdoto: '\u2A81',
	lesdotor: '\u2A83',
	lesg: '\u22DA\uFE00',
	lesges: '\u2A93',
	lessapprox: '\u2A85',
	lessdot: '\u22D6',
	lesseqgtr: '\u22DA',
	lesseqqgtr: '\u2A8B',
	LessEqualGreater: '\u22DA',
	LessFullEqual: '\u2266',
	LessGreater: '\u2276',
	lessgtr: '\u2276',
	LessLess: '\u2AA1',
	lesssim: '\u2272',
	LessSlantEqual: '\u2A7D',
	LessTilde: '\u2272',
	lfisht: '\u297C',
	lfloor: '\u230A',
	Lfr: '\uD835\uDD0F',
	lfr: '\uD835\uDD29',
	lg: '\u2276',
	lgE: '\u2A91',
	lHar: '\u2962',
	lhard: '\u21BD',
	lharu: '\u21BC',
	lharul: '\u296A',
	lhblk: '\u2584',
	LJcy: '\u0409',
	ljcy: '\u0459',
	Ll: '\u22D8',
	ll: '\u226A',
	llarr: '\u21C7',
	llcorner: '\u231E',
	Lleftarrow: '\u21DA',
	llhard: '\u296B',
	lltri: '\u25FA',
	Lmidot: '\u013F',
	lmidot: '\u0140',
	lmoust: '\u23B0',
	lmoustache: '\u23B0',
	lnap: '\u2A89',
	lnapprox: '\u2A89',
	lnE: '\u2268',
	lne: '\u2A87',
	lneq: '\u2A87',
	lneqq: '\u2268',
	lnsim: '\u22E6',
	loang: '\u27EC',
	loarr: '\u21FD',
	lobrk: '\u27E6',
	LongLeftArrow: '\u27F5',
	Longleftarrow: '\u27F8',
	longleftarrow: '\u27F5',
	LongLeftRightArrow: '\u27F7',
	Longleftrightarrow: '\u27FA',
	longleftrightarrow: '\u27F7',
	longmapsto: '\u27FC',
	LongRightArrow: '\u27F6',
	Longrightarrow: '\u27F9',
	longrightarrow: '\u27F6',
	looparrowleft: '\u21AB',
	looparrowright: '\u21AC',
	lopar: '\u2985',
	Lopf: '\uD835\uDD43',
	lopf: '\uD835\uDD5D',
	loplus: '\u2A2D',
	lotimes: '\u2A34',
	lowast: '\u2217',
	lowbar: '\u005F',
	LowerLeftArrow: '\u2199',
	LowerRightArrow: '\u2198',
	loz: '\u25CA',
	lozenge: '\u25CA',
	lozf: '\u29EB',
	lpar: '\u0028',
	lparlt: '\u2993',
	lrarr: '\u21C6',
	lrcorner: '\u231F',
	lrhar: '\u21CB',
	lrhard: '\u296D',
	lrm: '\u200E',
	lrtri: '\u22BF',
	lsaquo: '\u2039',
	Lscr: '\u2112',
	lscr: '\uD835\uDCC1',
	Lsh: '\u21B0',
	lsh: '\u21B0',
	lsim: '\u2272',
	lsime: '\u2A8D',
	lsimg: '\u2A8F',
	lsqb: '\u005B',
	lsquo: '\u2018',
	lsquor: '\u201A',
	Lstrok: '\u0141',
	lstrok: '\u0142',
	Lt: '\u226A',
	LT: '\u003C',
	lt: '\u003C',
	ltcc: '\u2AA6',
	ltcir: '\u2A79',
	ltdot: '\u22D6',
	lthree: '\u22CB',
	ltimes: '\u22C9',
	ltlarr: '\u2976',
	ltquest: '\u2A7B',
	ltri: '\u25C3',
	ltrie: '\u22B4',
	ltrif: '\u25C2',
	ltrPar: '\u2996',
	lurdshar: '\u294A',
	luruhar: '\u2966',
	lvertneqq: '\u2268\uFE00',
	lvnE: '\u2268\uFE00',
	macr: '\u00AF',
	male: '\u2642',
	malt: '\u2720',
	maltese: '\u2720',
	Map: '\u2905',
	map: '\u21A6',
	mapsto: '\u21A6',
	mapstodown: '\u21A7',
	mapstoleft: '\u21A4',
	mapstoup: '\u21A5',
	marker: '\u25AE',
	mcomma: '\u2A29',
	Mcy: '\u041C',
	mcy: '\u043C',
	mdash: '\u2014',
	mDDot: '\u223A',
	measuredangle: '\u2221',
	MediumSpace: '\u205F',
	Mellintrf: '\u2133',
	Mfr: '\uD835\uDD10',
	mfr: '\uD835\uDD2A',
	mho: '\u2127',
	micro: '\u00B5',
	mid: '\u2223',
	midast: '\u002A',
	midcir: '\u2AF0',
	middot: '\u00B7',
	minus: '\u2212',
	minusb: '\u229F',
	minusd: '\u2238',
	minusdu: '\u2A2A',
	MinusPlus: '\u2213',
	mlcp: '\u2ADB',
	mldr: '\u2026',
	mnplus: '\u2213',
	models: '\u22A7',
	Mopf: '\uD835\uDD44',
	mopf: '\uD835\uDD5E',
	mp: '\u2213',
	Mscr: '\u2133',
	mscr: '\uD835\uDCC2',
	mstpos: '\u223E',
	Mu: '\u039C',
	mu: '\u03BC',
	multimap: '\u22B8',
	mumap: '\u22B8',
	nabla: '\u2207',
	Nacute: '\u0143',
	nacute: '\u0144',
	nang: '\u2220\u20D2',
	nap: '\u2249',
	napE: '\u2A70\u0338',
	napid: '\u224B\u0338',
	napos: '\u0149',
	napprox: '\u2249',
	natur: '\u266E',
	natural: '\u266E',
	naturals: '\u2115',
	nbsp: '\u00A0',
	nbump: '\u224E\u0338',
	nbumpe: '\u224F\u0338',
	ncap: '\u2A43',
	Ncaron: '\u0147',
	ncaron: '\u0148',
	Ncedil: '\u0145',
	ncedil: '\u0146',
	ncong: '\u2247',
	ncongdot: '\u2A6D\u0338',
	ncup: '\u2A42',
	Ncy: '\u041D',
	ncy: '\u043D',
	ndash: '\u2013',
	ne: '\u2260',
	nearhk: '\u2924',
	neArr: '\u21D7',
	nearr: '\u2197',
	nearrow: '\u2197',
	nedot: '\u2250\u0338',
	NegativeMediumSpace: '\u200B',
	NegativeThickSpace: '\u200B',
	NegativeThinSpace: '\u200B',
	NegativeVeryThinSpace: '\u200B',
	nequiv: '\u2262',
	nesear: '\u2928',
	nesim: '\u2242\u0338',
	NestedGreaterGreater: '\u226B',
	NestedLessLess: '\u226A',
	NewLine: '\u000A',
	nexist: '\u2204',
	nexists: '\u2204',
	Nfr: '\uD835\uDD11',
	nfr: '\uD835\uDD2B',
	ngE: '\u2267\u0338',
	nge: '\u2271',
	ngeq: '\u2271',
	ngeqq: '\u2267\u0338',
	ngeqslant: '\u2A7E\u0338',
	nges: '\u2A7E\u0338',
	nGg: '\u22D9\u0338',
	ngsim: '\u2275',
	nGt: '\u226B\u20D2',
	ngt: '\u226F',
	ngtr: '\u226F',
	nGtv: '\u226B\u0338',
	nhArr: '\u21CE',
	nharr: '\u21AE',
	nhpar: '\u2AF2',
	ni: '\u220B',
	nis: '\u22FC',
	nisd: '\u22FA',
	niv: '\u220B',
	NJcy: '\u040A',
	njcy: '\u045A',
	nlArr: '\u21CD',
	nlarr: '\u219A',
	nldr: '\u2025',
	nlE: '\u2266\u0338',
	nle: '\u2270',
	nLeftarrow: '\u21CD',
	nleftarrow: '\u219A',
	nLeftrightarrow: '\u21CE',
	nleftrightarrow: '\u21AE',
	nleq: '\u2270',
	nleqq: '\u2266\u0338',
	nleqslant: '\u2A7D\u0338',
	nles: '\u2A7D\u0338',
	nless: '\u226E',
	nLl: '\u22D8\u0338',
	nlsim: '\u2274',
	nLt: '\u226A\u20D2',
	nlt: '\u226E',
	nltri: '\u22EA',
	nltrie: '\u22EC',
	nLtv: '\u226A\u0338',
	nmid: '\u2224',
	NoBreak: '\u2060',
	NonBreakingSpace: '\u00A0',
	Nopf: '\u2115',
	nopf: '\uD835\uDD5F',
	Not: '\u2AEC',
	not: '\u00AC',
	NotCongruent: '\u2262',
	NotCupCap: '\u226D',
	NotDoubleVerticalBar: '\u2226',
	NotElement: '\u2209',
	NotEqual: '\u2260',
	NotEqualTilde: '\u2242\u0338',
	NotExists: '\u2204',
	NotGreater: '\u226F',
	NotGreaterEqual: '\u2271',
	NotGreaterFullEqual: '\u2267\u0338',
	NotGreaterGreater: '\u226B\u0338',
	NotGreaterLess: '\u2279',
	NotGreaterSlantEqual: '\u2A7E\u0338',
	NotGreaterTilde: '\u2275',
	NotHumpDownHump: '\u224E\u0338',
	NotHumpEqual: '\u224F\u0338',
	notin: '\u2209',
	notindot: '\u22F5\u0338',
	notinE: '\u22F9\u0338',
	notinva: '\u2209',
	notinvb: '\u22F7',
	notinvc: '\u22F6',
	NotLeftTriangle: '\u22EA',
	NotLeftTriangleBar: '\u29CF\u0338',
	NotLeftTriangleEqual: '\u22EC',
	NotLess: '\u226E',
	NotLessEqual: '\u2270',
	NotLessGreater: '\u2278',
	NotLessLess: '\u226A\u0338',
	NotLessSlantEqual: '\u2A7D\u0338',
	NotLessTilde: '\u2274',
	NotNestedGreaterGreater: '\u2AA2\u0338',
	NotNestedLessLess: '\u2AA1\u0338',
	notni: '\u220C',
	notniva: '\u220C',
	notnivb: '\u22FE',
	notnivc: '\u22FD',
	NotPrecedes: '\u2280',
	NotPrecedesEqual: '\u2AAF\u0338',
	NotPrecedesSlantEqual: '\u22E0',
	NotReverseElement: '\u220C',
	NotRightTriangle: '\u22EB',
	NotRightTriangleBar: '\u29D0\u0338',
	NotRightTriangleEqual: '\u22ED',
	NotSquareSubset: '\u228F\u0338',
	NotSquareSubsetEqual: '\u22E2',
	NotSquareSuperset: '\u2290\u0338',
	NotSquareSupersetEqual: '\u22E3',
	NotSubset: '\u2282\u20D2',
	NotSubsetEqual: '\u2288',
	NotSucceeds: '\u2281',
	NotSucceedsEqual: '\u2AB0\u0338',
	NotSucceedsSlantEqual: '\u22E1',
	NotSucceedsTilde: '\u227F\u0338',
	NotSuperset: '\u2283\u20D2',
	NotSupersetEqual: '\u2289',
	NotTilde: '\u2241',
	NotTildeEqual: '\u2244',
	NotTildeFullEqual: '\u2247',
	NotTildeTilde: '\u2249',
	NotVerticalBar: '\u2224',
	npar: '\u2226',
	nparallel: '\u2226',
	nparsl: '\u2AFD\u20E5',
	npart: '\u2202\u0338',
	npolint: '\u2A14',
	npr: '\u2280',
	nprcue: '\u22E0',
	npre: '\u2AAF\u0338',
	nprec: '\u2280',
	npreceq: '\u2AAF\u0338',
	nrArr: '\u21CF',
	nrarr: '\u219B',
	nrarrc: '\u2933\u0338',
	nrarrw: '\u219D\u0338',
	nRightarrow: '\u21CF',
	nrightarrow: '\u219B',
	nrtri: '\u22EB',
	nrtrie: '\u22ED',
	nsc: '\u2281',
	nsccue: '\u22E1',
	nsce: '\u2AB0\u0338',
	Nscr: '\uD835\uDCA9',
	nscr: '\uD835\uDCC3',
	nshortmid: '\u2224',
	nshortparallel: '\u2226',
	nsim: '\u2241',
	nsime: '\u2244',
	nsimeq: '\u2244',
	nsmid: '\u2224',
	nspar: '\u2226',
	nsqsube: '\u22E2',
	nsqsupe: '\u22E3',
	nsub: '\u2284',
	nsubE: '\u2AC5\u0338',
	nsube: '\u2288',
	nsubset: '\u2282\u20D2',
	nsubseteq: '\u2288',
	nsubseteqq: '\u2AC5\u0338',
	nsucc: '\u2281',
	nsucceq: '\u2AB0\u0338',
	nsup: '\u2285',
	nsupE: '\u2AC6\u0338',
	nsupe: '\u2289',
	nsupset: '\u2283\u20D2',
	nsupseteq: '\u2289',
	nsupseteqq: '\u2AC6\u0338',
	ntgl: '\u2279',
	Ntilde: '\u00D1',
	ntilde: '\u00F1',
	ntlg: '\u2278',
	ntriangleleft: '\u22EA',
	ntrianglelefteq: '\u22EC',
	ntriangleright: '\u22EB',
	ntrianglerighteq: '\u22ED',
	Nu: '\u039D',
	nu: '\u03BD',
	num: '\u0023',
	numero: '\u2116',
	numsp: '\u2007',
	nvap: '\u224D\u20D2',
	nVDash: '\u22AF',
	nVdash: '\u22AE',
	nvDash: '\u22AD',
	nvdash: '\u22AC',
	nvge: '\u2265\u20D2',
	nvgt: '\u003E\u20D2',
	nvHarr: '\u2904',
	nvinfin: '\u29DE',
	nvlArr: '\u2902',
	nvle: '\u2264\u20D2',
	nvlt: '\u003C\u20D2',
	nvltrie: '\u22B4\u20D2',
	nvrArr: '\u2903',
	nvrtrie: '\u22B5\u20D2',
	nvsim: '\u223C\u20D2',
	nwarhk: '\u2923',
	nwArr: '\u21D6',
	nwarr: '\u2196',
	nwarrow: '\u2196',
	nwnear: '\u2927',
	Oacute: '\u00D3',
	oacute: '\u00F3',
	oast: '\u229B',
	ocir: '\u229A',
	Ocirc: '\u00D4',
	ocirc: '\u00F4',
	Ocy: '\u041E',
	ocy: '\u043E',
	odash: '\u229D',
	Odblac: '\u0150',
	odblac: '\u0151',
	odiv: '\u2A38',
	odot: '\u2299',
	odsold: '\u29BC',
	OElig: '\u0152',
	oelig: '\u0153',
	ofcir: '\u29BF',
	Ofr: '\uD835\uDD12',
	ofr: '\uD835\uDD2C',
	ogon: '\u02DB',
	Ograve: '\u00D2',
	ograve: '\u00F2',
	ogt: '\u29C1',
	ohbar: '\u29B5',
	ohm: '\u03A9',
	oint: '\u222E',
	olarr: '\u21BA',
	olcir: '\u29BE',
	olcross: '\u29BB',
	oline: '\u203E',
	olt: '\u29C0',
	Omacr: '\u014C',
	omacr: '\u014D',
	Omega: '\u03A9',
	omega: '\u03C9',
	Omicron: '\u039F',
	omicron: '\u03BF',
	omid: '\u29B6',
	ominus: '\u2296',
	Oopf: '\uD835\uDD46',
	oopf: '\uD835\uDD60',
	opar: '\u29B7',
	OpenCurlyDoubleQuote: '\u201C',
	OpenCurlyQuote: '\u2018',
	operp: '\u29B9',
	oplus: '\u2295',
	Or: '\u2A54',
	or: '\u2228',
	orarr: '\u21BB',
	ord: '\u2A5D',
	order: '\u2134',
	orderof: '\u2134',
	ordf: '\u00AA',
	ordm: '\u00BA',
	origof: '\u22B6',
	oror: '\u2A56',
	orslope: '\u2A57',
	orv: '\u2A5B',
	oS: '\u24C8',
	Oscr: '\uD835\uDCAA',
	oscr: '\u2134',
	Oslash: '\u00D8',
	oslash: '\u00F8',
	osol: '\u2298',
	Otilde: '\u00D5',
	otilde: '\u00F5',
	Otimes: '\u2A37',
	otimes: '\u2297',
	otimesas: '\u2A36',
	Ouml: '\u00D6',
	ouml: '\u00F6',
	ovbar: '\u233D',
	OverBar: '\u203E',
	OverBrace: '\u23DE',
	OverBracket: '\u23B4',
	OverParenthesis: '\u23DC',
	par: '\u2225',
	para: '\u00B6',
	parallel: '\u2225',
	parsim: '\u2AF3',
	parsl: '\u2AFD',
	part: '\u2202',
	PartialD: '\u2202',
	Pcy: '\u041F',
	pcy: '\u043F',
	percnt: '\u0025',
	period: '\u002E',
	permil: '\u2030',
	perp: '\u22A5',
	pertenk: '\u2031',
	Pfr: '\uD835\uDD13',
	pfr: '\uD835\uDD2D',
	Phi: '\u03A6',
	phi: '\u03C6',
	phiv: '\u03D5',
	phmmat: '\u2133',
	phone: '\u260E',
	Pi: '\u03A0',
	pi: '\u03C0',
	pitchfork: '\u22D4',
	piv: '\u03D6',
	planck: '\u210F',
	planckh: '\u210E',
	plankv: '\u210F',
	plus: '\u002B',
	plusacir: '\u2A23',
	plusb: '\u229E',
	pluscir: '\u2A22',
	plusdo: '\u2214',
	plusdu: '\u2A25',
	pluse: '\u2A72',
	PlusMinus: '\u00B1',
	plusmn: '\u00B1',
	plussim: '\u2A26',
	plustwo: '\u2A27',
	pm: '\u00B1',
	Poincareplane: '\u210C',
	pointint: '\u2A15',
	Popf: '\u2119',
	popf: '\uD835\uDD61',
	pound: '\u00A3',
	Pr: '\u2ABB',
	pr: '\u227A',
	prap: '\u2AB7',
	prcue: '\u227C',
	prE: '\u2AB3',
	pre: '\u2AAF',
	prec: '\u227A',
	precapprox: '\u2AB7',
	preccurlyeq: '\u227C',
	Precedes: '\u227A',
	PrecedesEqual: '\u2AAF',
	PrecedesSlantEqual: '\u227C',
	PrecedesTilde: '\u227E',
	preceq: '\u2AAF',
	precnapprox: '\u2AB9',
	precneqq: '\u2AB5',
	precnsim: '\u22E8',
	precsim: '\u227E',
	Prime: '\u2033',
	prime: '\u2032',
	primes: '\u2119',
	prnap: '\u2AB9',
	prnE: '\u2AB5',
	prnsim: '\u22E8',
	prod: '\u220F',
	Product: '\u220F',
	profalar: '\u232E',
	profline: '\u2312',
	profsurf: '\u2313',
	prop: '\u221D',
	Proportion: '\u2237',
	Proportional: '\u221D',
	propto: '\u221D',
	prsim: '\u227E',
	prurel: '\u22B0',
	Pscr: '\uD835\uDCAB',
	pscr: '\uD835\uDCC5',
	Psi: '\u03A8',
	psi: '\u03C8',
	puncsp: '\u2008',
	Qfr: '\uD835\uDD14',
	qfr: '\uD835\uDD2E',
	qint: '\u2A0C',
	Qopf: '\u211A',
	qopf: '\uD835\uDD62',
	qprime: '\u2057',
	Qscr: '\uD835\uDCAC',
	qscr: '\uD835\uDCC6',
	quaternions: '\u210D',
	quatint: '\u2A16',
	quest: '\u003F',
	questeq: '\u225F',
	QUOT: '\u0022',
	quot: '\u0022',
	rAarr: '\u21DB',
	race: '\u223D\u0331',
	Racute: '\u0154',
	racute: '\u0155',
	radic: '\u221A',
	raemptyv: '\u29B3',
	Rang: '\u27EB',
	rang: '\u27E9',
	rangd: '\u2992',
	range: '\u29A5',
	rangle: '\u27E9',
	raquo: '\u00BB',
	Rarr: '\u21A0',
	rArr: '\u21D2',
	rarr: '\u2192',
	rarrap: '\u2975',
	rarrb: '\u21E5',
	rarrbfs: '\u2920',
	rarrc: '\u2933',
	rarrfs: '\u291E',
	rarrhk: '\u21AA',
	rarrlp: '\u21AC',
	rarrpl: '\u2945',
	rarrsim: '\u2974',
	Rarrtl: '\u2916',
	rarrtl: '\u21A3',
	rarrw: '\u219D',
	rAtail: '\u291C',
	ratail: '\u291A',
	ratio: '\u2236',
	rationals: '\u211A',
	RBarr: '\u2910',
	rBarr: '\u290F',
	rbarr: '\u290D',
	rbbrk: '\u2773',
	rbrace: '\u007D',
	rbrack: '\u005D',
	rbrke: '\u298C',
	rbrksld: '\u298E',
	rbrkslu: '\u2990',
	Rcaron: '\u0158',
	rcaron: '\u0159',
	Rcedil: '\u0156',
	rcedil: '\u0157',
	rceil: '\u2309',
	rcub: '\u007D',
	Rcy: '\u0420',
	rcy: '\u0440',
	rdca: '\u2937',
	rdldhar: '\u2969',
	rdquo: '\u201D',
	rdquor: '\u201D',
	rdsh: '\u21B3',
	Re: '\u211C',
	real: '\u211C',
	realine: '\u211B',
	realpart: '\u211C',
	reals: '\u211D',
	rect: '\u25AD',
	REG: '\u00AE',
	reg: '\u00AE',
	ReverseElement: '\u220B',
	ReverseEquilibrium: '\u21CB',
	ReverseUpEquilibrium: '\u296F',
	rfisht: '\u297D',
	rfloor: '\u230B',
	Rfr: '\u211C',
	rfr: '\uD835\uDD2F',
	rHar: '\u2964',
	rhard: '\u21C1',
	rharu: '\u21C0',
	rharul: '\u296C',
	Rho: '\u03A1',
	rho: '\u03C1',
	rhov: '\u03F1',
	RightAngleBracket: '\u27E9',
	RightArrow: '\u2192',
	Rightarrow: '\u21D2',
	rightarrow: '\u2192',
	RightArrowBar: '\u21E5',
	RightArrowLeftArrow: '\u21C4',
	rightarrowtail: '\u21A3',
	RightCeiling: '\u2309',
	RightDoubleBracket: '\u27E7',
	RightDownTeeVector: '\u295D',
	RightDownVector: '\u21C2',
	RightDownVectorBar: '\u2955',
	RightFloor: '\u230B',
	rightharpoondown: '\u21C1',
	rightharpoonup: '\u21C0',
	rightleftarrows: '\u21C4',
	rightleftharpoons: '\u21CC',
	rightrightarrows: '\u21C9',
	rightsquigarrow: '\u219D',
	RightTee: '\u22A2',
	RightTeeArrow: '\u21A6',
	RightTeeVector: '\u295B',
	rightthreetimes: '\u22CC',
	RightTriangle: '\u22B3',
	RightTriangleBar: '\u29D0',
	RightTriangleEqual: '\u22B5',
	RightUpDownVector: '\u294F',
	RightUpTeeVector: '\u295C',
	RightUpVector: '\u21BE',
	RightUpVectorBar: '\u2954',
	RightVector: '\u21C0',
	RightVectorBar: '\u2953',
	ring: '\u02DA',
	risingdotseq: '\u2253',
	rlarr: '\u21C4',
	rlhar: '\u21CC',
	rlm: '\u200F',
	rmoust: '\u23B1',
	rmoustache: '\u23B1',
	rnmid: '\u2AEE',
	roang: '\u27ED',
	roarr: '\u21FE',
	robrk: '\u27E7',
	ropar: '\u2986',
	Ropf: '\u211D',
	ropf: '\uD835\uDD63',
	roplus: '\u2A2E',
	rotimes: '\u2A35',
	RoundImplies: '\u2970',
	rpar: '\u0029',
	rpargt: '\u2994',
	rppolint: '\u2A12',
	rrarr: '\u21C9',
	Rrightarrow: '\u21DB',
	rsaquo: '\u203A',
	Rscr: '\u211B',
	rscr: '\uD835\uDCC7',
	Rsh: '\u21B1',
	rsh: '\u21B1',
	rsqb: '\u005D',
	rsquo: '\u2019',
	rsquor: '\u2019',
	rthree: '\u22CC',
	rtimes: '\u22CA',
	rtri: '\u25B9',
	rtrie: '\u22B5',
	rtrif: '\u25B8',
	rtriltri: '\u29CE',
	RuleDelayed: '\u29F4',
	ruluhar: '\u2968',
	rx: '\u211E',
	Sacute: '\u015A',
	sacute: '\u015B',
	sbquo: '\u201A',
	Sc: '\u2ABC',
	sc: '\u227B',
	scap: '\u2AB8',
	Scaron: '\u0160',
	scaron: '\u0161',
	sccue: '\u227D',
	scE: '\u2AB4',
	sce: '\u2AB0',
	Scedil: '\u015E',
	scedil: '\u015F',
	Scirc: '\u015C',
	scirc: '\u015D',
	scnap: '\u2ABA',
	scnE: '\u2AB6',
	scnsim: '\u22E9',
	scpolint: '\u2A13',
	scsim: '\u227F',
	Scy: '\u0421',
	scy: '\u0441',
	sdot: '\u22C5',
	sdotb: '\u22A1',
	sdote: '\u2A66',
	searhk: '\u2925',
	seArr: '\u21D8',
	searr: '\u2198',
	searrow: '\u2198',
	sect: '\u00A7',
	semi: '\u003B',
	seswar: '\u2929',
	setminus: '\u2216',
	setmn: '\u2216',
	sext: '\u2736',
	Sfr: '\uD835\uDD16',
	sfr: '\uD835\uDD30',
	sfrown: '\u2322',
	sharp: '\u266F',
	SHCHcy: '\u0429',
	shchcy: '\u0449',
	SHcy: '\u0428',
	shcy: '\u0448',
	ShortDownArrow: '\u2193',
	ShortLeftArrow: '\u2190',
	shortmid: '\u2223',
	shortparallel: '\u2225',
	ShortRightArrow: '\u2192',
	ShortUpArrow: '\u2191',
	shy: '\u00AD',
	Sigma: '\u03A3',
	sigma: '\u03C3',
	sigmaf: '\u03C2',
	sigmav: '\u03C2',
	sim: '\u223C',
	simdot: '\u2A6A',
	sime: '\u2243',
	simeq: '\u2243',
	simg: '\u2A9E',
	simgE: '\u2AA0',
	siml: '\u2A9D',
	simlE: '\u2A9F',
	simne: '\u2246',
	simplus: '\u2A24',
	simrarr: '\u2972',
	slarr: '\u2190',
	SmallCircle: '\u2218',
	smallsetminus: '\u2216',
	smashp: '\u2A33',
	smeparsl: '\u29E4',
	smid: '\u2223',
	smile: '\u2323',
	smt: '\u2AAA',
	smte: '\u2AAC',
	smtes: '\u2AAC\uFE00',
	SOFTcy: '\u042C',
	softcy: '\u044C',
	sol: '\u002F',
	solb: '\u29C4',
	solbar: '\u233F',
	Sopf: '\uD835\uDD4A',
	sopf: '\uD835\uDD64',
	spades: '\u2660',
	spadesuit: '\u2660',
	spar: '\u2225',
	sqcap: '\u2293',
	sqcaps: '\u2293\uFE00',
	sqcup: '\u2294',
	sqcups: '\u2294\uFE00',
	Sqrt: '\u221A',
	sqsub: '\u228F',
	sqsube: '\u2291',
	sqsubset: '\u228F',
	sqsubseteq: '\u2291',
	sqsup: '\u2290',
	sqsupe: '\u2292',
	sqsupset: '\u2290',
	sqsupseteq: '\u2292',
	squ: '\u25A1',
	Square: '\u25A1',
	square: '\u25A1',
	SquareIntersection: '\u2293',
	SquareSubset: '\u228F',
	SquareSubsetEqual: '\u2291',
	SquareSuperset: '\u2290',
	SquareSupersetEqual: '\u2292',
	SquareUnion: '\u2294',
	squarf: '\u25AA',
	squf: '\u25AA',
	srarr: '\u2192',
	Sscr: '\uD835\uDCAE',
	sscr: '\uD835\uDCC8',
	ssetmn: '\u2216',
	ssmile: '\u2323',
	sstarf: '\u22C6',
	Star: '\u22C6',
	star: '\u2606',
	starf: '\u2605',
	straightepsilon: '\u03F5',
	straightphi: '\u03D5',
	strns: '\u00AF',
	Sub: '\u22D0',
	sub: '\u2282',
	subdot: '\u2ABD',
	subE: '\u2AC5',
	sube: '\u2286',
	subedot: '\u2AC3',
	submult: '\u2AC1',
	subnE: '\u2ACB',
	subne: '\u228A',
	subplus: '\u2ABF',
	subrarr: '\u2979',
	Subset: '\u22D0',
	subset: '\u2282',
	subseteq: '\u2286',
	subseteqq: '\u2AC5',
	SubsetEqual: '\u2286',
	subsetneq: '\u228A',
	subsetneqq: '\u2ACB',
	subsim: '\u2AC7',
	subsub: '\u2AD5',
	subsup: '\u2AD3',
	succ: '\u227B',
	succapprox: '\u2AB8',
	succcurlyeq: '\u227D',
	Succeeds: '\u227B',
	SucceedsEqual: '\u2AB0',
	SucceedsSlantEqual: '\u227D',
	SucceedsTilde: '\u227F',
	succeq: '\u2AB0',
	succnapprox: '\u2ABA',
	succneqq: '\u2AB6',
	succnsim: '\u22E9',
	succsim: '\u227F',
	SuchThat: '\u220B',
	Sum: '\u2211',
	sum: '\u2211',
	sung: '\u266A',
	Sup: '\u22D1',
	sup: '\u2283',
	sup1: '\u00B9',
	sup2: '\u00B2',
	sup3: '\u00B3',
	supdot: '\u2ABE',
	supdsub: '\u2AD8',
	supE: '\u2AC6',
	supe: '\u2287',
	supedot: '\u2AC4',
	Superset: '\u2283',
	SupersetEqual: '\u2287',
	suphsol: '\u27C9',
	suphsub: '\u2AD7',
	suplarr: '\u297B',
	supmult: '\u2AC2',
	supnE: '\u2ACC',
	supne: '\u228B',
	supplus: '\u2AC0',
	Supset: '\u22D1',
	supset: '\u2283',
	supseteq: '\u2287',
	supseteqq: '\u2AC6',
	supsetneq: '\u228B',
	supsetneqq: '\u2ACC',
	supsim: '\u2AC8',
	supsub: '\u2AD4',
	supsup: '\u2AD6',
	swarhk: '\u2926',
	swArr: '\u21D9',
	swarr: '\u2199',
	swarrow: '\u2199',
	swnwar: '\u292A',
	szlig: '\u00DF',
	Tab: '\u0009',
	target: '\u2316',
	Tau: '\u03A4',
	tau: '\u03C4',
	tbrk: '\u23B4',
	Tcaron: '\u0164',
	tcaron: '\u0165',
	Tcedil: '\u0162',
	tcedil: '\u0163',
	Tcy: '\u0422',
	tcy: '\u0442',
	tdot: '\u20DB',
	telrec: '\u2315',
	Tfr: '\uD835\uDD17',
	tfr: '\uD835\uDD31',
	there4: '\u2234',
	Therefore: '\u2234',
	therefore: '\u2234',
	Theta: '\u0398',
	theta: '\u03B8',
	thetasym: '\u03D1',
	thetav: '\u03D1',
	thickapprox: '\u2248',
	thicksim: '\u223C',
	ThickSpace: '\u205F\u200A',
	thinsp: '\u2009',
	ThinSpace: '\u2009',
	thkap: '\u2248',
	thksim: '\u223C',
	THORN: '\u00DE',
	thorn: '\u00FE',
	Tilde: '\u223C',
	tilde: '\u02DC',
	TildeEqual: '\u2243',
	TildeFullEqual: '\u2245',
	TildeTilde: '\u2248',
	times: '\u00D7',
	timesb: '\u22A0',
	timesbar: '\u2A31',
	timesd: '\u2A30',
	tint: '\u222D',
	toea: '\u2928',
	top: '\u22A4',
	topbot: '\u2336',
	topcir: '\u2AF1',
	Topf: '\uD835\uDD4B',
	topf: '\uD835\uDD65',
	topfork: '\u2ADA',
	tosa: '\u2929',
	tprime: '\u2034',
	TRADE: '\u2122',
	trade: '\u2122',
	triangle: '\u25B5',
	triangledown: '\u25BF',
	triangleleft: '\u25C3',
	trianglelefteq: '\u22B4',
	triangleq: '\u225C',
	triangleright: '\u25B9',
	trianglerighteq: '\u22B5',
	tridot: '\u25EC',
	trie: '\u225C',
	triminus: '\u2A3A',
	TripleDot: '\u20DB',
	triplus: '\u2A39',
	trisb: '\u29CD',
	tritime: '\u2A3B',
	trpezium: '\u23E2',
	Tscr: '\uD835\uDCAF',
	tscr: '\uD835\uDCC9',
	TScy: '\u0426',
	tscy: '\u0446',
	TSHcy: '\u040B',
	tshcy: '\u045B',
	Tstrok: '\u0166',
	tstrok: '\u0167',
	twixt: '\u226C',
	twoheadleftarrow: '\u219E',
	twoheadrightarrow: '\u21A0',
	Uacute: '\u00DA',
	uacute: '\u00FA',
	Uarr: '\u219F',
	uArr: '\u21D1',
	uarr: '\u2191',
	Uarrocir: '\u2949',
	Ubrcy: '\u040E',
	ubrcy: '\u045E',
	Ubreve: '\u016C',
	ubreve: '\u016D',
	Ucirc: '\u00DB',
	ucirc: '\u00FB',
	Ucy: '\u0423',
	ucy: '\u0443',
	udarr: '\u21C5',
	Udblac: '\u0170',
	udblac: '\u0171',
	udhar: '\u296E',
	ufisht: '\u297E',
	Ufr: '\uD835\uDD18',
	ufr: '\uD835\uDD32',
	Ugrave: '\u00D9',
	ugrave: '\u00F9',
	uHar: '\u2963',
	uharl: '\u21BF',
	uharr: '\u21BE',
	uhblk: '\u2580',
	ulcorn: '\u231C',
	ulcorner: '\u231C',
	ulcrop: '\u230F',
	ultri: '\u25F8',
	Umacr: '\u016A',
	umacr: '\u016B',
	uml: '\u00A8',
	UnderBar: '\u005F',
	UnderBrace: '\u23DF',
	UnderBracket: '\u23B5',
	UnderParenthesis: '\u23DD',
	Union: '\u22C3',
	UnionPlus: '\u228E',
	Uogon: '\u0172',
	uogon: '\u0173',
	Uopf: '\uD835\uDD4C',
	uopf: '\uD835\uDD66',
	UpArrow: '\u2191',
	Uparrow: '\u21D1',
	uparrow: '\u2191',
	UpArrowBar: '\u2912',
	UpArrowDownArrow: '\u21C5',
	UpDownArrow: '\u2195',
	Updownarrow: '\u21D5',
	updownarrow: '\u2195',
	UpEquilibrium: '\u296E',
	upharpoonleft: '\u21BF',
	upharpoonright: '\u21BE',
	uplus: '\u228E',
	UpperLeftArrow: '\u2196',
	UpperRightArrow: '\u2197',
	Upsi: '\u03D2',
	upsi: '\u03C5',
	upsih: '\u03D2',
	Upsilon: '\u03A5',
	upsilon: '\u03C5',
	UpTee: '\u22A5',
	UpTeeArrow: '\u21A5',
	upuparrows: '\u21C8',
	urcorn: '\u231D',
	urcorner: '\u231D',
	urcrop: '\u230E',
	Uring: '\u016E',
	uring: '\u016F',
	urtri: '\u25F9',
	Uscr: '\uD835\uDCB0',
	uscr: '\uD835\uDCCA',
	utdot: '\u22F0',
	Utilde: '\u0168',
	utilde: '\u0169',
	utri: '\u25B5',
	utrif: '\u25B4',
	uuarr: '\u21C8',
	Uuml: '\u00DC',
	uuml: '\u00FC',
	uwangle: '\u29A7',
	vangrt: '\u299C',
	varepsilon: '\u03F5',
	varkappa: '\u03F0',
	varnothing: '\u2205',
	varphi: '\u03D5',
	varpi: '\u03D6',
	varpropto: '\u221D',
	vArr: '\u21D5',
	varr: '\u2195',
	varrho: '\u03F1',
	varsigma: '\u03C2',
	varsubsetneq: '\u228A\uFE00',
	varsubsetneqq: '\u2ACB\uFE00',
	varsupsetneq: '\u228B\uFE00',
	varsupsetneqq: '\u2ACC\uFE00',
	vartheta: '\u03D1',
	vartriangleleft: '\u22B2',
	vartriangleright: '\u22B3',
	Vbar: '\u2AEB',
	vBar: '\u2AE8',
	vBarv: '\u2AE9',
	Vcy: '\u0412',
	vcy: '\u0432',
	VDash: '\u22AB',
	Vdash: '\u22A9',
	vDash: '\u22A8',
	vdash: '\u22A2',
	Vdashl: '\u2AE6',
	Vee: '\u22C1',
	vee: '\u2228',
	veebar: '\u22BB',
	veeeq: '\u225A',
	vellip: '\u22EE',
	Verbar: '\u2016',
	verbar: '\u007C',
	Vert: '\u2016',
	vert: '\u007C',
	VerticalBar: '\u2223',
	VerticalLine: '\u007C',
	VerticalSeparator: '\u2758',
	VerticalTilde: '\u2240',
	VeryThinSpace: '\u200A',
	Vfr: '\uD835\uDD19',
	vfr: '\uD835\uDD33',
	vltri: '\u22B2',
	vnsub: '\u2282\u20D2',
	vnsup: '\u2283\u20D2',
	Vopf: '\uD835\uDD4D',
	vopf: '\uD835\uDD67',
	vprop: '\u221D',
	vrtri: '\u22B3',
	Vscr: '\uD835\uDCB1',
	vscr: '\uD835\uDCCB',
	vsubnE: '\u2ACB\uFE00',
	vsubne: '\u228A\uFE00',
	vsupnE: '\u2ACC\uFE00',
	vsupne: '\u228B\uFE00',
	Vvdash: '\u22AA',
	vzigzag: '\u299A',
	Wcirc: '\u0174',
	wcirc: '\u0175',
	wedbar: '\u2A5F',
	Wedge: '\u22C0',
	wedge: '\u2227',
	wedgeq: '\u2259',
	weierp: '\u2118',
	Wfr: '\uD835\uDD1A',
	wfr: '\uD835\uDD34',
	Wopf: '\uD835\uDD4E',
	wopf: '\uD835\uDD68',
	wp: '\u2118',
	wr: '\u2240',
	wreath: '\u2240',
	Wscr: '\uD835\uDCB2',
	wscr: '\uD835\uDCCC',
	xcap: '\u22C2',
	xcirc: '\u25EF',
	xcup: '\u22C3',
	xdtri: '\u25BD',
	Xfr: '\uD835\uDD1B',
	xfr: '\uD835\uDD35',
	xhArr: '\u27FA',
	xharr: '\u27F7',
	Xi: '\u039E',
	xi: '\u03BE',
	xlArr: '\u27F8',
	xlarr: '\u27F5',
	xmap: '\u27FC',
	xnis: '\u22FB',
	xodot: '\u2A00',
	Xopf: '\uD835\uDD4F',
	xopf: '\uD835\uDD69',
	xoplus: '\u2A01',
	xotime: '\u2A02',
	xrArr: '\u27F9',
	xrarr: '\u27F6',
	Xscr: '\uD835\uDCB3',
	xscr: '\uD835\uDCCD',
	xsqcup: '\u2A06',
	xuplus: '\u2A04',
	xutri: '\u25B3',
	xvee: '\u22C1',
	xwedge: '\u22C0',
	Yacute: '\u00DD',
	yacute: '\u00FD',
	YAcy: '\u042F',
	yacy: '\u044F',
	Ycirc: '\u0176',
	ycirc: '\u0177',
	Ycy: '\u042B',
	ycy: '\u044B',
	yen: '\u00A5',
	Yfr: '\uD835\uDD1C',
	yfr: '\uD835\uDD36',
	YIcy: '\u0407',
	yicy: '\u0457',
	Yopf: '\uD835\uDD50',
	yopf: '\uD835\uDD6A',
	Yscr: '\uD835\uDCB4',
	yscr: '\uD835\uDCCE',
	YUcy: '\u042E',
	yucy: '\u044E',
	Yuml: '\u0178',
	yuml: '\u00FF',
	Zacute: '\u0179',
	zacute: '\u017A',
	Zcaron: '\u017D',
	zcaron: '\u017E',
	Zcy: '\u0417',
	zcy: '\u0437',
	Zdot: '\u017B',
	zdot: '\u017C',
	zeetrf: '\u2128',
	ZeroWidthSpace: '\u200B',
	Zeta: '\u0396',
	zeta: '\u03B6',
	Zfr: '\u2128',
	zfr: '\uD835\uDD37',
	ZHcy: '\u0416',
	zhcy: '\u0436',
	zigrarr: '\u21DD',
	Zopf: '\u2124',
	zopf: '\uD835\uDD6B',
	Zscr: '\uD835\uDCB5',
	zscr: '\uD835\uDCCF',
	zwj: '\u200D',
	zwnj: '\u200C',
});

/**
 * @deprecated use `HTML_ENTITIES` instead
 * @see HTML_ENTITIES
 */
exports.entityMap = exports.HTML_ENTITIES;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
exports.DOMImplementation = dom.DOMImplementation
exports.XMLSerializer = dom.XMLSerializer
exports.DOMParser = __webpack_require__(/*! ./dom-parser */ "./node_modules/@xmldom/xmldom/lib/dom-parser.js").DOMParser


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/sax.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/sax.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NAMESPACE = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").NAMESPACE;

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @param {string} message
 * @param {any?} locator Optional, can provide details about the location in the source
 * @constructor
 */
function ParseError(message, locator) {
	this.message = message
	this.locator = locator
	if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
ParseError.prototype = new Error();
ParseError.prototype.name = ParseError.name

function XMLReader(){

}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if (Object.hasOwnProperty.call(entityMap, k)) {
			return entityMap[k];
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;

	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
				var config = parseStack.pop();
				if(end<0){

	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for (var prefix in localNSMap) {
							if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
					}
		        }else{
		        	parseStack.push(config)
		        }

				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;


				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}

				if (NAMESPACE.isHTML(el.uri) && !el.closed) {
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				} else {
					end++;
				}
			}
		}catch(e){
			if (e instanceof ParseError) {
				throw e;
			}
			errorHandler.error('element parse error: '+e)
			end = -1;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (el.attributeNames.hasOwnProperty(qname)) {
			errorHandler.fatalError('Attribute ' + qname + ' redefined')
		}
		el.addValue(
			qname,
			// @see https://www.w3.org/TR/xml/#AVNormalize
			// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
			// - recursive replacement of (DTD) entity references
			// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
			value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
			startIndex
		)
	}
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName'); // No known test case
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start, p);
					addAttribute(attrName, value, start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start, p);
				addAttribute(attrName, value, start);
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="'); // No known test case
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
				break;
				case S_ATTR_SPACE:
					el.closed = true;
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')") // No known test case
			}
			break;
		case ''://end document
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!');
					addAttribute(attrName, value, start)
				}else{
					if(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					addAttribute(value, value, start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start, p);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					addAttribute(attrName, value, start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					addAttribute(attrName, attrName, start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = NAMESPACE.XMLNS
			domBuilder.startPrefixMapping(nsPrefix, value)
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = NAMESPACE.XML;
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']

				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for (prefix in localNSMap) {
				if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
					domBuilder.endPrefixMapping(prefix);
				}
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}

		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//}
}

function _copy (source, target) {
	for (var n in source) {
		if (Object.prototype.hasOwnProperty.call(source, n)) {
			target[n] = source[n];
		}
	}
}

function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA()
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = false;
			var sysid = false;
			if(len>3){
				if(/^public$/i.test(matchs[2][0])){
					pubid = matchs[3][0];
					sysid = len>4 && matchs[4][0];
				}else if(/^system$/i.test(matchs[2][0])){
					sysid = matchs[3][0];
				}
			}
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name, pubid, sysid);
			domBuilder.endDTD();

			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

function ElementAttributes(){
	this.attributeNames = {}
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	addValue:function(qName, value, offset) {
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}



function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;
exports.ParseError = ParseError;


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tencentcloud-cls-uploader-sdk/dist/cls.browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/tencentcloud-cls-uploader-sdk/dist/cls.browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
})(this, (function () { 'use strict';

  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw new Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    try {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    } catch (e) {
      return typeof fn === "function";
    }
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }

  /**
   * SDK异常错误类型
   * @internal
   */
  var ClsSDKError = /*#__PURE__*/function (_Error) {
    _inherits(ClsSDKError, _Error);
    var _super = _createSuper(ClsSDKError);
    function ClsSDKError(error) {
      var _this;
      _classCallCheck(this, ClsSDKError);
      if (typeof error === 'string') {
        _this = _super.call(this, error);
      } else {
        var _error$headers;
        _this = _super.call(this, error.message);
        _this.clsRequestId = ((_error$headers = error.headers) === null || _error$headers === void 0 ? void 0 : _error$headers['x-cls-requestid']) || '';
        _this.httpStatus = error.status;
        _this.httpCode = error.code;
      }
      return _possibleConstructorReturn(_this);
    }
    _createClass(ClsSDKError, [{
      key: "requestId",
      get:
      /**
       * 请求id
       */

      function get() {
        return this.clsRequestId;
      }
      /**
       * http状态码
       */
    }, {
      key: "status",
      get: function get() {
        return this.httpStatus;
      }
      /**
       * 接口返回状态码
       */
    }, {
      key: "code",
      get: function get() {
        return this.httpCode;
      }
    }, {
      key: "getMessage",
      value: function getMessage() {
        return this.message;
      }
    }, {
      key: "toString",
      value: function toString() {
        return '[ClsSDKError]' + 'message:' + this.getMessage() + '  requestId:' + this.requestId;
      }
    }, {
      key: "toLocaleString",
      value: function toLocaleString() {
        return '[ClsSDKError]' + 'message:' + this.getMessage() + '  requestId:' + this.requestId;
      }
    }]);
    return ClsSDKError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function isString$1(s) {
    return typeof s === 'string';
  }
  function wait(time) {
    return new Promise(function (resolve) {
      setTimeout(resolve, time);
    });
  }
  function isNotEmpty(value) {
    return value !== undefined && value !== null && value !== '';
  }

  var ClientConfig = /*#__PURE__*/function () {
    function ClientConfig(options) {
      _classCallCheck(this, ClientConfig);
      _defineProperty(this, "clsTopicId", '');
      _defineProperty(this, "region", undefined);
      _defineProperty(this, "endpoint", undefined);
      _defineProperty(this, "api", undefined);
      _defineProperty(this, "clsCredential", undefined);
      _defineProperty(this, "getAuthorization", undefined);
      _defineProperty(this, "maxRetainDuration", 20);
      _defineProperty(this, "maxRetainSize", 30);
      _defineProperty(this, "logExpiredDays", 7);
      _defineProperty(this, "logPath", '');
      _defineProperty(this, "httpAdapter", undefined);
      _defineProperty(this, "autoFillSourceIp", undefined);
      _defineProperty(this, "sourceIp", undefined);
      _defineProperty(this, "proxy", undefined);
      _defineProperty(this, "getAgent", undefined);
      if (!options.topicId || typeof options.topicId !== 'string') {
        throw new ClsSDKError('topicId is required and must be a string');
      }
      if (options.region && isNotEmpty(options.region)) {
        this.region = options.region;
      } else if (options.endpoint && isNotEmpty(options.endpoint)) {
        this.endpoint = options.endpoint;
      } else {
        throw new ClsSDKError('region or endpoint is required');
      }
      if (isNotEmpty(options.api)) {
        this.api = options.api;
      }
      if (isNotEmpty(options.sourceIp)) {
        this.sourceIp = options.sourceIp;
      }
      if (isNotEmpty(options.autoFillSourceIp)) {
        this.autoFillSourceIp = options.autoFillSourceIp;
      }
      if (isNotEmpty(options.credential)) {
        this.clsCredential = options.credential;
      }
      if (isNotEmpty(options.getAuthorization)) {
        this.getAuthorization = options.getAuthorization;
      }
      if (isNotEmpty(options.proxy)) {
        this.proxy = options.proxy;
      }
      if (isNotEmpty(options.getAgent)) {
        this.getAgent = options.getAgent;
      }
      if (isNotEmpty(options.httpAdapter)) {
        this.httpAdapter = options.httpAdapter;
      }
      if (options.maxRetainDuration) {
        this.maxRetainDuration = options.maxRetainDuration;
      }
      if (options.maxRetainSize) {
        this.maxRetainSize = options.maxRetainSize;
      }
      if (options.logExpiredDays) {
        this.logExpiredDays = options.logExpiredDays;
      }
      if (options.logPath) {
        this.logPath = options.logPath;
      }
      if (options.onError) {
        this.onError = options.onError;
      }
      this.clsTopicId = options.topicId;
    }
    _createClass(ClientConfig, [{
      key: "topicId",
      get: function get() {
        return this.clsTopicId;
      }
    }, {
      key: "credential",
      get: function get() {
        return this.clsCredential;
      }
    }, {
      key: "onError",
      value: function onError(_error) {}
    }]);
    return ClientConfig;
  }();

  function bind(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // utils is a library of generic helper functions non-specific to axios

  const {toString} = Object.prototype;
  const {getPrototypeOf} = Object;

  const kindOf = (cache => thing => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(Object.create(null));

  const kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type
  };

  const typeOfTest = type => thing => typeof thing === type;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   *
   * @returns {boolean} True if value is an Array, otherwise false
   */
  const {isArray} = Array;

  /**
   * Determine if a value is undefined
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  const isUndefined = typeOfTest('undefined');

  /**
   * Determine if a value is a Buffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
      && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  const isArrayBuffer = kindOfTest('ArrayBuffer');


  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    let result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a String, otherwise false
   */
  const isString = typeOfTest('string');

  /**
   * Determine if a value is a Function
   *
   * @param {*} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  const isFunction = typeOfTest('function');

  /**
   * Determine if a value is a Number
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Number, otherwise false
   */
  const isNumber = typeOfTest('number');

  /**
   * Determine if a value is an Object
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an Object, otherwise false
   */
  const isObject = (thing) => thing !== null && typeof thing === 'object';

  /**
   * Determine if a value is a Boolean
   *
   * @param {*} thing The value to test
   * @returns {boolean} True if value is a Boolean, otherwise false
   */
  const isBoolean = thing => thing === true || thing === false;

  /**
   * Determine if a value is a plain Object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a plain Object, otherwise false
   */
  const isPlainObject = (val) => {
    if (kindOf(val) !== 'object') {
      return false;
    }

    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };

  /**
   * Determine if a value is a Date
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Date, otherwise false
   */
  const isDate = kindOfTest('Date');

  /**
   * Determine if a value is a File
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFile = kindOfTest('File');

  /**
   * Determine if a value is a Blob
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  const isBlob = kindOfTest('Blob');

  /**
   * Determine if a value is a FileList
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  const isFileList = kindOfTest('FileList');

  /**
   * Determine if a value is a Stream
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  const isStream = (val) => isObject(val) && isFunction(val.pipe);

  /**
   * Determine if a value is a FormData
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  const isFormData = (thing) => {
    let kind;
    return thing && (
      (typeof FormData === 'function' && thing instanceof FormData) || (
        isFunction(thing.append) && (
          (kind = kindOf(thing)) === 'formdata' ||
          // detect form-data instance
          (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
        )
      )
    )
  };

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  const isURLSearchParams = kindOfTest('URLSearchParams');

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   *
   * @returns {String} The String freed of excess whitespace
   */
  const trim = (str) => str.trim ?
    str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   *
   * @param {Boolean} [allOwnKeys = false]
   * @returns {any}
   */
  function forEach(obj, fn, {allOwnKeys = false} = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    let i;
    let l;

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys.length;
      let key;

      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }

  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }

  const _global = (() => {
    /*eslint no-undef:0*/
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
  })();

  const isContextDefined = (context) => !isUndefined(context) && context !== _global;

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   *
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    const {caseless} = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };

    for (let i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   *
   * @param {Boolean} [allOwnKeys]
   * @returns {Object} The resulting value of object a
   */
  const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
    forEach(b, (val, key) => {
      if (thisArg && isFunction(val)) {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    }, {allOwnKeys});
    return a;
  };

  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   *
   * @returns {string} content value without BOM
   */
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }
    return content;
  };

  /**
   * Inherit the prototype methods from one constructor into another
   * @param {function} constructor
   * @param {function} superConstructor
   * @param {object} [props]
   * @param {object} [descriptors]
   *
   * @returns {void}
   */
  const inherits = (constructor, superConstructor, props, descriptors) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, 'super', {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };

  /**
   * Resolve object with deep prototype chain to a flat object
   * @param {Object} sourceObj source object
   * @param {Object} [destObj]
   * @param {Function|Boolean} [filter]
   * @param {Function} [propFilter]
   *
   * @returns {Object}
   */
  const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};

    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;

    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

    return destObj;
  };

  /**
   * Determines whether a string ends with the characters of a specified string
   *
   * @param {String} str
   * @param {String} searchString
   * @param {Number} [position= 0]
   *
   * @returns {boolean}
   */
  const endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === undefined || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };


  /**
   * Returns new array from array like object or null if failed
   *
   * @param {*} [thing]
   *
   * @returns {?Array}
   */
  const toArray = (thing) => {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };

  /**
   * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
   * thing passed in is an instance of Uint8Array
   *
   * @param {TypedArray}
   *
   * @returns {Array}
   */
  // eslint-disable-next-line func-names
  const isTypedArray = (TypedArray => {
    // eslint-disable-next-line func-names
    return thing => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

  /**
   * For each entry in the object, call the function with the key and value.
   *
   * @param {Object<any, any>} obj - The object to iterate over.
   * @param {Function} fn - The function to call for each entry.
   *
   * @returns {void}
   */
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];

    const iterator = generator.call(obj);

    let result;

    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };

  /**
   * It takes a regular expression and a string, and returns an array of all the matches
   *
   * @param {string} regExp - The regular expression to match against.
   * @param {string} str - The string to search.
   *
   * @returns {Array<boolean>}
   */
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];

    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }

    return arr;
  };

  /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
  const isHTMLForm = kindOfTest('HTMLFormElement');

  const toCamelCase = str => {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
      function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };

  /* Creating a function that will check if an object has a property. */
  const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

  /**
   * Determine if a value is a RegExp object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a RegExp object, otherwise false
   */
  const isRegExp = kindOfTest('RegExp');

  const reduceDescriptors = (obj, reducer) => {
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};

    forEach(descriptors, (descriptor, name) => {
      let ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });

    Object.defineProperties(obj, reducedDescriptors);
  };

  /**
   * Makes all methods read-only
   * @param {Object} obj
   */

  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      // skip restricted props in strict mode
      if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
        return false;
      }

      const value = obj[name];

      if (!isFunction(value)) return;

      descriptor.enumerable = false;

      if ('writable' in descriptor) {
        descriptor.writable = false;
        return;
      }

      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error('Can not rewrite read-only method \'' + name + '\'');
        };
      }
    });
  };

  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};

    const define = (arr) => {
      arr.forEach(value => {
        obj[value] = true;
      });
    };

    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

    return obj;
  };

  const noop$1 = () => {};

  const toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };

  const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

  const DIGIT = '0123456789';

  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };

  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = '';
    const {length} = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length|0];
    }

    return str;
  };

  /**
   * If the thing is a FormData object, return true, otherwise return false.
   *
   * @param {unknown} thing - The thing to check.
   *
   * @returns {boolean}
   */
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
  }

  const toJSONObject = (obj) => {
    const stack = new Array(10);

    const visit = (source, i) => {

      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }

        if(!('toJSON' in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};

          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });

          stack[i] = undefined;

          return target;
        }
      }

      return source;
    };

    return visit(obj, 0);
  };

  const isAsyncFn = kindOfTest('AsyncFunction');

  const isThenable = (thing) =>
    thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

  var utils$1 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$1,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  function AxiosError(message, code, config, request, response) {
    Error.call(this);

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error()).stack;
    }

    this.message = message;
    this.name = 'AxiosError';
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }

  utils$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });

  const prototype$1 = AxiosError.prototype;
  const descriptors = {};

  [
    'ERR_BAD_OPTION_VALUE',
    'ERR_BAD_OPTION',
    'ECONNABORTED',
    'ETIMEDOUT',
    'ERR_NETWORK',
    'ERR_FR_TOO_MANY_REDIRECTS',
    'ERR_DEPRECATED',
    'ERR_BAD_RESPONSE',
    'ERR_BAD_REQUEST',
    'ERR_CANCELED',
    'ERR_NOT_SUPPORT',
    'ERR_INVALID_URL'
  // eslint-disable-next-line func-names
  ].forEach(code => {
    descriptors[code] = {value: code};
  });

  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

  // eslint-disable-next-line func-names
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);

    utils$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, prop => {
      return prop !== 'isAxiosError';
    });

    AxiosError.call(axiosError, error.message, code, config, request, response);

    axiosError.cause = error;

    axiosError.name = error.name;

    customProps && Object.assign(axiosError, customProps);

    return axiosError;
  };

  // eslint-disable-next-line strict
  var httpAdapter = null;

  /**
   * Determines if the given thing is a array or js object.
   *
   * @param {string} thing - The object or array to be visited.
   *
   * @returns {boolean}
   */
  function isVisitable(thing) {
    return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
  }

  /**
   * It removes the brackets from the end of a string
   *
   * @param {string} key - The key of the parameter.
   *
   * @returns {string} the key without the brackets.
   */
  function removeBrackets(key) {
    return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
  }

  /**
   * It takes a path, a key, and a boolean, and returns a string
   *
   * @param {string} path - The path to the current key.
   * @param {string} key - The key of the current object being iterated over.
   * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
   *
   * @returns {string} The path to the current key.
   */
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      // eslint-disable-next-line no-param-reassign
      token = removeBrackets(token);
      return !dots && i ? '[' + token + ']' : token;
    }).join(dots ? '.' : '');
  }

  /**
   * If the array is an array and none of its elements are visitable, then it's a flat array.
   *
   * @param {Array<any>} arr - The array to check
   *
   * @returns {boolean}
   */
  function isFlatArray(arr) {
    return utils$1.isArray(arr) && !arr.some(isVisitable);
  }

  const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });

  /**
   * Convert a data object to FormData
   *
   * @param {Object} obj
   * @param {?Object} [formData]
   * @param {?Object} [options]
   * @param {Function} [options.visitor]
   * @param {Boolean} [options.metaTokens = true]
   * @param {Boolean} [options.dots = false]
   * @param {?Boolean} [options.indexes = false]
   *
   * @returns {Object}
   **/

  /**
   * It converts an object into a FormData object
   *
   * @param {Object<any, any>} obj - The object to convert to form data.
   * @param {string} formData - The FormData object to append to.
   * @param {Object<string, any>} options
   *
   * @returns
   */
  function toFormData(obj, formData, options) {
    if (!utils$1.isObject(obj)) {
      throw new TypeError('target must be an object');
    }

    // eslint-disable-next-line no-param-reassign
    formData = formData || new (FormData)();

    // eslint-disable-next-line no-param-reassign
    options = utils$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      // eslint-disable-next-line no-eq-null,eqeqeq
      return !utils$1.isUndefined(source[option]);
    });

    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
    const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

    if (!utils$1.isFunction(visitor)) {
      throw new TypeError('visitor must be a function');
    }

    function convertValue(value) {
      if (value === null) return '';

      if (utils$1.isDate(value)) {
        return value.toISOString();
      }

      if (!useBlob && utils$1.isBlob(value)) {
        throw new AxiosError('Blob is not supported. Use a Buffer instead.');
      }

      if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
        return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
      }

      return value;
    }

    /**
     * Default visitor.
     *
     * @param {*} value
     * @param {String|Number} key
     * @param {Array<String|Number>} path
     * @this {FormData}
     *
     * @returns {boolean} return true to visit the each prop of the value recursively
     */
    function defaultVisitor(value, key, path) {
      let arr = value;

      if (value && !path && typeof value === 'object') {
        if (utils$1.endsWith(key, '{}')) {
          // eslint-disable-next-line no-param-reassign
          key = metaTokens ? key : key.slice(0, -2);
          // eslint-disable-next-line no-param-reassign
          value = JSON.stringify(value);
        } else if (
          (utils$1.isArray(value) && isFlatArray(value)) ||
          ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
          )) {
          // eslint-disable-next-line no-param-reassign
          key = removeBrackets(key);

          arr.forEach(function each(el, index) {
            !(utils$1.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
              convertValue(el)
            );
          });
          return false;
        }
      }

      if (isVisitable(value)) {
        return true;
      }

      formData.append(renderKey(path, key, dots), convertValue(value));

      return false;
    }

    const stack = [];

    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });

    function build(value, path) {
      if (utils$1.isUndefined(value)) return;

      if (stack.indexOf(value) !== -1) {
        throw Error('Circular reference detected in ' + path.join('.'));
      }

      stack.push(value);

      utils$1.forEach(value, function each(el, key) {
        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
          formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
        );

        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });

      stack.pop();
    }

    if (!utils$1.isObject(obj)) {
      throw new TypeError('data must be an object');
    }

    build(obj);

    return formData;
  }

  /**
   * It encodes a string by replacing all characters that are not in the unreserved set with
   * their percent-encoded equivalents
   *
   * @param {string} str - The string to encode.
   *
   * @returns {string} The encoded string.
   */
  function encode$1(str) {
    const charMap = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }

  /**
   * It takes a params object and converts it to a FormData object
   *
   * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
   * @param {Object<string, any>} options - The options object passed to the Axios constructor.
   *
   * @returns {void}
   */
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];

    params && toFormData(params, this, options);
  }

  const prototype = AxiosURLSearchParams.prototype;

  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };

  prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;

    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + '=' + _encode(pair[1]);
    }, '').join('&');
  };

  /**
   * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
   * URI encoded counterparts
   *
   * @param {string} val The value to be encoded.
   *
   * @returns {string} The encoded value.
   */
  function encode(val) {
    return encodeURIComponent(val).
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @param {?object} options
   *
   * @returns {string} The formatted url
   */
  function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }
    
    const _encode = options && options.encode || encode;

    const serializeFn = options && options.serialize;

    let serializedParams;

    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1.isURLSearchParams(params) ?
        params.toString() :
        new AxiosURLSearchParams(params, options).toString(_encode);
    }

    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");

      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  }

  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }

    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$1.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }

  var InterceptorManager$1 = InterceptorManager;

  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

  var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

  var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
  };

  const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   *
   * @returns {boolean}
   */
  const hasStandardBrowserEnv = (
    (product) => {
      return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0
    })(typeof navigator !== 'undefined' && navigator.product);

  /**
   * Determine if we're running in a standard browser webWorker environment
   *
   * Although the `isStandardBrowserEnv` method indicates that
   * `allows axios to run in a web worker`, the WebWorker will still be
   * filtered out due to its judgment standard
   * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
   * This leads to a problem when axios post `FormData` in webWorker
   */
  const hasStandardBrowserWebWorkerEnv = (() => {
    return (
      typeof WorkerGlobalScope !== 'undefined' &&
      // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope &&
      typeof self.importScripts === 'function'
    );
  })();

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv
  });

  var platform = {
    ...utils,
    ...platform$1
  };

  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path, helpers) {
        if (platform.isNode && utils$1.isBuffer(value)) {
          this.append(key, value.toString('base64'));
          return false;
        }

        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  /**
   * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
   *
   * @param {string} name - The name of the property to get.
   *
   * @returns An array of strings.
   */
  function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
      return match[0] === '[]' ? '' : match[1] || match[0];
    });
  }

  /**
   * Convert an array to an object.
   *
   * @param {Array<any>} arr - The array to convert to an object.
   *
   * @returns An object with the same keys and values as the array.
   */
  function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }

  /**
   * It takes a FormData object and returns a JavaScript object
   *
   * @param {string} formData The FormData object to convert to JSON.
   *
   * @returns {Object<string, any> | null} The converted object.
   */
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      let name = path[index++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index >= path.length;
      name = !name && utils$1.isArray(target) ? target.length : name;

      if (isLast) {
        if (utils$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }

        return !isNumericKey;
      }

      if (!target[name] || !utils$1.isObject(target[name])) {
        target[name] = [];
      }

      const result = buildPath(path, value, target[name], index);

      if (result && utils$1.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }

      return !isNumericKey;
    }

    if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
      const obj = {};

      utils$1.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });

      return obj;
    }

    return null;
  }

  /**
   * It takes a string, tries to parse it, and if it fails, it returns the stringified version
   * of the input
   *
   * @param {any} rawValue - The value to be stringified.
   * @param {Function} parser - A function that parses a string into a JavaScript object.
   * @param {Function} encoder - A function that takes a value and returns a string.
   *
   * @returns {string} A stringified version of the rawValue.
   */
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1.trim(rawValue);
      } catch (e) {
        if (e.name !== 'SyntaxError') {
          throw e;
        }
      }
    }

    return (encoder || JSON.stringify)(rawValue);
  }

  const defaults = {

    transitional: transitionalDefaults,

    adapter: ['xhr', 'http'],

    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || '';
      const hasJSONContentType = contentType.indexOf('application/json') > -1;
      const isObjectPayload = utils$1.isObject(data);

      if (isObjectPayload && utils$1.isHTMLForm(data)) {
        data = new FormData(data);
      }

      const isFormData = utils$1.isFormData(data);

      if (isFormData) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }

      if (utils$1.isArrayBuffer(data) ||
        utils$1.isBuffer(data) ||
        utils$1.isStream(data) ||
        utils$1.isFile(data) ||
        utils$1.isBlob(data)
      ) {
        return data;
      }
      if (utils$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1.isURLSearchParams(data)) {
        headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
        return data.toString();
      }

      let isFileList;

      if (isObjectPayload) {
        if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }

        if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
          const _FormData = this.env && this.env.FormData;

          return toFormData(
            isFileList ? {'files[]': data} : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }

      if (isObjectPayload || hasJSONContentType ) {
        headers.setContentType('application/json', false);
        return stringifySafely(data);
      }

      return data;
    }],

    transformResponse: [function transformResponse(data) {
      const transitional = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === 'json';

      if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;

        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === 'SyntaxError') {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }

      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,
    maxBodyLength: -1,

    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },

    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*',
        'Content-Type': undefined
      }
    }
  };

  utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
    defaults.headers[method] = {};
  });

  var defaults$1 = defaults;

  // RawAxiosHeaders whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  const ignoreDuplicateOf = utils$1.toObjectSet([
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ]);

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} rawHeaders Headers needing to be parsed
   *
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = rawHeaders => {
    const parsed = {};
    let key;
    let val;
    let i;

    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
      i = line.indexOf(':');
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();

      if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
        return;
      }

      if (key === 'set-cookie') {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    });

    return parsed;
  };

  const $internals = Symbol('internals');

  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }

  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }

    return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }

  function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;

    while ((match = tokensRE.exec(str))) {
      tokens[match[1]] = match[2];
    }

    return tokens;
  }

  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }

    if (isHeaderNameFilter) {
      value = header;
    }

    if (!utils$1.isString(value)) return;

    if (utils$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }

    if (utils$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }

  function formatHeader(header) {
    return header.trim()
      .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
  }

  function buildAccessors(obj, header) {
    const accessorName = utils$1.toCamelCase(' ' + header);

    ['get', 'set', 'has'].forEach(methodName => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }

  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }

    set(header, valueOrRewrite, rewrite) {
      const self = this;

      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);

        if (!lHeader) {
          throw new Error('header name must be a non-empty string');
        }

        const key = utils$1.findKey(self, lHeader);

        if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
          self[key || _header] = normalizeValue(_value);
        }
      }

      const setHeaders = (headers, _rewrite) =>
        utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

      if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }

      return this;
    }

    get(header, parser) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$1.findKey(this, header);

        if (key) {
          const value = this[key];

          if (!parser) {
            return value;
          }

          if (parser === true) {
            return parseTokens(value);
          }

          if (utils$1.isFunction(parser)) {
            return parser.call(this, value, key);
          }

          if (utils$1.isRegExp(parser)) {
            return parser.exec(value);
          }

          throw new TypeError('parser must be boolean|regexp|function');
        }
      }
    }

    has(header, matcher) {
      header = normalizeHeader(header);

      if (header) {
        const key = utils$1.findKey(this, header);

        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }

      return false;
    }

    delete(header, matcher) {
      const self = this;
      let deleted = false;

      function deleteHeader(_header) {
        _header = normalizeHeader(_header);

        if (_header) {
          const key = utils$1.findKey(self, _header);

          if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
            delete self[key];

            deleted = true;
          }
        }
      }

      if (utils$1.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }

      return deleted;
    }

    clear(matcher) {
      const keys = Object.keys(this);
      let i = keys.length;
      let deleted = false;

      while (i--) {
        const key = keys[i];
        if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }

      return deleted;
    }

    normalize(format) {
      const self = this;
      const headers = {};

      utils$1.forEach(this, (value, header) => {
        const key = utils$1.findKey(headers, header);

        if (key) {
          self[key] = normalizeValue(value);
          delete self[header];
          return;
        }

        const normalized = format ? formatHeader(header) : String(header).trim();

        if (normalized !== header) {
          delete self[header];
        }

        self[normalized] = normalizeValue(value);

        headers[normalized] = true;
      });

      return this;
    }

    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }

    toJSON(asStrings) {
      const obj = Object.create(null);

      utils$1.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
      });

      return obj;
    }

    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }

    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
    }

    get [Symbol.toStringTag]() {
      return 'AxiosHeaders';
    }

    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }

    static concat(first, ...targets) {
      const computed = new this(first);

      targets.forEach((target) => computed.set(target));

      return computed;
    }

    static accessor(header) {
      const internals = this[$internals] = (this[$internals] = {
        accessors: {}
      });

      const accessors = internals.accessors;
      const prototype = this.prototype;

      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);

        if (!accessors[lHeader]) {
          buildAccessors(prototype, _header);
          accessors[lHeader] = true;
        }
      }

      utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

      return this;
    }
  }

  AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

  // reserved names hotfix
  utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    }
  });

  utils$1.freezeMethods(AxiosHeaders);

  var AxiosHeaders$1 = AxiosHeaders;

  /**
   * Transform the data for a request or a response
   *
   * @param {Array|Function} fns A single function or Array of functions
   * @param {?Object} response The response object
   *
   * @returns {*} The resulting transformed data
   */
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;

    utils$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });

    headers.normalize();

    return data;
  }

  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
    this.name = 'CanceledError';
  }

  utils$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   *
   * @returns {object} The response.
   */
  function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        'Request failed with status code ' + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  var cookies = platform.hasStandardBrowserEnv ?

    // Standard browser envs support document.cookie
    {
      write(name, value, expires, path, domain, secure) {
        const cookie = [name + '=' + encodeURIComponent(value)];

        utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

        utils$1.isString(path) && cookie.push('path=' + path);

        utils$1.isString(domain) && cookie.push('domain=' + domain);

        secure === true && cookie.push('secure');

        document.cookie = cookie.join('; ');
      },

      read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    }

    :

    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {},
      read() {
        return null;
      },
      remove() {}
    };

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   *
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   *
   * @returns {string} The combined URL
   */
  function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  }

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   *
   * @returns {string} The combined full path
   */
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  var isURLSameOrigin = platform.hasStandardBrowserEnv ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement('a');
      let originURL;

      /**
      * Parse a URL to discover its components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
      function resolveURL(url) {
        let href = url;

        if (msie) {
          // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
      return function isURLSameOrigin(requestURL) {
        const parsed = (utils$1.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })();

  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || '';
  }

  /**
   * Calculate data maxRate
   * @param {Number} [samplesCount= 10]
   * @param {Number} [min= 1000]
   * @returns {Function}
   */
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;

    min = min !== undefined ? min : 1000;

    return function push(chunkLength) {
      const now = Date.now();

      const startedAt = timestamps[tail];

      if (!firstSampleTS) {
        firstSampleTS = now;
      }

      bytes[head] = chunkLength;
      timestamps[head] = now;

      let i = tail;
      let bytesCount = 0;

      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }

      head = (head + 1) % samplesCount;

      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }

      if (now - firstSampleTS < min) {
        return;
      }

      const passed = startedAt && now - startedAt;

      return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
  }

  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);

    return e => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : undefined;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;

      bytesNotified = loaded;

      const data = {
        loaded,
        total,
        progress: total ? (loaded / total) : undefined,
        bytes: progressBytes,
        rate: rate ? rate : undefined,
        estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
        event: e
      };

      data[isDownloadStream ? 'download' : 'upload'] = true;

      listener(data);
    };
  }

  const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

  var xhrAdapter = isXHRAdapterSupported && function (config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = config.data;
      const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
      let {responseType, withXSRFToken} = config;
      let onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }

        if (config.signal) {
          config.signal.removeEventListener('abort', onCanceled);
        }
      }

      let contentType;

      if (utils$1.isFormData(requestData)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false); // Let the browser set it
        } else if ((contentType = requestHeaders.getContentType()) !== false) {
          // fix semicolon duplication issue for ReactNative FormData implementation
          const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
          requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
        }
      }

      let request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        const username = config.auth.username || '';
        const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
        requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
      }

      const fullPath = buildFullPath(config.baseURL, config.url);

      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      function onloadend() {
        if (!request) {
          return;
        }
        // Prepare the response
        const responseHeaders = AxiosHeaders$1.from(
          'getAllResponseHeaders' in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
          request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };

        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);

        // Clean up request
        request = null;
      }

      if ('onloadend' in request) {
        // Use onloadend if available
        request.onloadend = onloadend;
      } else {
        // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }
          // readystate handler is calling before onerror or ontimeout handlers,
          // so we should call onloadend on the next 'tick'
          setTimeout(onloadend);
        };
      }

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if(platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));

        if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(fullPath))) {
          // Add xsrf header
          const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
      }

      // Remove Content-Type if data is undefined
      requestData === undefined && requestHeaders.setContentType(null);

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }

      // Add withCredentials to request if needed
      if (!utils$1.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }

      // Add responseType to request if needed
      if (responseType && responseType !== 'json') {
        request.responseType = config.responseType;
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
      }

      if (config.cancelToken || config.signal) {
        // Handle cancellation
        // eslint-disable-next-line func-names
        onCanceled = cancel => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };

        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
        }
      }

      const protocol = parseProtocol(fullPath);

      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
        return;
      }


      // Send the request
      request.send(requestData || null);
    });
  };

  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };

  utils$1.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, 'name', {value});
      } catch (e) {
        // eslint-disable-next-line no-empty
      }
      Object.defineProperty(fn, 'adapterName', {value});
    }
  });

  const renderReason = (reason) => `- ${reason}`;

  const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

  var adapters = {
    getAdapter: (adapters) => {
      adapters = utils$1.isArray(adapters) ? adapters : [adapters];

      const {length} = adapters;
      let nameOrAdapter;
      let adapter;

      const rejectedReasons = {};

      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters[i];
        let id;

        adapter = nameOrAdapter;

        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

          if (adapter === undefined) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }

        if (adapter) {
          break;
        }

        rejectedReasons[id || '#' + i] = adapter;
      }

      if (!adapter) {

        const reasons = Object.entries(rejectedReasons)
          .map(([id, state]) => `adapter ${id} ` +
            (state === false ? 'is not supported by the environment' : 'is not available in the build')
          );

        let s = length ?
          (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
          'as no adapter specified';

        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          'ERR_NOT_SUPPORT'
        );
      }

      return adapter;
    },
    adapters: knownAdapters
  };

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   *
   * @param {Object} config The config that is to be used for the request
   *
   * @returns {void}
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }

    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    config.headers = AxiosHeaders$1.from(config.headers);

    // Transform request data
    config.data = transformData.call(
      config,
      config.transformRequest
    );

    if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
      config.headers.setContentType('application/x-www-form-urlencoded', false);
    }

    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );

      response.headers = AxiosHeaders$1.from(response.headers);

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }

      return Promise.reject(reason);
    });
  }

  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   *
   * @returns {Object} New object resulting from merging config2 to config1
   */
  function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};

    function getMergedValue(target, source, caseless) {
      if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
        return utils$1.merge.call({caseless}, target, source);
      } else if (utils$1.isPlainObject(source)) {
        return utils$1.merge({}, source);
      } else if (utils$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }

    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a, caseless);
      }
    }

    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      }
    }

    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
      if (!utils$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      } else if (!utils$1.isUndefined(a)) {
        return getMergedValue(undefined, a);
      }
    }

    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(undefined, a);
      }
    }

    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };

    utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge(config1[prop], config2[prop], prop);
      (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
    });

    return config;
  }

  const VERSION = "1.6.2";

  const validators$1 = {};

  // eslint-disable-next-line func-names
  ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
    validators$1[type] = function validator(thing) {
      return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
  });

  const deprecatedWarnings = {};

  /**
   * Transitional option validator
   *
   * @param {function|boolean?} validator - set to false if the transitional option has been removed
   * @param {string?} version - deprecated version / removed since version
   * @param {string?} message - some message with additional info
   *
   * @returns {function}
   */
  validators$1.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
      return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }

    // eslint-disable-next-line func-names
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError(
          formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
          AxiosError.ERR_DEPRECATED
        );
      }

      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        // eslint-disable-next-line no-console
        console.warn(
          formatMessage(
            opt,
            ' has been deprecated since v' + version + ' and will be removed in the near future'
          )
        );
      }

      return validator ? validator(value, opt, opts) : true;
    };
  };

  /**
   * Assert object's properties type
   *
   * @param {object} options
   * @param {object} schema
   * @param {boolean?} allowUnknown
   *
   * @returns {object}
   */

  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== 'object') {
      throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys = Object.keys(options);
    let i = keys.length;
    while (i-- > 0) {
      const opt = keys[i];
      const validator = schema[opt];
      if (validator) {
        const value = options[opt];
        const result = value === undefined || validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }

  var validator = {
    assertOptions,
    validators: validators$1
  };

  const validators = validator.validators;

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   *
   * @return {Axios} A new instance of Axios
   */
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof configOrUrl === 'string') {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }

      config = mergeConfig(this.defaults, config);

      const {transitional, paramsSerializer, headers} = config;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }

      if (paramsSerializer != null) {
        if (utils$1.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }

      // Set config.method
      config.method = (config.method || this.defaults.method || 'get').toLowerCase();

      // Flatten headers
      let contextHeaders = headers && utils$1.merge(
        headers.common,
        headers[config.method]
      );

      headers && utils$1.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        (method) => {
          delete headers[method];
        }
      );

      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

      // filter out skipped interceptors
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      let promise;
      let i = 0;
      let len;

      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), undefined];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;

        promise = Promise.resolve(config);

        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }

        return promise;
      }

      len = requestInterceptorChain.length;

      let newConfig = config;

      i = 0;

      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }

      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      i = 0;
      len = responseInterceptorChain.length;

      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }

      return promise;
    }

    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }

  // Provide aliases for supported request methods
  utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });

  utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/

    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          headers: isForm ? {
            'Content-Type': 'multipart/form-data'
          } : {},
          url,
          data
        }));
      };
    }

    Axios.prototype[method] = generateHTTPMethod();

    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
  });

  var Axios$1 = Axios;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @param {Function} executor The executor function.
   *
   * @returns {CancelToken}
   */
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      let resolvePromise;

      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      const token = this;

      // eslint-disable-next-line func-names
      this.promise.then(cancel => {
        if (!token._listeners) return;

        let i = token._listeners.length;

        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });

      // eslint-disable-next-line func-names
      this.promise.then = onfulfilled => {
        let _resolve;
        // eslint-disable-next-line func-names
        const promise = new Promise(resolve => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);

        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };

        return promise;
      };

      executor(function cancel(message, config, request) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }

    /**
     * Subscribe to the cancel signal
     */

    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }

      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }

    /**
     * Unsubscribe from the cancel signal
     */

    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }

  var CancelToken$1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   *
   * @returns {Function}
   */
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   *
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */
  function isAxiosError(payload) {
    return utils$1.isObject(payload) && (payload.isAxiosError === true);
  }

  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
  };

  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });

  var HttpStatusCode$1 = HttpStatusCode;

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   *
   * @returns {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    const context = new Axios$1(defaultConfig);
    const instance = bind(Axios$1.prototype.request, context);

    // Copy axios.prototype to instance
    utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

    // Copy context to instance
    utils$1.extend(instance, context, null, {allOwnKeys: true});

    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };

    return instance;
  }

  // Create the default instance to be exported
  const axios = createInstance(defaults$1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios$1;

  // Expose Cancel & CancelToken
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;

  // Expose AxiosError class
  axios.AxiosError = AxiosError;

  // alias for CanceledError for backward compatibility
  axios.Cancel = axios.CanceledError;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };

  axios.spread = spread;

  // Expose isAxiosError
  axios.isAxiosError = isAxiosError;

  // Expose mergeConfig
  axios.mergeConfig = mergeConfig;

  axios.AxiosHeaders = AxiosHeaders$1;

  axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

  axios.getAdapter = adapters.getAdapter;

  axios.HttpStatusCode = HttpStatusCode$1;

  axios.default = axios;

  // this module should only have a default export
  var axios$1 = axios;

  /**
   * 系统时间校准
   */
  var SystemClock = /*#__PURE__*/function () {
    function SystemClock() {
      _classCallCheck(this, SystemClock);
      // 当前时间与系统时间偏移量
      /**
       * 当前时间与系统时间偏移量
       */
      _defineProperty(this, "offset", 0);
    }
    _createClass(SystemClock, [{
      key: "systemClockOffset",
      get:
      /**
       * 获取时间偏移量
       */
      function get() {
        return this.offset;
      }
      /**
       * 获取当前系统时间
       * @returns
       */
    }, {
      key: "now",
      value: function now() {
        return Date.now() + (this.offset || 0);
      }
    }, {
      key: "handleOffset",
      value: function handleOffset(serverDate) {
        var serverTime = Date.parse(serverDate);
        // 本地时间与服务器时间相差大于等于30s则需要进行校准
        if (Math.abs(this.now() - serverTime) >= 30000) {
          this.offset = serverTime - Date.now();
        }
      }
    }]);
    return SystemClock;
  }();
  var systemClock = new SystemClock();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			if (this instanceof a) {
          return Reflect.construct(f, arguments, this.constructor);
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var cryptoJs = {exports: {}};

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var core = {exports: {}};

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  var hasRequiredCore;

  function requireCore () {
  	if (hasRequiredCore) return core.exports;
  	hasRequiredCore = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory();
  			}
  		}(commonjsGlobal, function () {

  			/*globals window, global, require*/

  			/**
  			 * CryptoJS core components.
  			 */
  			var CryptoJS = CryptoJS || (function (Math, undefined$1) {

  			    var crypto;

  			    // Native crypto from window (Browser)
  			    if (typeof window !== 'undefined' && window.crypto) {
  			        crypto = window.crypto;
  			    }

  			    // Native crypto in web worker (Browser)
  			    if (typeof self !== 'undefined' && self.crypto) {
  			        crypto = self.crypto;
  			    }

  			    // Native crypto from worker
  			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
  			        crypto = globalThis.crypto;
  			    }

  			    // Native (experimental IE 11) crypto from window (Browser)
  			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
  			        crypto = window.msCrypto;
  			    }

  			    // Native crypto from global (NodeJS)
  			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
  			        crypto = commonjsGlobal.crypto;
  			    }

  			    // Native crypto import via require (NodeJS)
  			    if (!crypto && typeof commonjsRequire === 'function') {
  			        try {
  			            crypto = require$$0;
  			        } catch (err) {}
  			    }

  			    /*
  			     * Cryptographically secure pseudorandom number generator
  			     *
  			     * As Math.random() is cryptographically not safe to use
  			     */
  			    var cryptoSecureRandomInt = function () {
  			        if (crypto) {
  			            // Use getRandomValues method (Browser)
  			            if (typeof crypto.getRandomValues === 'function') {
  			                try {
  			                    return crypto.getRandomValues(new Uint32Array(1))[0];
  			                } catch (err) {}
  			            }

  			            // Use randomBytes method (NodeJS)
  			            if (typeof crypto.randomBytes === 'function') {
  			                try {
  			                    return crypto.randomBytes(4).readInt32LE();
  			                } catch (err) {}
  			            }
  			        }

  			        throw new Error('Native crypto module could not be used to get secure random number.');
  			    };

  			    /*
  			     * Local polyfill of Object.create

  			     */
  			    var create = Object.create || (function () {
  			        function F() {}

  			        return function (obj) {
  			            var subtype;

  			            F.prototype = obj;

  			            subtype = new F();

  			            F.prototype = null;

  			            return subtype;
  			        };
  			    }());

  			    /**
  			     * CryptoJS namespace.
  			     */
  			    var C = {};

  			    /**
  			     * Library namespace.
  			     */
  			    var C_lib = C.lib = {};

  			    /**
  			     * Base object for prototypal inheritance.
  			     */
  			    var Base = C_lib.Base = (function () {


  			        return {
  			            /**
  			             * Creates a new object that inherits from this object.
  			             *
  			             * @param {Object} overrides Properties to copy into the new object.
  			             *
  			             * @return {Object} The new object.
  			             *
  			             * @static
  			             *
  			             * @example
  			             *
  			             *     var MyType = CryptoJS.lib.Base.extend({
  			             *         field: 'value',
  			             *
  			             *         method: function () {
  			             *         }
  			             *     });
  			             */
  			            extend: function (overrides) {
  			                // Spawn
  			                var subtype = create(this);

  			                // Augment
  			                if (overrides) {
  			                    subtype.mixIn(overrides);
  			                }

  			                // Create default initializer
  			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
  			                    subtype.init = function () {
  			                        subtype.$super.init.apply(this, arguments);
  			                    };
  			                }

  			                // Initializer's prototype is the subtype object
  			                subtype.init.prototype = subtype;

  			                // Reference supertype
  			                subtype.$super = this;

  			                return subtype;
  			            },

  			            /**
  			             * Extends this object and runs the init method.
  			             * Arguments to create() will be passed to init().
  			             *
  			             * @return {Object} The new object.
  			             *
  			             * @static
  			             *
  			             * @example
  			             *
  			             *     var instance = MyType.create();
  			             */
  			            create: function () {
  			                var instance = this.extend();
  			                instance.init.apply(instance, arguments);

  			                return instance;
  			            },

  			            /**
  			             * Initializes a newly created object.
  			             * Override this method to add some logic when your objects are created.
  			             *
  			             * @example
  			             *
  			             *     var MyType = CryptoJS.lib.Base.extend({
  			             *         init: function () {
  			             *             // ...
  			             *         }
  			             *     });
  			             */
  			            init: function () {
  			            },

  			            /**
  			             * Copies properties into this object.
  			             *
  			             * @param {Object} properties The properties to mix in.
  			             *
  			             * @example
  			             *
  			             *     MyType.mixIn({
  			             *         field: 'value'
  			             *     });
  			             */
  			            mixIn: function (properties) {
  			                for (var propertyName in properties) {
  			                    if (properties.hasOwnProperty(propertyName)) {
  			                        this[propertyName] = properties[propertyName];
  			                    }
  			                }

  			                // IE won't copy toString using the loop above
  			                if (properties.hasOwnProperty('toString')) {
  			                    this.toString = properties.toString;
  			                }
  			            },

  			            /**
  			             * Creates a copy of this object.
  			             *
  			             * @return {Object} The clone.
  			             *
  			             * @example
  			             *
  			             *     var clone = instance.clone();
  			             */
  			            clone: function () {
  			                return this.init.prototype.extend(this);
  			            }
  			        };
  			    }());

  			    /**
  			     * An array of 32-bit words.
  			     *
  			     * @property {Array} words The array of 32-bit words.
  			     * @property {number} sigBytes The number of significant bytes in this word array.
  			     */
  			    var WordArray = C_lib.WordArray = Base.extend({
  			        /**
  			         * Initializes a newly created word array.
  			         *
  			         * @param {Array} words (Optional) An array of 32-bit words.
  			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.lib.WordArray.create();
  			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
  			         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
  			         */
  			        init: function (words, sigBytes) {
  			            words = this.words = words || [];

  			            if (sigBytes != undefined$1) {
  			                this.sigBytes = sigBytes;
  			            } else {
  			                this.sigBytes = words.length * 4;
  			            }
  			        },

  			        /**
  			         * Converts this word array to a string.
  			         *
  			         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
  			         *
  			         * @return {string} The stringified word array.
  			         *
  			         * @example
  			         *
  			         *     var string = wordArray + '';
  			         *     var string = wordArray.toString();
  			         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
  			         */
  			        toString: function (encoder) {
  			            return (encoder || Hex).stringify(this);
  			        },

  			        /**
  			         * Concatenates a word array to this word array.
  			         *
  			         * @param {WordArray} wordArray The word array to append.
  			         *
  			         * @return {WordArray} This word array.
  			         *
  			         * @example
  			         *
  			         *     wordArray1.concat(wordArray2);
  			         */
  			        concat: function (wordArray) {
  			            // Shortcuts
  			            var thisWords = this.words;
  			            var thatWords = wordArray.words;
  			            var thisSigBytes = this.sigBytes;
  			            var thatSigBytes = wordArray.sigBytes;

  			            // Clamp excess bits
  			            this.clamp();

  			            // Concat
  			            if (thisSigBytes % 4) {
  			                // Copy one byte at a time
  			                for (var i = 0; i < thatSigBytes; i++) {
  			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
  			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
  			                }
  			            } else {
  			                // Copy one word at a time
  			                for (var j = 0; j < thatSigBytes; j += 4) {
  			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
  			                }
  			            }
  			            this.sigBytes += thatSigBytes;

  			            // Chainable
  			            return this;
  			        },

  			        /**
  			         * Removes insignificant bits.
  			         *
  			         * @example
  			         *
  			         *     wordArray.clamp();
  			         */
  			        clamp: function () {
  			            // Shortcuts
  			            var words = this.words;
  			            var sigBytes = this.sigBytes;

  			            // Clamp
  			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
  			            words.length = Math.ceil(sigBytes / 4);
  			        },

  			        /**
  			         * Creates a copy of this word array.
  			         *
  			         * @return {WordArray} The clone.
  			         *
  			         * @example
  			         *
  			         *     var clone = wordArray.clone();
  			         */
  			        clone: function () {
  			            var clone = Base.clone.call(this);
  			            clone.words = this.words.slice(0);

  			            return clone;
  			        },

  			        /**
  			         * Creates a word array filled with random bytes.
  			         *
  			         * @param {number} nBytes The number of random bytes to generate.
  			         *
  			         * @return {WordArray} The random word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.lib.WordArray.random(16);
  			         */
  			        random: function (nBytes) {
  			            var words = [];

  			            for (var i = 0; i < nBytes; i += 4) {
  			                words.push(cryptoSecureRandomInt());
  			            }

  			            return new WordArray.init(words, nBytes);
  			        }
  			    });

  			    /**
  			     * Encoder namespace.
  			     */
  			    var C_enc = C.enc = {};

  			    /**
  			     * Hex encoding strategy.
  			     */
  			    var Hex = C_enc.Hex = {
  			        /**
  			         * Converts a word array to a hex string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The hex string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;

  			            // Convert
  			            var hexChars = [];
  			            for (var i = 0; i < sigBytes; i++) {
  			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
  			                hexChars.push((bite >>> 4).toString(16));
  			                hexChars.push((bite & 0x0f).toString(16));
  			            }

  			            return hexChars.join('');
  			        },

  			        /**
  			         * Converts a hex string to a word array.
  			         *
  			         * @param {string} hexStr The hex string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
  			         */
  			        parse: function (hexStr) {
  			            // Shortcut
  			            var hexStrLength = hexStr.length;

  			            // Convert
  			            var words = [];
  			            for (var i = 0; i < hexStrLength; i += 2) {
  			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
  			            }

  			            return new WordArray.init(words, hexStrLength / 2);
  			        }
  			    };

  			    /**
  			     * Latin1 encoding strategy.
  			     */
  			    var Latin1 = C_enc.Latin1 = {
  			        /**
  			         * Converts a word array to a Latin1 string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The Latin1 string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;

  			            // Convert
  			            var latin1Chars = [];
  			            for (var i = 0; i < sigBytes; i++) {
  			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
  			                latin1Chars.push(String.fromCharCode(bite));
  			            }

  			            return latin1Chars.join('');
  			        },

  			        /**
  			         * Converts a Latin1 string to a word array.
  			         *
  			         * @param {string} latin1Str The Latin1 string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
  			         */
  			        parse: function (latin1Str) {
  			            // Shortcut
  			            var latin1StrLength = latin1Str.length;

  			            // Convert
  			            var words = [];
  			            for (var i = 0; i < latin1StrLength; i++) {
  			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
  			            }

  			            return new WordArray.init(words, latin1StrLength);
  			        }
  			    };

  			    /**
  			     * UTF-8 encoding strategy.
  			     */
  			    var Utf8 = C_enc.Utf8 = {
  			        /**
  			         * Converts a word array to a UTF-8 string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The UTF-8 string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            try {
  			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
  			            } catch (e) {
  			                throw new Error('Malformed UTF-8 data');
  			            }
  			        },

  			        /**
  			         * Converts a UTF-8 string to a word array.
  			         *
  			         * @param {string} utf8Str The UTF-8 string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
  			         */
  			        parse: function (utf8Str) {
  			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  			        }
  			    };

  			    /**
  			     * Abstract buffered block algorithm template.
  			     *
  			     * The property blockSize must be implemented in a concrete subtype.
  			     *
  			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
  			     */
  			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
  			        /**
  			         * Resets this block algorithm's data buffer to its initial state.
  			         *
  			         * @example
  			         *
  			         *     bufferedBlockAlgorithm.reset();
  			         */
  			        reset: function () {
  			            // Initial values
  			            this._data = new WordArray.init();
  			            this._nDataBytes = 0;
  			        },

  			        /**
  			         * Adds new data to this block algorithm's buffer.
  			         *
  			         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
  			         *
  			         * @example
  			         *
  			         *     bufferedBlockAlgorithm._append('data');
  			         *     bufferedBlockAlgorithm._append(wordArray);
  			         */
  			        _append: function (data) {
  			            // Convert string to WordArray, else assume WordArray already
  			            if (typeof data == 'string') {
  			                data = Utf8.parse(data);
  			            }

  			            // Append
  			            this._data.concat(data);
  			            this._nDataBytes += data.sigBytes;
  			        },

  			        /**
  			         * Processes available data blocks.
  			         *
  			         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
  			         *
  			         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
  			         *
  			         * @return {WordArray} The processed data.
  			         *
  			         * @example
  			         *
  			         *     var processedData = bufferedBlockAlgorithm._process();
  			         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
  			         */
  			        _process: function (doFlush) {
  			            var processedWords;

  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;
  			            var dataSigBytes = data.sigBytes;
  			            var blockSize = this.blockSize;
  			            var blockSizeBytes = blockSize * 4;

  			            // Count blocks ready
  			            var nBlocksReady = dataSigBytes / blockSizeBytes;
  			            if (doFlush) {
  			                // Round up to include partial blocks
  			                nBlocksReady = Math.ceil(nBlocksReady);
  			            } else {
  			                // Round down to include only full blocks,
  			                // less the number of blocks that must remain in the buffer
  			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
  			            }

  			            // Count words ready
  			            var nWordsReady = nBlocksReady * blockSize;

  			            // Count bytes ready
  			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

  			            // Process blocks
  			            if (nWordsReady) {
  			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
  			                    // Perform concrete-algorithm logic
  			                    this._doProcessBlock(dataWords, offset);
  			                }

  			                // Remove processed words
  			                processedWords = dataWords.splice(0, nWordsReady);
  			                data.sigBytes -= nBytesReady;
  			            }

  			            // Return processed words
  			            return new WordArray.init(processedWords, nBytesReady);
  			        },

  			        /**
  			         * Creates a copy of this object.
  			         *
  			         * @return {Object} The clone.
  			         *
  			         * @example
  			         *
  			         *     var clone = bufferedBlockAlgorithm.clone();
  			         */
  			        clone: function () {
  			            var clone = Base.clone.call(this);
  			            clone._data = this._data.clone();

  			            return clone;
  			        },

  			        _minBufferSize: 0
  			    });

  			    /**
  			     * Abstract hasher template.
  			     *
  			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
  			     */
  			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
  			        /**
  			         * Configuration options.
  			         */
  			        cfg: Base.extend(),

  			        /**
  			         * Initializes a newly created hasher.
  			         *
  			         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
  			         *
  			         * @example
  			         *
  			         *     var hasher = CryptoJS.algo.SHA256.create();
  			         */
  			        init: function (cfg) {
  			            // Apply config defaults
  			            this.cfg = this.cfg.extend(cfg);

  			            // Set initial values
  			            this.reset();
  			        },

  			        /**
  			         * Resets this hasher to its initial state.
  			         *
  			         * @example
  			         *
  			         *     hasher.reset();
  			         */
  			        reset: function () {
  			            // Reset data buffer
  			            BufferedBlockAlgorithm.reset.call(this);

  			            // Perform concrete-hasher logic
  			            this._doReset();
  			        },

  			        /**
  			         * Updates this hasher with a message.
  			         *
  			         * @param {WordArray|string} messageUpdate The message to append.
  			         *
  			         * @return {Hasher} This hasher.
  			         *
  			         * @example
  			         *
  			         *     hasher.update('message');
  			         *     hasher.update(wordArray);
  			         */
  			        update: function (messageUpdate) {
  			            // Append
  			            this._append(messageUpdate);

  			            // Update the hash
  			            this._process();

  			            // Chainable
  			            return this;
  			        },

  			        /**
  			         * Finalizes the hash computation.
  			         * Note that the finalize operation is effectively a destructive, read-once operation.
  			         *
  			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
  			         *
  			         * @return {WordArray} The hash.
  			         *
  			         * @example
  			         *
  			         *     var hash = hasher.finalize();
  			         *     var hash = hasher.finalize('message');
  			         *     var hash = hasher.finalize(wordArray);
  			         */
  			        finalize: function (messageUpdate) {
  			            // Final message update
  			            if (messageUpdate) {
  			                this._append(messageUpdate);
  			            }

  			            // Perform concrete-hasher logic
  			            var hash = this._doFinalize();

  			            return hash;
  			        },

  			        blockSize: 512/32,

  			        /**
  			         * Creates a shortcut function to a hasher's object interface.
  			         *
  			         * @param {Hasher} hasher The hasher to create a helper for.
  			         *
  			         * @return {Function} The shortcut function.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
  			         */
  			        _createHelper: function (hasher) {
  			            return function (message, cfg) {
  			                return new hasher.init(cfg).finalize(message);
  			            };
  			        },

  			        /**
  			         * Creates a shortcut function to the HMAC's object interface.
  			         *
  			         * @param {Hasher} hasher The hasher to use in this HMAC helper.
  			         *
  			         * @return {Function} The shortcut function.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
  			         */
  			        _createHmacHelper: function (hasher) {
  			            return function (message, key) {
  			                return new C_algo.HMAC.init(hasher, key).finalize(message);
  			            };
  			        }
  			    });

  			    /**
  			     * Algorithm namespace.
  			     */
  			    var C_algo = C.algo = {};

  			    return C;
  			}(Math));


  			return CryptoJS;

  		})); 
  	} (core));
  	return core.exports;
  }

  var x64Core = {exports: {}};

  var hasRequiredX64Core;

  function requireX64Core () {
  	if (hasRequiredX64Core) return x64Core.exports;
  	hasRequiredX64Core = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function (undefined$1) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Base = C_lib.Base;
  			    var X32WordArray = C_lib.WordArray;

  			    /**
  			     * x64 namespace.
  			     */
  			    var C_x64 = C.x64 = {};

  			    /**
  			     * A 64-bit word.
  			     */
  			    C_x64.Word = Base.extend({
  			        /**
  			         * Initializes a newly created 64-bit word.
  			         *
  			         * @param {number} high The high 32 bits.
  			         * @param {number} low The low 32 bits.
  			         *
  			         * @example
  			         *
  			         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
  			         */
  			        init: function (high, low) {
  			            this.high = high;
  			            this.low = low;
  			        }

  			        /**
  			         * Bitwise NOTs this word.
  			         *
  			         * @return {X64Word} A new x64-Word object after negating.
  			         *
  			         * @example
  			         *
  			         *     var negated = x64Word.not();
  			         */
  			        // not: function () {
  			            // var high = ~this.high;
  			            // var low = ~this.low;

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Bitwise ANDs this word with the passed word.
  			         *
  			         * @param {X64Word} word The x64-Word to AND with this word.
  			         *
  			         * @return {X64Word} A new x64-Word object after ANDing.
  			         *
  			         * @example
  			         *
  			         *     var anded = x64Word.and(anotherX64Word);
  			         */
  			        // and: function (word) {
  			            // var high = this.high & word.high;
  			            // var low = this.low & word.low;

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Bitwise ORs this word with the passed word.
  			         *
  			         * @param {X64Word} word The x64-Word to OR with this word.
  			         *
  			         * @return {X64Word} A new x64-Word object after ORing.
  			         *
  			         * @example
  			         *
  			         *     var ored = x64Word.or(anotherX64Word);
  			         */
  			        // or: function (word) {
  			            // var high = this.high | word.high;
  			            // var low = this.low | word.low;

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Bitwise XORs this word with the passed word.
  			         *
  			         * @param {X64Word} word The x64-Word to XOR with this word.
  			         *
  			         * @return {X64Word} A new x64-Word object after XORing.
  			         *
  			         * @example
  			         *
  			         *     var xored = x64Word.xor(anotherX64Word);
  			         */
  			        // xor: function (word) {
  			            // var high = this.high ^ word.high;
  			            // var low = this.low ^ word.low;

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Shifts this word n bits to the left.
  			         *
  			         * @param {number} n The number of bits to shift.
  			         *
  			         * @return {X64Word} A new x64-Word object after shifting.
  			         *
  			         * @example
  			         *
  			         *     var shifted = x64Word.shiftL(25);
  			         */
  			        // shiftL: function (n) {
  			            // if (n < 32) {
  			                // var high = (this.high << n) | (this.low >>> (32 - n));
  			                // var low = this.low << n;
  			            // } else {
  			                // var high = this.low << (n - 32);
  			                // var low = 0;
  			            // }

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Shifts this word n bits to the right.
  			         *
  			         * @param {number} n The number of bits to shift.
  			         *
  			         * @return {X64Word} A new x64-Word object after shifting.
  			         *
  			         * @example
  			         *
  			         *     var shifted = x64Word.shiftR(7);
  			         */
  			        // shiftR: function (n) {
  			            // if (n < 32) {
  			                // var low = (this.low >>> n) | (this.high << (32 - n));
  			                // var high = this.high >>> n;
  			            // } else {
  			                // var low = this.high >>> (n - 32);
  			                // var high = 0;
  			            // }

  			            // return X64Word.create(high, low);
  			        // },

  			        /**
  			         * Rotates this word n bits to the left.
  			         *
  			         * @param {number} n The number of bits to rotate.
  			         *
  			         * @return {X64Word} A new x64-Word object after rotating.
  			         *
  			         * @example
  			         *
  			         *     var rotated = x64Word.rotL(25);
  			         */
  			        // rotL: function (n) {
  			            // return this.shiftL(n).or(this.shiftR(64 - n));
  			        // },

  			        /**
  			         * Rotates this word n bits to the right.
  			         *
  			         * @param {number} n The number of bits to rotate.
  			         *
  			         * @return {X64Word} A new x64-Word object after rotating.
  			         *
  			         * @example
  			         *
  			         *     var rotated = x64Word.rotR(7);
  			         */
  			        // rotR: function (n) {
  			            // return this.shiftR(n).or(this.shiftL(64 - n));
  			        // },

  			        /**
  			         * Adds this word with the passed word.
  			         *
  			         * @param {X64Word} word The x64-Word to add with this word.
  			         *
  			         * @return {X64Word} A new x64-Word object after adding.
  			         *
  			         * @example
  			         *
  			         *     var added = x64Word.add(anotherX64Word);
  			         */
  			        // add: function (word) {
  			            // var low = (this.low + word.low) | 0;
  			            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
  			            // var high = (this.high + word.high + carry) | 0;

  			            // return X64Word.create(high, low);
  			        // }
  			    });

  			    /**
  			     * An array of 64-bit words.
  			     *
  			     * @property {Array} words The array of CryptoJS.x64.Word objects.
  			     * @property {number} sigBytes The number of significant bytes in this word array.
  			     */
  			    C_x64.WordArray = Base.extend({
  			        /**
  			         * Initializes a newly created word array.
  			         *
  			         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
  			         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.x64.WordArray.create();
  			         *
  			         *     var wordArray = CryptoJS.x64.WordArray.create([
  			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
  			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
  			         *     ]);
  			         *
  			         *     var wordArray = CryptoJS.x64.WordArray.create([
  			         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
  			         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
  			         *     ], 10);
  			         */
  			        init: function (words, sigBytes) {
  			            words = this.words = words || [];

  			            if (sigBytes != undefined$1) {
  			                this.sigBytes = sigBytes;
  			            } else {
  			                this.sigBytes = words.length * 8;
  			            }
  			        },

  			        /**
  			         * Converts this 64-bit word array to a 32-bit word array.
  			         *
  			         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
  			         *
  			         * @example
  			         *
  			         *     var x32WordArray = x64WordArray.toX32();
  			         */
  			        toX32: function () {
  			            // Shortcuts
  			            var x64Words = this.words;
  			            var x64WordsLength = x64Words.length;

  			            // Convert
  			            var x32Words = [];
  			            for (var i = 0; i < x64WordsLength; i++) {
  			                var x64Word = x64Words[i];
  			                x32Words.push(x64Word.high);
  			                x32Words.push(x64Word.low);
  			            }

  			            return X32WordArray.create(x32Words, this.sigBytes);
  			        },

  			        /**
  			         * Creates a copy of this word array.
  			         *
  			         * @return {X64WordArray} The clone.
  			         *
  			         * @example
  			         *
  			         *     var clone = x64WordArray.clone();
  			         */
  			        clone: function () {
  			            var clone = Base.clone.call(this);

  			            // Clone "words" array
  			            var words = clone.words = this.words.slice(0);

  			            // Clone each X64Word object
  			            var wordsLength = words.length;
  			            for (var i = 0; i < wordsLength; i++) {
  			                words[i] = words[i].clone();
  			            }

  			            return clone;
  			        }
  			    });
  			}());


  			return CryptoJS;

  		})); 
  	} (x64Core));
  	return x64Core.exports;
  }

  var libTypedarrays = {exports: {}};

  var hasRequiredLibTypedarrays;

  function requireLibTypedarrays () {
  	if (hasRequiredLibTypedarrays) return libTypedarrays.exports;
  	hasRequiredLibTypedarrays = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Check if typed arrays are supported
  			    if (typeof ArrayBuffer != 'function') {
  			        return;
  			    }

  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;

  			    // Reference original init
  			    var superInit = WordArray.init;

  			    // Augment WordArray.init to handle typed arrays
  			    var subInit = WordArray.init = function (typedArray) {
  			        // Convert buffers to uint8
  			        if (typedArray instanceof ArrayBuffer) {
  			            typedArray = new Uint8Array(typedArray);
  			        }

  			        // Convert other array views to uint8
  			        if (
  			            typedArray instanceof Int8Array ||
  			            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
  			            typedArray instanceof Int16Array ||
  			            typedArray instanceof Uint16Array ||
  			            typedArray instanceof Int32Array ||
  			            typedArray instanceof Uint32Array ||
  			            typedArray instanceof Float32Array ||
  			            typedArray instanceof Float64Array
  			        ) {
  			            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
  			        }

  			        // Handle Uint8Array
  			        if (typedArray instanceof Uint8Array) {
  			            // Shortcut
  			            var typedArrayByteLength = typedArray.byteLength;

  			            // Extract bytes
  			            var words = [];
  			            for (var i = 0; i < typedArrayByteLength; i++) {
  			                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
  			            }

  			            // Initialize this word array
  			            superInit.call(this, words, typedArrayByteLength);
  			        } else {
  			            // Else call normal init
  			            superInit.apply(this, arguments);
  			        }
  			    };

  			    subInit.prototype = WordArray;
  			}());


  			return CryptoJS.lib.WordArray;

  		})); 
  	} (libTypedarrays));
  	return libTypedarrays.exports;
  }

  var encUtf16 = {exports: {}};

  var hasRequiredEncUtf16;

  function requireEncUtf16 () {
  	if (hasRequiredEncUtf16) return encUtf16.exports;
  	hasRequiredEncUtf16 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var C_enc = C.enc;

  			    /**
  			     * UTF-16 BE encoding strategy.
  			     */
  			    C_enc.Utf16 = C_enc.Utf16BE = {
  			        /**
  			         * Converts a word array to a UTF-16 BE string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The UTF-16 BE string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;

  			            // Convert
  			            var utf16Chars = [];
  			            for (var i = 0; i < sigBytes; i += 2) {
  			                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
  			                utf16Chars.push(String.fromCharCode(codePoint));
  			            }

  			            return utf16Chars.join('');
  			        },

  			        /**
  			         * Converts a UTF-16 BE string to a word array.
  			         *
  			         * @param {string} utf16Str The UTF-16 BE string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
  			         */
  			        parse: function (utf16Str) {
  			            // Shortcut
  			            var utf16StrLength = utf16Str.length;

  			            // Convert
  			            var words = [];
  			            for (var i = 0; i < utf16StrLength; i++) {
  			                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
  			            }

  			            return WordArray.create(words, utf16StrLength * 2);
  			        }
  			    };

  			    /**
  			     * UTF-16 LE encoding strategy.
  			     */
  			    C_enc.Utf16LE = {
  			        /**
  			         * Converts a word array to a UTF-16 LE string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The UTF-16 LE string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;

  			            // Convert
  			            var utf16Chars = [];
  			            for (var i = 0; i < sigBytes; i += 2) {
  			                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
  			                utf16Chars.push(String.fromCharCode(codePoint));
  			            }

  			            return utf16Chars.join('');
  			        },

  			        /**
  			         * Converts a UTF-16 LE string to a word array.
  			         *
  			         * @param {string} utf16Str The UTF-16 LE string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
  			         */
  			        parse: function (utf16Str) {
  			            // Shortcut
  			            var utf16StrLength = utf16Str.length;

  			            // Convert
  			            var words = [];
  			            for (var i = 0; i < utf16StrLength; i++) {
  			                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
  			            }

  			            return WordArray.create(words, utf16StrLength * 2);
  			        }
  			    };

  			    function swapEndian(word) {
  			        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
  			    }
  			}());


  			return CryptoJS.enc.Utf16;

  		})); 
  	} (encUtf16));
  	return encUtf16.exports;
  }

  var encBase64 = {exports: {}};

  var hasRequiredEncBase64;

  function requireEncBase64 () {
  	if (hasRequiredEncBase64) return encBase64.exports;
  	hasRequiredEncBase64 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var C_enc = C.enc;

  			    /**
  			     * Base64 encoding strategy.
  			     */
  			    C_enc.Base64 = {
  			        /**
  			         * Converts a word array to a Base64 string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @return {string} The Base64 string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
  			         */
  			        stringify: function (wordArray) {
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;
  			            var map = this._map;

  			            // Clamp excess bits
  			            wordArray.clamp();

  			            // Convert
  			            var base64Chars = [];
  			            for (var i = 0; i < sigBytes; i += 3) {
  			                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
  			                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
  			                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

  			                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

  			                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
  			                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
  			                }
  			            }

  			            // Add padding
  			            var paddingChar = map.charAt(64);
  			            if (paddingChar) {
  			                while (base64Chars.length % 4) {
  			                    base64Chars.push(paddingChar);
  			                }
  			            }

  			            return base64Chars.join('');
  			        },

  			        /**
  			         * Converts a Base64 string to a word array.
  			         *
  			         * @param {string} base64Str The Base64 string.
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
  			         */
  			        parse: function (base64Str) {
  			            // Shortcuts
  			            var base64StrLength = base64Str.length;
  			            var map = this._map;
  			            var reverseMap = this._reverseMap;

  			            if (!reverseMap) {
  			                    reverseMap = this._reverseMap = [];
  			                    for (var j = 0; j < map.length; j++) {
  			                        reverseMap[map.charCodeAt(j)] = j;
  			                    }
  			            }

  			            // Ignore padding
  			            var paddingChar = map.charAt(64);
  			            if (paddingChar) {
  			                var paddingIndex = base64Str.indexOf(paddingChar);
  			                if (paddingIndex !== -1) {
  			                    base64StrLength = paddingIndex;
  			                }
  			            }

  			            // Convert
  			            return parseLoop(base64Str, base64StrLength, reverseMap);

  			        },

  			        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
  			    };

  			    function parseLoop(base64Str, base64StrLength, reverseMap) {
  			      var words = [];
  			      var nBytes = 0;
  			      for (var i = 0; i < base64StrLength; i++) {
  			          if (i % 4) {
  			              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
  			              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
  			              var bitsCombined = bits1 | bits2;
  			              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
  			              nBytes++;
  			          }
  			      }
  			      return WordArray.create(words, nBytes);
  			    }
  			}());


  			return CryptoJS.enc.Base64;

  		})); 
  	} (encBase64));
  	return encBase64.exports;
  }

  var encBase64url = {exports: {}};

  var hasRequiredEncBase64url;

  function requireEncBase64url () {
  	if (hasRequiredEncBase64url) return encBase64url.exports;
  	hasRequiredEncBase64url = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var C_enc = C.enc;

  			    /**
  			     * Base64url encoding strategy.
  			     */
  			    C_enc.Base64url = {
  			        /**
  			         * Converts a word array to a Base64url string.
  			         *
  			         * @param {WordArray} wordArray The word array.
  			         *
  			         * @param {boolean} urlSafe Whether to use url safe
  			         *
  			         * @return {string} The Base64url string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
  			         */
  			        stringify: function (wordArray, urlSafe) {
  			            if (urlSafe === undefined) {
  			                urlSafe = true;
  			            }
  			            // Shortcuts
  			            var words = wordArray.words;
  			            var sigBytes = wordArray.sigBytes;
  			            var map = urlSafe ? this._safe_map : this._map;

  			            // Clamp excess bits
  			            wordArray.clamp();

  			            // Convert
  			            var base64Chars = [];
  			            for (var i = 0; i < sigBytes; i += 3) {
  			                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
  			                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
  			                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

  			                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

  			                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
  			                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
  			                }
  			            }

  			            // Add padding
  			            var paddingChar = map.charAt(64);
  			            if (paddingChar) {
  			                while (base64Chars.length % 4) {
  			                    base64Chars.push(paddingChar);
  			                }
  			            }

  			            return base64Chars.join('');
  			        },

  			        /**
  			         * Converts a Base64url string to a word array.
  			         *
  			         * @param {string} base64Str The Base64url string.
  			         *
  			         * @param {boolean} urlSafe Whether to use url safe
  			         *
  			         * @return {WordArray} The word array.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
  			         */
  			        parse: function (base64Str, urlSafe) {
  			            if (urlSafe === undefined) {
  			                urlSafe = true;
  			            }

  			            // Shortcuts
  			            var base64StrLength = base64Str.length;
  			            var map = urlSafe ? this._safe_map : this._map;
  			            var reverseMap = this._reverseMap;

  			            if (!reverseMap) {
  			                reverseMap = this._reverseMap = [];
  			                for (var j = 0; j < map.length; j++) {
  			                    reverseMap[map.charCodeAt(j)] = j;
  			                }
  			            }

  			            // Ignore padding
  			            var paddingChar = map.charAt(64);
  			            if (paddingChar) {
  			                var paddingIndex = base64Str.indexOf(paddingChar);
  			                if (paddingIndex !== -1) {
  			                    base64StrLength = paddingIndex;
  			                }
  			            }

  			            // Convert
  			            return parseLoop(base64Str, base64StrLength, reverseMap);

  			        },

  			        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
  			        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
  			    };

  			    function parseLoop(base64Str, base64StrLength, reverseMap) {
  			        var words = [];
  			        var nBytes = 0;
  			        for (var i = 0; i < base64StrLength; i++) {
  			            if (i % 4) {
  			                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
  			                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
  			                var bitsCombined = bits1 | bits2;
  			                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
  			                nBytes++;
  			            }
  			        }
  			        return WordArray.create(words, nBytes);
  			    }
  			}());


  			return CryptoJS.enc.Base64url;

  		})); 
  	} (encBase64url));
  	return encBase64url.exports;
  }

  var md5 = {exports: {}};

  var hasRequiredMd5;

  function requireMd5 () {
  	if (hasRequiredMd5) return md5.exports;
  	hasRequiredMd5 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function (Math) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var Hasher = C_lib.Hasher;
  			    var C_algo = C.algo;

  			    // Constants table
  			    var T = [];

  			    // Compute constants
  			    (function () {
  			        for (var i = 0; i < 64; i++) {
  			            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
  			        }
  			    }());

  			    /**
  			     * MD5 hash algorithm.
  			     */
  			    var MD5 = C_algo.MD5 = Hasher.extend({
  			        _doReset: function () {
  			            this._hash = new WordArray.init([
  			                0x67452301, 0xefcdab89,
  			                0x98badcfe, 0x10325476
  			            ]);
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Swap endian
  			            for (var i = 0; i < 16; i++) {
  			                // Shortcuts
  			                var offset_i = offset + i;
  			                var M_offset_i = M[offset_i];

  			                M[offset_i] = (
  			                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
  			                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
  			                );
  			            }

  			            // Shortcuts
  			            var H = this._hash.words;

  			            var M_offset_0  = M[offset + 0];
  			            var M_offset_1  = M[offset + 1];
  			            var M_offset_2  = M[offset + 2];
  			            var M_offset_3  = M[offset + 3];
  			            var M_offset_4  = M[offset + 4];
  			            var M_offset_5  = M[offset + 5];
  			            var M_offset_6  = M[offset + 6];
  			            var M_offset_7  = M[offset + 7];
  			            var M_offset_8  = M[offset + 8];
  			            var M_offset_9  = M[offset + 9];
  			            var M_offset_10 = M[offset + 10];
  			            var M_offset_11 = M[offset + 11];
  			            var M_offset_12 = M[offset + 12];
  			            var M_offset_13 = M[offset + 13];
  			            var M_offset_14 = M[offset + 14];
  			            var M_offset_15 = M[offset + 15];

  			            // Working variables
  			            var a = H[0];
  			            var b = H[1];
  			            var c = H[2];
  			            var d = H[3];

  			            // Computation
  			            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
  			            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
  			            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
  			            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
  			            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
  			            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
  			            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
  			            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
  			            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
  			            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
  			            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
  			            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
  			            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
  			            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
  			            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
  			            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

  			            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
  			            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
  			            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
  			            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
  			            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
  			            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
  			            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
  			            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
  			            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
  			            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
  			            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
  			            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
  			            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
  			            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
  			            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
  			            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

  			            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
  			            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
  			            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
  			            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
  			            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
  			            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
  			            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
  			            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
  			            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
  			            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
  			            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
  			            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
  			            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
  			            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
  			            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
  			            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

  			            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
  			            d = II(d, a, b, c, M_offset_7,  10, T[49]);
  			            c = II(c, d, a, b, M_offset_14, 15, T[50]);
  			            b = II(b, c, d, a, M_offset_5,  21, T[51]);
  			            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
  			            d = II(d, a, b, c, M_offset_3,  10, T[53]);
  			            c = II(c, d, a, b, M_offset_10, 15, T[54]);
  			            b = II(b, c, d, a, M_offset_1,  21, T[55]);
  			            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
  			            d = II(d, a, b, c, M_offset_15, 10, T[57]);
  			            c = II(c, d, a, b, M_offset_6,  15, T[58]);
  			            b = II(b, c, d, a, M_offset_13, 21, T[59]);
  			            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
  			            d = II(d, a, b, c, M_offset_11, 10, T[61]);
  			            c = II(c, d, a, b, M_offset_2,  15, T[62]);
  			            b = II(b, c, d, a, M_offset_9,  21, T[63]);

  			            // Intermediate hash value
  			            H[0] = (H[0] + a) | 0;
  			            H[1] = (H[1] + b) | 0;
  			            H[2] = (H[2] + c) | 0;
  			            H[3] = (H[3] + d) | 0;
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;

  			            var nBitsTotal = this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

  			            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
  			            var nBitsTotalL = nBitsTotal;
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
  			                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
  			                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
  			            );
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
  			                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
  			                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
  			            );

  			            data.sigBytes = (dataWords.length + 1) * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Shortcuts
  			            var hash = this._hash;
  			            var H = hash.words;

  			            // Swap endian
  			            for (var i = 0; i < 4; i++) {
  			                // Shortcut
  			                var H_i = H[i];

  			                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
  			                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
  			            }

  			            // Return final computed hash
  			            return hash;
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);
  			            clone._hash = this._hash.clone();

  			            return clone;
  			        }
  			    });

  			    function FF(a, b, c, d, x, s, t) {
  			        var n = a + ((b & c) | (~b & d)) + x + t;
  			        return ((n << s) | (n >>> (32 - s))) + b;
  			    }

  			    function GG(a, b, c, d, x, s, t) {
  			        var n = a + ((b & d) | (c & ~d)) + x + t;
  			        return ((n << s) | (n >>> (32 - s))) + b;
  			    }

  			    function HH(a, b, c, d, x, s, t) {
  			        var n = a + (b ^ c ^ d) + x + t;
  			        return ((n << s) | (n >>> (32 - s))) + b;
  			    }

  			    function II(a, b, c, d, x, s, t) {
  			        var n = a + (c ^ (b | ~d)) + x + t;
  			        return ((n << s) | (n >>> (32 - s))) + b;
  			    }

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.MD5('message');
  			     *     var hash = CryptoJS.MD5(wordArray);
  			     */
  			    C.MD5 = Hasher._createHelper(MD5);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacMD5(message, key);
  			     */
  			    C.HmacMD5 = Hasher._createHmacHelper(MD5);
  			}(Math));


  			return CryptoJS.MD5;

  		})); 
  	} (md5));
  	return md5.exports;
  }

  var sha1 = {exports: {}};

  var hasRequiredSha1;

  function requireSha1 () {
  	if (hasRequiredSha1) return sha1.exports;
  	hasRequiredSha1 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var Hasher = C_lib.Hasher;
  			    var C_algo = C.algo;

  			    // Reusable object
  			    var W = [];

  			    /**
  			     * SHA-1 hash algorithm.
  			     */
  			    var SHA1 = C_algo.SHA1 = Hasher.extend({
  			        _doReset: function () {
  			            this._hash = new WordArray.init([
  			                0x67452301, 0xefcdab89,
  			                0x98badcfe, 0x10325476,
  			                0xc3d2e1f0
  			            ]);
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcut
  			            var H = this._hash.words;

  			            // Working variables
  			            var a = H[0];
  			            var b = H[1];
  			            var c = H[2];
  			            var d = H[3];
  			            var e = H[4];

  			            // Computation
  			            for (var i = 0; i < 80; i++) {
  			                if (i < 16) {
  			                    W[i] = M[offset + i] | 0;
  			                } else {
  			                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
  			                    W[i] = (n << 1) | (n >>> 31);
  			                }

  			                var t = ((a << 5) | (a >>> 27)) + e + W[i];
  			                if (i < 20) {
  			                    t += ((b & c) | (~b & d)) + 0x5a827999;
  			                } else if (i < 40) {
  			                    t += (b ^ c ^ d) + 0x6ed9eba1;
  			                } else if (i < 60) {
  			                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
  			                } else /* if (i < 80) */ {
  			                    t += (b ^ c ^ d) - 0x359d3e2a;
  			                }

  			                e = d;
  			                d = c;
  			                c = (b << 30) | (b >>> 2);
  			                b = a;
  			                a = t;
  			            }

  			            // Intermediate hash value
  			            H[0] = (H[0] + a) | 0;
  			            H[1] = (H[1] + b) | 0;
  			            H[2] = (H[2] + c) | 0;
  			            H[3] = (H[3] + d) | 0;
  			            H[4] = (H[4] + e) | 0;
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;

  			            var nBitsTotal = this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
  			            data.sigBytes = dataWords.length * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Return final computed hash
  			            return this._hash;
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);
  			            clone._hash = this._hash.clone();

  			            return clone;
  			        }
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA1('message');
  			     *     var hash = CryptoJS.SHA1(wordArray);
  			     */
  			    C.SHA1 = Hasher._createHelper(SHA1);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA1(message, key);
  			     */
  			    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
  			}());


  			return CryptoJS.SHA1;

  		})); 
  	} (sha1));
  	return sha1.exports;
  }

  var sha256 = {exports: {}};

  var hasRequiredSha256;

  function requireSha256 () {
  	if (hasRequiredSha256) return sha256.exports;
  	hasRequiredSha256 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function (Math) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var Hasher = C_lib.Hasher;
  			    var C_algo = C.algo;

  			    // Initialization and round constants tables
  			    var H = [];
  			    var K = [];

  			    // Compute constants
  			    (function () {
  			        function isPrime(n) {
  			            var sqrtN = Math.sqrt(n);
  			            for (var factor = 2; factor <= sqrtN; factor++) {
  			                if (!(n % factor)) {
  			                    return false;
  			                }
  			            }

  			            return true;
  			        }

  			        function getFractionalBits(n) {
  			            return ((n - (n | 0)) * 0x100000000) | 0;
  			        }

  			        var n = 2;
  			        var nPrime = 0;
  			        while (nPrime < 64) {
  			            if (isPrime(n)) {
  			                if (nPrime < 8) {
  			                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
  			                }
  			                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

  			                nPrime++;
  			            }

  			            n++;
  			        }
  			    }());

  			    // Reusable object
  			    var W = [];

  			    /**
  			     * SHA-256 hash algorithm.
  			     */
  			    var SHA256 = C_algo.SHA256 = Hasher.extend({
  			        _doReset: function () {
  			            this._hash = new WordArray.init(H.slice(0));
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcut
  			            var H = this._hash.words;

  			            // Working variables
  			            var a = H[0];
  			            var b = H[1];
  			            var c = H[2];
  			            var d = H[3];
  			            var e = H[4];
  			            var f = H[5];
  			            var g = H[6];
  			            var h = H[7];

  			            // Computation
  			            for (var i = 0; i < 64; i++) {
  			                if (i < 16) {
  			                    W[i] = M[offset + i] | 0;
  			                } else {
  			                    var gamma0x = W[i - 15];
  			                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
  			                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
  			                                   (gamma0x >>> 3);

  			                    var gamma1x = W[i - 2];
  			                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
  			                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
  			                                   (gamma1x >>> 10);

  			                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
  			                }

  			                var ch  = (e & f) ^ (~e & g);
  			                var maj = (a & b) ^ (a & c) ^ (b & c);

  			                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
  			                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

  			                var t1 = h + sigma1 + ch + K[i] + W[i];
  			                var t2 = sigma0 + maj;

  			                h = g;
  			                g = f;
  			                f = e;
  			                e = (d + t1) | 0;
  			                d = c;
  			                c = b;
  			                b = a;
  			                a = (t1 + t2) | 0;
  			            }

  			            // Intermediate hash value
  			            H[0] = (H[0] + a) | 0;
  			            H[1] = (H[1] + b) | 0;
  			            H[2] = (H[2] + c) | 0;
  			            H[3] = (H[3] + d) | 0;
  			            H[4] = (H[4] + e) | 0;
  			            H[5] = (H[5] + f) | 0;
  			            H[6] = (H[6] + g) | 0;
  			            H[7] = (H[7] + h) | 0;
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;

  			            var nBitsTotal = this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
  			            data.sigBytes = dataWords.length * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Return final computed hash
  			            return this._hash;
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);
  			            clone._hash = this._hash.clone();

  			            return clone;
  			        }
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA256('message');
  			     *     var hash = CryptoJS.SHA256(wordArray);
  			     */
  			    C.SHA256 = Hasher._createHelper(SHA256);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA256(message, key);
  			     */
  			    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
  			}(Math));


  			return CryptoJS.SHA256;

  		})); 
  	} (sha256));
  	return sha256.exports;
  }

  var sha224 = {exports: {}};

  var hasRequiredSha224;

  function requireSha224 () {
  	if (hasRequiredSha224) return sha224.exports;
  	hasRequiredSha224 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireSha256());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var C_algo = C.algo;
  			    var SHA256 = C_algo.SHA256;

  			    /**
  			     * SHA-224 hash algorithm.
  			     */
  			    var SHA224 = C_algo.SHA224 = SHA256.extend({
  			        _doReset: function () {
  			            this._hash = new WordArray.init([
  			                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
  			                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
  			            ]);
  			        },

  			        _doFinalize: function () {
  			            var hash = SHA256._doFinalize.call(this);

  			            hash.sigBytes -= 4;

  			            return hash;
  			        }
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA224('message');
  			     *     var hash = CryptoJS.SHA224(wordArray);
  			     */
  			    C.SHA224 = SHA256._createHelper(SHA224);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA224(message, key);
  			     */
  			    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
  			}());


  			return CryptoJS.SHA224;

  		})); 
  	} (sha224));
  	return sha224.exports;
  }

  var sha512 = {exports: {}};

  var hasRequiredSha512;

  function requireSha512 () {
  	if (hasRequiredSha512) return sha512.exports;
  	hasRequiredSha512 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireX64Core());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Hasher = C_lib.Hasher;
  			    var C_x64 = C.x64;
  			    var X64Word = C_x64.Word;
  			    var X64WordArray = C_x64.WordArray;
  			    var C_algo = C.algo;

  			    function X64Word_create() {
  			        return X64Word.create.apply(X64Word, arguments);
  			    }

  			    // Constants
  			    var K = [
  			        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
  			        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
  			        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
  			        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
  			        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
  			        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
  			        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
  			        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
  			        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
  			        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
  			        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
  			        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
  			        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
  			        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
  			        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
  			        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
  			        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
  			        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
  			        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
  			        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
  			        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
  			        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
  			        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
  			        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
  			        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
  			        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
  			        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
  			        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
  			        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
  			        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
  			        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
  			        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
  			        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
  			        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
  			        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
  			        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
  			        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
  			        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
  			        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
  			        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
  			    ];

  			    // Reusable objects
  			    var W = [];
  			    (function () {
  			        for (var i = 0; i < 80; i++) {
  			            W[i] = X64Word_create();
  			        }
  			    }());

  			    /**
  			     * SHA-512 hash algorithm.
  			     */
  			    var SHA512 = C_algo.SHA512 = Hasher.extend({
  			        _doReset: function () {
  			            this._hash = new X64WordArray.init([
  			                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
  			                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
  			                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
  			                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
  			            ]);
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcuts
  			            var H = this._hash.words;

  			            var H0 = H[0];
  			            var H1 = H[1];
  			            var H2 = H[2];
  			            var H3 = H[3];
  			            var H4 = H[4];
  			            var H5 = H[5];
  			            var H6 = H[6];
  			            var H7 = H[7];

  			            var H0h = H0.high;
  			            var H0l = H0.low;
  			            var H1h = H1.high;
  			            var H1l = H1.low;
  			            var H2h = H2.high;
  			            var H2l = H2.low;
  			            var H3h = H3.high;
  			            var H3l = H3.low;
  			            var H4h = H4.high;
  			            var H4l = H4.low;
  			            var H5h = H5.high;
  			            var H5l = H5.low;
  			            var H6h = H6.high;
  			            var H6l = H6.low;
  			            var H7h = H7.high;
  			            var H7l = H7.low;

  			            // Working variables
  			            var ah = H0h;
  			            var al = H0l;
  			            var bh = H1h;
  			            var bl = H1l;
  			            var ch = H2h;
  			            var cl = H2l;
  			            var dh = H3h;
  			            var dl = H3l;
  			            var eh = H4h;
  			            var el = H4l;
  			            var fh = H5h;
  			            var fl = H5l;
  			            var gh = H6h;
  			            var gl = H6l;
  			            var hh = H7h;
  			            var hl = H7l;

  			            // Rounds
  			            for (var i = 0; i < 80; i++) {
  			                var Wil;
  			                var Wih;

  			                // Shortcut
  			                var Wi = W[i];

  			                // Extend message
  			                if (i < 16) {
  			                    Wih = Wi.high = M[offset + i * 2]     | 0;
  			                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
  			                } else {
  			                    // Gamma0
  			                    var gamma0x  = W[i - 15];
  			                    var gamma0xh = gamma0x.high;
  			                    var gamma0xl = gamma0x.low;
  			                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
  			                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

  			                    // Gamma1
  			                    var gamma1x  = W[i - 2];
  			                    var gamma1xh = gamma1x.high;
  			                    var gamma1xl = gamma1x.low;
  			                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
  			                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

  			                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
  			                    var Wi7  = W[i - 7];
  			                    var Wi7h = Wi7.high;
  			                    var Wi7l = Wi7.low;

  			                    var Wi16  = W[i - 16];
  			                    var Wi16h = Wi16.high;
  			                    var Wi16l = Wi16.low;

  			                    Wil = gamma0l + Wi7l;
  			                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
  			                    Wil = Wil + gamma1l;
  			                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
  			                    Wil = Wil + Wi16l;
  			                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

  			                    Wi.high = Wih;
  			                    Wi.low  = Wil;
  			                }

  			                var chh  = (eh & fh) ^ (~eh & gh);
  			                var chl  = (el & fl) ^ (~el & gl);
  			                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
  			                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

  			                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
  			                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
  			                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
  			                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

  			                // t1 = h + sigma1 + ch + K[i] + W[i]
  			                var Ki  = K[i];
  			                var Kih = Ki.high;
  			                var Kil = Ki.low;

  			                var t1l = hl + sigma1l;
  			                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
  			                var t1l = t1l + chl;
  			                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
  			                var t1l = t1l + Kil;
  			                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
  			                var t1l = t1l + Wil;
  			                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

  			                // t2 = sigma0 + maj
  			                var t2l = sigma0l + majl;
  			                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

  			                // Update working variables
  			                hh = gh;
  			                hl = gl;
  			                gh = fh;
  			                gl = fl;
  			                fh = eh;
  			                fl = el;
  			                el = (dl + t1l) | 0;
  			                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
  			                dh = ch;
  			                dl = cl;
  			                ch = bh;
  			                cl = bl;
  			                bh = ah;
  			                bl = al;
  			                al = (t1l + t2l) | 0;
  			                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
  			            }

  			            // Intermediate hash value
  			            H0l = H0.low  = (H0l + al);
  			            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
  			            H1l = H1.low  = (H1l + bl);
  			            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
  			            H2l = H2.low  = (H2l + cl);
  			            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
  			            H3l = H3.low  = (H3l + dl);
  			            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
  			            H4l = H4.low  = (H4l + el);
  			            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
  			            H5l = H5.low  = (H5l + fl);
  			            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
  			            H6l = H6.low  = (H6l + gl);
  			            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
  			            H7l = H7.low  = (H7l + hl);
  			            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;

  			            var nBitsTotal = this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
  			            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
  			            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
  			            data.sigBytes = dataWords.length * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Convert hash to 32-bit word array before returning
  			            var hash = this._hash.toX32();

  			            // Return final computed hash
  			            return hash;
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);
  			            clone._hash = this._hash.clone();

  			            return clone;
  			        },

  			        blockSize: 1024/32
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA512('message');
  			     *     var hash = CryptoJS.SHA512(wordArray);
  			     */
  			    C.SHA512 = Hasher._createHelper(SHA512);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA512(message, key);
  			     */
  			    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
  			}());


  			return CryptoJS.SHA512;

  		})); 
  	} (sha512));
  	return sha512.exports;
  }

  var sha384 = {exports: {}};

  var hasRequiredSha384;

  function requireSha384 () {
  	if (hasRequiredSha384) return sha384.exports;
  	hasRequiredSha384 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireX64Core(), requireSha512());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_x64 = C.x64;
  			    var X64Word = C_x64.Word;
  			    var X64WordArray = C_x64.WordArray;
  			    var C_algo = C.algo;
  			    var SHA512 = C_algo.SHA512;

  			    /**
  			     * SHA-384 hash algorithm.
  			     */
  			    var SHA384 = C_algo.SHA384 = SHA512.extend({
  			        _doReset: function () {
  			            this._hash = new X64WordArray.init([
  			                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
  			                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
  			                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
  			                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
  			            ]);
  			        },

  			        _doFinalize: function () {
  			            var hash = SHA512._doFinalize.call(this);

  			            hash.sigBytes -= 16;

  			            return hash;
  			        }
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA384('message');
  			     *     var hash = CryptoJS.SHA384(wordArray);
  			     */
  			    C.SHA384 = SHA512._createHelper(SHA384);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA384(message, key);
  			     */
  			    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
  			}());


  			return CryptoJS.SHA384;

  		})); 
  	} (sha384));
  	return sha384.exports;
  }

  var sha3 = {exports: {}};

  var hasRequiredSha3;

  function requireSha3 () {
  	if (hasRequiredSha3) return sha3.exports;
  	hasRequiredSha3 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireX64Core());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function (Math) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var Hasher = C_lib.Hasher;
  			    var C_x64 = C.x64;
  			    var X64Word = C_x64.Word;
  			    var C_algo = C.algo;

  			    // Constants tables
  			    var RHO_OFFSETS = [];
  			    var PI_INDEXES  = [];
  			    var ROUND_CONSTANTS = [];

  			    // Compute Constants
  			    (function () {
  			        // Compute rho offset constants
  			        var x = 1, y = 0;
  			        for (var t = 0; t < 24; t++) {
  			            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

  			            var newX = y % 5;
  			            var newY = (2 * x + 3 * y) % 5;
  			            x = newX;
  			            y = newY;
  			        }

  			        // Compute pi index constants
  			        for (var x = 0; x < 5; x++) {
  			            for (var y = 0; y < 5; y++) {
  			                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
  			            }
  			        }

  			        // Compute round constants
  			        var LFSR = 0x01;
  			        for (var i = 0; i < 24; i++) {
  			            var roundConstantMsw = 0;
  			            var roundConstantLsw = 0;

  			            for (var j = 0; j < 7; j++) {
  			                if (LFSR & 0x01) {
  			                    var bitPosition = (1 << j) - 1;
  			                    if (bitPosition < 32) {
  			                        roundConstantLsw ^= 1 << bitPosition;
  			                    } else /* if (bitPosition >= 32) */ {
  			                        roundConstantMsw ^= 1 << (bitPosition - 32);
  			                    }
  			                }

  			                // Compute next LFSR
  			                if (LFSR & 0x80) {
  			                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
  			                    LFSR = (LFSR << 1) ^ 0x71;
  			                } else {
  			                    LFSR <<= 1;
  			                }
  			            }

  			            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
  			        }
  			    }());

  			    // Reusable objects for temporary values
  			    var T = [];
  			    (function () {
  			        for (var i = 0; i < 25; i++) {
  			            T[i] = X64Word.create();
  			        }
  			    }());

  			    /**
  			     * SHA-3 hash algorithm.
  			     */
  			    var SHA3 = C_algo.SHA3 = Hasher.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {number} outputLength
  			         *   The desired number of bits in the output hash.
  			         *   Only values permitted are: 224, 256, 384, 512.
  			         *   Default: 512
  			         */
  			        cfg: Hasher.cfg.extend({
  			            outputLength: 512
  			        }),

  			        _doReset: function () {
  			            var state = this._state = [];
  			            for (var i = 0; i < 25; i++) {
  			                state[i] = new X64Word.init();
  			            }

  			            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcuts
  			            var state = this._state;
  			            var nBlockSizeLanes = this.blockSize / 2;

  			            // Absorb
  			            for (var i = 0; i < nBlockSizeLanes; i++) {
  			                // Shortcuts
  			                var M2i  = M[offset + 2 * i];
  			                var M2i1 = M[offset + 2 * i + 1];

  			                // Swap endian
  			                M2i = (
  			                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
  			                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
  			                );
  			                M2i1 = (
  			                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
  			                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
  			                );

  			                // Absorb message into state
  			                var lane = state[i];
  			                lane.high ^= M2i1;
  			                lane.low  ^= M2i;
  			            }

  			            // Rounds
  			            for (var round = 0; round < 24; round++) {
  			                // Theta
  			                for (var x = 0; x < 5; x++) {
  			                    // Mix column lanes
  			                    var tMsw = 0, tLsw = 0;
  			                    for (var y = 0; y < 5; y++) {
  			                        var lane = state[x + 5 * y];
  			                        tMsw ^= lane.high;
  			                        tLsw ^= lane.low;
  			                    }

  			                    // Temporary values
  			                    var Tx = T[x];
  			                    Tx.high = tMsw;
  			                    Tx.low  = tLsw;
  			                }
  			                for (var x = 0; x < 5; x++) {
  			                    // Shortcuts
  			                    var Tx4 = T[(x + 4) % 5];
  			                    var Tx1 = T[(x + 1) % 5];
  			                    var Tx1Msw = Tx1.high;
  			                    var Tx1Lsw = Tx1.low;

  			                    // Mix surrounding columns
  			                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
  			                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
  			                    for (var y = 0; y < 5; y++) {
  			                        var lane = state[x + 5 * y];
  			                        lane.high ^= tMsw;
  			                        lane.low  ^= tLsw;
  			                    }
  			                }

  			                // Rho Pi
  			                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
  			                    var tMsw;
  			                    var tLsw;

  			                    // Shortcuts
  			                    var lane = state[laneIndex];
  			                    var laneMsw = lane.high;
  			                    var laneLsw = lane.low;
  			                    var rhoOffset = RHO_OFFSETS[laneIndex];

  			                    // Rotate lanes
  			                    if (rhoOffset < 32) {
  			                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
  			                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
  			                    } else /* if (rhoOffset >= 32) */ {
  			                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
  			                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
  			                    }

  			                    // Transpose lanes
  			                    var TPiLane = T[PI_INDEXES[laneIndex]];
  			                    TPiLane.high = tMsw;
  			                    TPiLane.low  = tLsw;
  			                }

  			                // Rho pi at x = y = 0
  			                var T0 = T[0];
  			                var state0 = state[0];
  			                T0.high = state0.high;
  			                T0.low  = state0.low;

  			                // Chi
  			                for (var x = 0; x < 5; x++) {
  			                    for (var y = 0; y < 5; y++) {
  			                        // Shortcuts
  			                        var laneIndex = x + 5 * y;
  			                        var lane = state[laneIndex];
  			                        var TLane = T[laneIndex];
  			                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
  			                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

  			                        // Mix rows
  			                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
  			                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
  			                    }
  			                }

  			                // Iota
  			                var lane = state[0];
  			                var roundConstant = ROUND_CONSTANTS[round];
  			                lane.high ^= roundConstant.high;
  			                lane.low  ^= roundConstant.low;
  			            }
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;
  			            this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;
  			            var blockSizeBits = this.blockSize * 32;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
  			            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
  			            data.sigBytes = dataWords.length * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Shortcuts
  			            var state = this._state;
  			            var outputLengthBytes = this.cfg.outputLength / 8;
  			            var outputLengthLanes = outputLengthBytes / 8;

  			            // Squeeze
  			            var hashWords = [];
  			            for (var i = 0; i < outputLengthLanes; i++) {
  			                // Shortcuts
  			                var lane = state[i];
  			                var laneMsw = lane.high;
  			                var laneLsw = lane.low;

  			                // Swap endian
  			                laneMsw = (
  			                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
  			                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
  			                );
  			                laneLsw = (
  			                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
  			                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
  			                );

  			                // Squeeze state to retrieve hash
  			                hashWords.push(laneLsw);
  			                hashWords.push(laneMsw);
  			            }

  			            // Return final computed hash
  			            return new WordArray.init(hashWords, outputLengthBytes);
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);

  			            var state = clone._state = this._state.slice(0);
  			            for (var i = 0; i < 25; i++) {
  			                state[i] = state[i].clone();
  			            }

  			            return clone;
  			        }
  			    });

  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.SHA3('message');
  			     *     var hash = CryptoJS.SHA3(wordArray);
  			     */
  			    C.SHA3 = Hasher._createHelper(SHA3);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacSHA3(message, key);
  			     */
  			    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
  			}(Math));


  			return CryptoJS.SHA3;

  		})); 
  	} (sha3));
  	return sha3.exports;
  }

  var ripemd160 = {exports: {}};

  var hasRequiredRipemd160;

  function requireRipemd160 () {
  	if (hasRequiredRipemd160) return ripemd160.exports;
  	hasRequiredRipemd160 = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/** @preserve
  			(c) 2012 by Cédric Mesnil. All rights reserved.

  			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

  			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

  			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  			*/

  			(function (Math) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var Hasher = C_lib.Hasher;
  			    var C_algo = C.algo;

  			    // Constants table
  			    var _zl = WordArray.create([
  			        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  			        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
  			        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
  			        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
  			        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
  			    var _zr = WordArray.create([
  			        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
  			        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
  			        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
  			        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
  			        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
  			    var _sl = WordArray.create([
  			         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
  			        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
  			        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
  			          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
  			        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
  			    var _sr = WordArray.create([
  			        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
  			        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
  			        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
  			        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
  			        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

  			    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
  			    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

  			    /**
  			     * RIPEMD160 hash algorithm.
  			     */
  			    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
  			        _doReset: function () {
  			            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
  			        },

  			        _doProcessBlock: function (M, offset) {

  			            // Swap endian
  			            for (var i = 0; i < 16; i++) {
  			                // Shortcuts
  			                var offset_i = offset + i;
  			                var M_offset_i = M[offset_i];

  			                // Swap
  			                M[offset_i] = (
  			                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
  			                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
  			                );
  			            }
  			            // Shortcut
  			            var H  = this._hash.words;
  			            var hl = _hl.words;
  			            var hr = _hr.words;
  			            var zl = _zl.words;
  			            var zr = _zr.words;
  			            var sl = _sl.words;
  			            var sr = _sr.words;

  			            // Working variables
  			            var al, bl, cl, dl, el;
  			            var ar, br, cr, dr, er;

  			            ar = al = H[0];
  			            br = bl = H[1];
  			            cr = cl = H[2];
  			            dr = dl = H[3];
  			            er = el = H[4];
  			            // Computation
  			            var t;
  			            for (var i = 0; i < 80; i += 1) {
  			                t = (al +  M[offset+zl[i]])|0;
  			                if (i<16){
  				            t +=  f1(bl,cl,dl) + hl[0];
  			                } else if (i<32) {
  				            t +=  f2(bl,cl,dl) + hl[1];
  			                } else if (i<48) {
  				            t +=  f3(bl,cl,dl) + hl[2];
  			                } else if (i<64) {
  				            t +=  f4(bl,cl,dl) + hl[3];
  			                } else {// if (i<80) {
  				            t +=  f5(bl,cl,dl) + hl[4];
  			                }
  			                t = t|0;
  			                t =  rotl(t,sl[i]);
  			                t = (t+el)|0;
  			                al = el;
  			                el = dl;
  			                dl = rotl(cl, 10);
  			                cl = bl;
  			                bl = t;

  			                t = (ar + M[offset+zr[i]])|0;
  			                if (i<16){
  				            t +=  f5(br,cr,dr) + hr[0];
  			                } else if (i<32) {
  				            t +=  f4(br,cr,dr) + hr[1];
  			                } else if (i<48) {
  				            t +=  f3(br,cr,dr) + hr[2];
  			                } else if (i<64) {
  				            t +=  f2(br,cr,dr) + hr[3];
  			                } else {// if (i<80) {
  				            t +=  f1(br,cr,dr) + hr[4];
  			                }
  			                t = t|0;
  			                t =  rotl(t,sr[i]) ;
  			                t = (t+er)|0;
  			                ar = er;
  			                er = dr;
  			                dr = rotl(cr, 10);
  			                cr = br;
  			                br = t;
  			            }
  			            // Intermediate hash value
  			            t    = (H[1] + cl + dr)|0;
  			            H[1] = (H[2] + dl + er)|0;
  			            H[2] = (H[3] + el + ar)|0;
  			            H[3] = (H[4] + al + br)|0;
  			            H[4] = (H[0] + bl + cr)|0;
  			            H[0] =  t;
  			        },

  			        _doFinalize: function () {
  			            // Shortcuts
  			            var data = this._data;
  			            var dataWords = data.words;

  			            var nBitsTotal = this._nDataBytes * 8;
  			            var nBitsLeft = data.sigBytes * 8;

  			            // Add padding
  			            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
  			            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
  			                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
  			                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
  			            );
  			            data.sigBytes = (dataWords.length + 1) * 4;

  			            // Hash final blocks
  			            this._process();

  			            // Shortcuts
  			            var hash = this._hash;
  			            var H = hash.words;

  			            // Swap endian
  			            for (var i = 0; i < 5; i++) {
  			                // Shortcut
  			                var H_i = H[i];

  			                // Swap
  			                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
  			                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
  			            }

  			            // Return final computed hash
  			            return hash;
  			        },

  			        clone: function () {
  			            var clone = Hasher.clone.call(this);
  			            clone._hash = this._hash.clone();

  			            return clone;
  			        }
  			    });


  			    function f1(x, y, z) {
  			        return ((x) ^ (y) ^ (z));

  			    }

  			    function f2(x, y, z) {
  			        return (((x)&(y)) | ((~x)&(z)));
  			    }

  			    function f3(x, y, z) {
  			        return (((x) | (~(y))) ^ (z));
  			    }

  			    function f4(x, y, z) {
  			        return (((x) & (z)) | ((y)&(~(z))));
  			    }

  			    function f5(x, y, z) {
  			        return ((x) ^ ((y) |(~(z))));

  			    }

  			    function rotl(x,n) {
  			        return (x<<n) | (x>>>(32-n));
  			    }


  			    /**
  			     * Shortcut function to the hasher's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     *
  			     * @return {WordArray} The hash.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hash = CryptoJS.RIPEMD160('message');
  			     *     var hash = CryptoJS.RIPEMD160(wordArray);
  			     */
  			    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

  			    /**
  			     * Shortcut function to the HMAC's object interface.
  			     *
  			     * @param {WordArray|string} message The message to hash.
  			     * @param {WordArray|string} key The secret key.
  			     *
  			     * @return {WordArray} The HMAC.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
  			     */
  			    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
  			}());


  			return CryptoJS.RIPEMD160;

  		})); 
  	} (ripemd160));
  	return ripemd160.exports;
  }

  var hmac = {exports: {}};

  var hasRequiredHmac;

  function requireHmac () {
  	if (hasRequiredHmac) return hmac.exports;
  	hasRequiredHmac = 1;
  	(function (module, exports) {
  (function (root, factory) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Base = C_lib.Base;
  			    var C_enc = C.enc;
  			    var Utf8 = C_enc.Utf8;
  			    var C_algo = C.algo;

  			    /**
  			     * HMAC algorithm.
  			     */
  			    C_algo.HMAC = Base.extend({
  			        /**
  			         * Initializes a newly created HMAC.
  			         *
  			         * @param {Hasher} hasher The hash algorithm to use.
  			         * @param {WordArray|string} key The secret key.
  			         *
  			         * @example
  			         *
  			         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
  			         */
  			        init: function (hasher, key) {
  			            // Init hasher
  			            hasher = this._hasher = new hasher.init();

  			            // Convert string to WordArray, else assume WordArray already
  			            if (typeof key == 'string') {
  			                key = Utf8.parse(key);
  			            }

  			            // Shortcuts
  			            var hasherBlockSize = hasher.blockSize;
  			            var hasherBlockSizeBytes = hasherBlockSize * 4;

  			            // Allow arbitrary length keys
  			            if (key.sigBytes > hasherBlockSizeBytes) {
  			                key = hasher.finalize(key);
  			            }

  			            // Clamp excess bits
  			            key.clamp();

  			            // Clone key for inner and outer pads
  			            var oKey = this._oKey = key.clone();
  			            var iKey = this._iKey = key.clone();

  			            // Shortcuts
  			            var oKeyWords = oKey.words;
  			            var iKeyWords = iKey.words;

  			            // XOR keys with pad constants
  			            for (var i = 0; i < hasherBlockSize; i++) {
  			                oKeyWords[i] ^= 0x5c5c5c5c;
  			                iKeyWords[i] ^= 0x36363636;
  			            }
  			            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

  			            // Set initial values
  			            this.reset();
  			        },

  			        /**
  			         * Resets this HMAC to its initial state.
  			         *
  			         * @example
  			         *
  			         *     hmacHasher.reset();
  			         */
  			        reset: function () {
  			            // Shortcut
  			            var hasher = this._hasher;

  			            // Reset
  			            hasher.reset();
  			            hasher.update(this._iKey);
  			        },

  			        /**
  			         * Updates this HMAC with a message.
  			         *
  			         * @param {WordArray|string} messageUpdate The message to append.
  			         *
  			         * @return {HMAC} This HMAC instance.
  			         *
  			         * @example
  			         *
  			         *     hmacHasher.update('message');
  			         *     hmacHasher.update(wordArray);
  			         */
  			        update: function (messageUpdate) {
  			            this._hasher.update(messageUpdate);

  			            // Chainable
  			            return this;
  			        },

  			        /**
  			         * Finalizes the HMAC computation.
  			         * Note that the finalize operation is effectively a destructive, read-once operation.
  			         *
  			         * @param {WordArray|string} messageUpdate (Optional) A final message update.
  			         *
  			         * @return {WordArray} The HMAC.
  			         *
  			         * @example
  			         *
  			         *     var hmac = hmacHasher.finalize();
  			         *     var hmac = hmacHasher.finalize('message');
  			         *     var hmac = hmacHasher.finalize(wordArray);
  			         */
  			        finalize: function (messageUpdate) {
  			            // Shortcut
  			            var hasher = this._hasher;

  			            // Compute HMAC
  			            var innerHash = hasher.finalize(messageUpdate);
  			            hasher.reset();
  			            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

  			            return hmac;
  			        }
  			    });
  			}());


  		})); 
  	} (hmac));
  	return hmac.exports;
  }

  var pbkdf2 = {exports: {}};

  var hasRequiredPbkdf2;

  function requirePbkdf2 () {
  	if (hasRequiredPbkdf2) return pbkdf2.exports;
  	hasRequiredPbkdf2 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireSha256(), requireHmac());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Base = C_lib.Base;
  			    var WordArray = C_lib.WordArray;
  			    var C_algo = C.algo;
  			    var SHA256 = C_algo.SHA256;
  			    var HMAC = C_algo.HMAC;

  			    /**
  			     * Password-Based Key Derivation Function 2 algorithm.
  			     */
  			    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
  			         * @property {Hasher} hasher The hasher to use. Default: SHA256
  			         * @property {number} iterations The number of iterations to perform. Default: 250000
  			         */
  			        cfg: Base.extend({
  			            keySize: 128/32,
  			            hasher: SHA256,
  			            iterations: 250000
  			        }),

  			        /**
  			         * Initializes a newly created key derivation function.
  			         *
  			         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
  			         *
  			         * @example
  			         *
  			         *     var kdf = CryptoJS.algo.PBKDF2.create();
  			         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
  			         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
  			         */
  			        init: function (cfg) {
  			            this.cfg = this.cfg.extend(cfg);
  			        },

  			        /**
  			         * Computes the Password-Based Key Derivation Function 2.
  			         *
  			         * @param {WordArray|string} password The password.
  			         * @param {WordArray|string} salt A salt.
  			         *
  			         * @return {WordArray} The derived key.
  			         *
  			         * @example
  			         *
  			         *     var key = kdf.compute(password, salt);
  			         */
  			        compute: function (password, salt) {
  			            // Shortcut
  			            var cfg = this.cfg;

  			            // Init HMAC
  			            var hmac = HMAC.create(cfg.hasher, password);

  			            // Initial values
  			            var derivedKey = WordArray.create();
  			            var blockIndex = WordArray.create([0x00000001]);

  			            // Shortcuts
  			            var derivedKeyWords = derivedKey.words;
  			            var blockIndexWords = blockIndex.words;
  			            var keySize = cfg.keySize;
  			            var iterations = cfg.iterations;

  			            // Generate key
  			            while (derivedKeyWords.length < keySize) {
  			                var block = hmac.update(salt).finalize(blockIndex);
  			                hmac.reset();

  			                // Shortcuts
  			                var blockWords = block.words;
  			                var blockWordsLength = blockWords.length;

  			                // Iterations
  			                var intermediate = block;
  			                for (var i = 1; i < iterations; i++) {
  			                    intermediate = hmac.finalize(intermediate);
  			                    hmac.reset();

  			                    // Shortcut
  			                    var intermediateWords = intermediate.words;

  			                    // XOR intermediate with block
  			                    for (var j = 0; j < blockWordsLength; j++) {
  			                        blockWords[j] ^= intermediateWords[j];
  			                    }
  			                }

  			                derivedKey.concat(block);
  			                blockIndexWords[0]++;
  			            }
  			            derivedKey.sigBytes = keySize * 4;

  			            return derivedKey;
  			        }
  			    });

  			    /**
  			     * Computes the Password-Based Key Derivation Function 2.
  			     *
  			     * @param {WordArray|string} password The password.
  			     * @param {WordArray|string} salt A salt.
  			     * @param {Object} cfg (Optional) The configuration options to use for this computation.
  			     *
  			     * @return {WordArray} The derived key.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var key = CryptoJS.PBKDF2(password, salt);
  			     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
  			     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
  			     */
  			    C.PBKDF2 = function (password, salt, cfg) {
  			        return PBKDF2.create(cfg).compute(password, salt);
  			    };
  			}());


  			return CryptoJS.PBKDF2;

  		})); 
  	} (pbkdf2));
  	return pbkdf2.exports;
  }

  var evpkdf = {exports: {}};

  var hasRequiredEvpkdf;

  function requireEvpkdf () {
  	if (hasRequiredEvpkdf) return evpkdf.exports;
  	hasRequiredEvpkdf = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireSha1(), requireHmac());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Base = C_lib.Base;
  			    var WordArray = C_lib.WordArray;
  			    var C_algo = C.algo;
  			    var MD5 = C_algo.MD5;

  			    /**
  			     * This key derivation function is meant to conform with EVP_BytesToKey.
  			     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
  			     */
  			    var EvpKDF = C_algo.EvpKDF = Base.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
  			         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
  			         * @property {number} iterations The number of iterations to perform. Default: 1
  			         */
  			        cfg: Base.extend({
  			            keySize: 128/32,
  			            hasher: MD5,
  			            iterations: 1
  			        }),

  			        /**
  			         * Initializes a newly created key derivation function.
  			         *
  			         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
  			         *
  			         * @example
  			         *
  			         *     var kdf = CryptoJS.algo.EvpKDF.create();
  			         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
  			         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
  			         */
  			        init: function (cfg) {
  			            this.cfg = this.cfg.extend(cfg);
  			        },

  			        /**
  			         * Derives a key from a password.
  			         *
  			         * @param {WordArray|string} password The password.
  			         * @param {WordArray|string} salt A salt.
  			         *
  			         * @return {WordArray} The derived key.
  			         *
  			         * @example
  			         *
  			         *     var key = kdf.compute(password, salt);
  			         */
  			        compute: function (password, salt) {
  			            var block;

  			            // Shortcut
  			            var cfg = this.cfg;

  			            // Init hasher
  			            var hasher = cfg.hasher.create();

  			            // Initial values
  			            var derivedKey = WordArray.create();

  			            // Shortcuts
  			            var derivedKeyWords = derivedKey.words;
  			            var keySize = cfg.keySize;
  			            var iterations = cfg.iterations;

  			            // Generate key
  			            while (derivedKeyWords.length < keySize) {
  			                if (block) {
  			                    hasher.update(block);
  			                }
  			                block = hasher.update(password).finalize(salt);
  			                hasher.reset();

  			                // Iterations
  			                for (var i = 1; i < iterations; i++) {
  			                    block = hasher.finalize(block);
  			                    hasher.reset();
  			                }

  			                derivedKey.concat(block);
  			            }
  			            derivedKey.sigBytes = keySize * 4;

  			            return derivedKey;
  			        }
  			    });

  			    /**
  			     * Derives a key from a password.
  			     *
  			     * @param {WordArray|string} password The password.
  			     * @param {WordArray|string} salt A salt.
  			     * @param {Object} cfg (Optional) The configuration options to use for this computation.
  			     *
  			     * @return {WordArray} The derived key.
  			     *
  			     * @static
  			     *
  			     * @example
  			     *
  			     *     var key = CryptoJS.EvpKDF(password, salt);
  			     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
  			     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
  			     */
  			    C.EvpKDF = function (password, salt, cfg) {
  			        return EvpKDF.create(cfg).compute(password, salt);
  			    };
  			}());


  			return CryptoJS.EvpKDF;

  		})); 
  	} (evpkdf));
  	return evpkdf.exports;
  }

  var cipherCore = {exports: {}};

  var hasRequiredCipherCore;

  function requireCipherCore () {
  	if (hasRequiredCipherCore) return cipherCore.exports;
  	hasRequiredCipherCore = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEvpkdf());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Cipher core components.
  			 */
  			CryptoJS.lib.Cipher || (function (undefined$1) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var Base = C_lib.Base;
  			    var WordArray = C_lib.WordArray;
  			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
  			    var C_enc = C.enc;
  			    C_enc.Utf8;
  			    var Base64 = C_enc.Base64;
  			    var C_algo = C.algo;
  			    var EvpKDF = C_algo.EvpKDF;

  			    /**
  			     * Abstract base cipher template.
  			     *
  			     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
  			     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
  			     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
  			     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
  			     */
  			    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {WordArray} iv The IV to use for this operation.
  			         */
  			        cfg: Base.extend(),

  			        /**
  			         * Creates this cipher in encryption mode.
  			         *
  			         * @param {WordArray} key The key.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {Cipher} A cipher instance.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
  			         */
  			        createEncryptor: function (key, cfg) {
  			            return this.create(this._ENC_XFORM_MODE, key, cfg);
  			        },

  			        /**
  			         * Creates this cipher in decryption mode.
  			         *
  			         * @param {WordArray} key The key.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {Cipher} A cipher instance.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
  			         */
  			        createDecryptor: function (key, cfg) {
  			            return this.create(this._DEC_XFORM_MODE, key, cfg);
  			        },

  			        /**
  			         * Initializes a newly created cipher.
  			         *
  			         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
  			         * @param {WordArray} key The key.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @example
  			         *
  			         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
  			         */
  			        init: function (xformMode, key, cfg) {
  			            // Apply config defaults
  			            this.cfg = this.cfg.extend(cfg);

  			            // Store transform mode and key
  			            this._xformMode = xformMode;
  			            this._key = key;

  			            // Set initial values
  			            this.reset();
  			        },

  			        /**
  			         * Resets this cipher to its initial state.
  			         *
  			         * @example
  			         *
  			         *     cipher.reset();
  			         */
  			        reset: function () {
  			            // Reset data buffer
  			            BufferedBlockAlgorithm.reset.call(this);

  			            // Perform concrete-cipher logic
  			            this._doReset();
  			        },

  			        /**
  			         * Adds data to be encrypted or decrypted.
  			         *
  			         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
  			         *
  			         * @return {WordArray} The data after processing.
  			         *
  			         * @example
  			         *
  			         *     var encrypted = cipher.process('data');
  			         *     var encrypted = cipher.process(wordArray);
  			         */
  			        process: function (dataUpdate) {
  			            // Append
  			            this._append(dataUpdate);

  			            // Process available blocks
  			            return this._process();
  			        },

  			        /**
  			         * Finalizes the encryption or decryption process.
  			         * Note that the finalize operation is effectively a destructive, read-once operation.
  			         *
  			         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
  			         *
  			         * @return {WordArray} The data after final processing.
  			         *
  			         * @example
  			         *
  			         *     var encrypted = cipher.finalize();
  			         *     var encrypted = cipher.finalize('data');
  			         *     var encrypted = cipher.finalize(wordArray);
  			         */
  			        finalize: function (dataUpdate) {
  			            // Final data update
  			            if (dataUpdate) {
  			                this._append(dataUpdate);
  			            }

  			            // Perform concrete-cipher logic
  			            var finalProcessedData = this._doFinalize();

  			            return finalProcessedData;
  			        },

  			        keySize: 128/32,

  			        ivSize: 128/32,

  			        _ENC_XFORM_MODE: 1,

  			        _DEC_XFORM_MODE: 2,

  			        /**
  			         * Creates shortcut functions to a cipher's object interface.
  			         *
  			         * @param {Cipher} cipher The cipher to create a helper for.
  			         *
  			         * @return {Object} An object with encrypt and decrypt shortcut functions.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
  			         */
  			        _createHelper: (function () {
  			            function selectCipherStrategy(key) {
  			                if (typeof key == 'string') {
  			                    return PasswordBasedCipher;
  			                } else {
  			                    return SerializableCipher;
  			                }
  			            }

  			            return function (cipher) {
  			                return {
  			                    encrypt: function (message, key, cfg) {
  			                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
  			                    },

  			                    decrypt: function (ciphertext, key, cfg) {
  			                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
  			                    }
  			                };
  			            };
  			        }())
  			    });

  			    /**
  			     * Abstract base stream cipher template.
  			     *
  			     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
  			     */
  			    C_lib.StreamCipher = Cipher.extend({
  			        _doFinalize: function () {
  			            // Process partial blocks
  			            var finalProcessedBlocks = this._process(!!'flush');

  			            return finalProcessedBlocks;
  			        },

  			        blockSize: 1
  			    });

  			    /**
  			     * Mode namespace.
  			     */
  			    var C_mode = C.mode = {};

  			    /**
  			     * Abstract base block cipher mode template.
  			     */
  			    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
  			        /**
  			         * Creates this mode for encryption.
  			         *
  			         * @param {Cipher} cipher A block cipher instance.
  			         * @param {Array} iv The IV words.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
  			         */
  			        createEncryptor: function (cipher, iv) {
  			            return this.Encryptor.create(cipher, iv);
  			        },

  			        /**
  			         * Creates this mode for decryption.
  			         *
  			         * @param {Cipher} cipher A block cipher instance.
  			         * @param {Array} iv The IV words.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
  			         */
  			        createDecryptor: function (cipher, iv) {
  			            return this.Decryptor.create(cipher, iv);
  			        },

  			        /**
  			         * Initializes a newly created mode.
  			         *
  			         * @param {Cipher} cipher A block cipher instance.
  			         * @param {Array} iv The IV words.
  			         *
  			         * @example
  			         *
  			         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
  			         */
  			        init: function (cipher, iv) {
  			            this._cipher = cipher;
  			            this._iv = iv;
  			        }
  			    });

  			    /**
  			     * Cipher Block Chaining mode.
  			     */
  			    var CBC = C_mode.CBC = (function () {
  			        /**
  			         * Abstract base CBC mode.
  			         */
  			        var CBC = BlockCipherMode.extend();

  			        /**
  			         * CBC encryptor.
  			         */
  			        CBC.Encryptor = CBC.extend({
  			            /**
  			             * Processes the data block at offset.
  			             *
  			             * @param {Array} words The data words to operate on.
  			             * @param {number} offset The offset where the block starts.
  			             *
  			             * @example
  			             *
  			             *     mode.processBlock(data.words, offset);
  			             */
  			            processBlock: function (words, offset) {
  			                // Shortcuts
  			                var cipher = this._cipher;
  			                var blockSize = cipher.blockSize;

  			                // XOR and encrypt
  			                xorBlock.call(this, words, offset, blockSize);
  			                cipher.encryptBlock(words, offset);

  			                // Remember this block to use with next block
  			                this._prevBlock = words.slice(offset, offset + blockSize);
  			            }
  			        });

  			        /**
  			         * CBC decryptor.
  			         */
  			        CBC.Decryptor = CBC.extend({
  			            /**
  			             * Processes the data block at offset.
  			             *
  			             * @param {Array} words The data words to operate on.
  			             * @param {number} offset The offset where the block starts.
  			             *
  			             * @example
  			             *
  			             *     mode.processBlock(data.words, offset);
  			             */
  			            processBlock: function (words, offset) {
  			                // Shortcuts
  			                var cipher = this._cipher;
  			                var blockSize = cipher.blockSize;

  			                // Remember this block to use with next block
  			                var thisBlock = words.slice(offset, offset + blockSize);

  			                // Decrypt and XOR
  			                cipher.decryptBlock(words, offset);
  			                xorBlock.call(this, words, offset, blockSize);

  			                // This block becomes the previous block
  			                this._prevBlock = thisBlock;
  			            }
  			        });

  			        function xorBlock(words, offset, blockSize) {
  			            var block;

  			            // Shortcut
  			            var iv = this._iv;

  			            // Choose mixing block
  			            if (iv) {
  			                block = iv;

  			                // Remove IV for subsequent blocks
  			                this._iv = undefined$1;
  			            } else {
  			                block = this._prevBlock;
  			            }

  			            // XOR blocks
  			            for (var i = 0; i < blockSize; i++) {
  			                words[offset + i] ^= block[i];
  			            }
  			        }

  			        return CBC;
  			    }());

  			    /**
  			     * Padding namespace.
  			     */
  			    var C_pad = C.pad = {};

  			    /**
  			     * PKCS #5/7 padding strategy.
  			     */
  			    var Pkcs7 = C_pad.Pkcs7 = {
  			        /**
  			         * Pads data using the algorithm defined in PKCS #5/7.
  			         *
  			         * @param {WordArray} data The data to pad.
  			         * @param {number} blockSize The multiple that the data should be padded to.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
  			         */
  			        pad: function (data, blockSize) {
  			            // Shortcut
  			            var blockSizeBytes = blockSize * 4;

  			            // Count padding bytes
  			            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

  			            // Create padding word
  			            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

  			            // Create padding
  			            var paddingWords = [];
  			            for (var i = 0; i < nPaddingBytes; i += 4) {
  			                paddingWords.push(paddingWord);
  			            }
  			            var padding = WordArray.create(paddingWords, nPaddingBytes);

  			            // Add padding
  			            data.concat(padding);
  			        },

  			        /**
  			         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
  			         *
  			         * @param {WordArray} data The data to unpad.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
  			         */
  			        unpad: function (data) {
  			            // Get number of padding bytes from last byte
  			            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

  			            // Remove padding
  			            data.sigBytes -= nPaddingBytes;
  			        }
  			    };

  			    /**
  			     * Abstract base block cipher template.
  			     *
  			     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
  			     */
  			    C_lib.BlockCipher = Cipher.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {Mode} mode The block mode to use. Default: CBC
  			         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
  			         */
  			        cfg: Cipher.cfg.extend({
  			            mode: CBC,
  			            padding: Pkcs7
  			        }),

  			        reset: function () {
  			            var modeCreator;

  			            // Reset cipher
  			            Cipher.reset.call(this);

  			            // Shortcuts
  			            var cfg = this.cfg;
  			            var iv = cfg.iv;
  			            var mode = cfg.mode;

  			            // Reset block mode
  			            if (this._xformMode == this._ENC_XFORM_MODE) {
  			                modeCreator = mode.createEncryptor;
  			            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
  			                modeCreator = mode.createDecryptor;
  			                // Keep at least one block in the buffer for unpadding
  			                this._minBufferSize = 1;
  			            }

  			            if (this._mode && this._mode.__creator == modeCreator) {
  			                this._mode.init(this, iv && iv.words);
  			            } else {
  			                this._mode = modeCreator.call(mode, this, iv && iv.words);
  			                this._mode.__creator = modeCreator;
  			            }
  			        },

  			        _doProcessBlock: function (words, offset) {
  			            this._mode.processBlock(words, offset);
  			        },

  			        _doFinalize: function () {
  			            var finalProcessedBlocks;

  			            // Shortcut
  			            var padding = this.cfg.padding;

  			            // Finalize
  			            if (this._xformMode == this._ENC_XFORM_MODE) {
  			                // Pad data
  			                padding.pad(this._data, this.blockSize);

  			                // Process final blocks
  			                finalProcessedBlocks = this._process(!!'flush');
  			            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
  			                // Process final blocks
  			                finalProcessedBlocks = this._process(!!'flush');

  			                // Unpad data
  			                padding.unpad(finalProcessedBlocks);
  			            }

  			            return finalProcessedBlocks;
  			        },

  			        blockSize: 128/32
  			    });

  			    /**
  			     * A collection of cipher parameters.
  			     *
  			     * @property {WordArray} ciphertext The raw ciphertext.
  			     * @property {WordArray} key The key to this ciphertext.
  			     * @property {WordArray} iv The IV used in the ciphering operation.
  			     * @property {WordArray} salt The salt used with a key derivation function.
  			     * @property {Cipher} algorithm The cipher algorithm.
  			     * @property {Mode} mode The block mode used in the ciphering operation.
  			     * @property {Padding} padding The padding scheme used in the ciphering operation.
  			     * @property {number} blockSize The block size of the cipher.
  			     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
  			     */
  			    var CipherParams = C_lib.CipherParams = Base.extend({
  			        /**
  			         * Initializes a newly created cipher params object.
  			         *
  			         * @param {Object} cipherParams An object with any of the possible cipher parameters.
  			         *
  			         * @example
  			         *
  			         *     var cipherParams = CryptoJS.lib.CipherParams.create({
  			         *         ciphertext: ciphertextWordArray,
  			         *         key: keyWordArray,
  			         *         iv: ivWordArray,
  			         *         salt: saltWordArray,
  			         *         algorithm: CryptoJS.algo.AES,
  			         *         mode: CryptoJS.mode.CBC,
  			         *         padding: CryptoJS.pad.PKCS7,
  			         *         blockSize: 4,
  			         *         formatter: CryptoJS.format.OpenSSL
  			         *     });
  			         */
  			        init: function (cipherParams) {
  			            this.mixIn(cipherParams);
  			        },

  			        /**
  			         * Converts this cipher params object to a string.
  			         *
  			         * @param {Format} formatter (Optional) The formatting strategy to use.
  			         *
  			         * @return {string} The stringified cipher params.
  			         *
  			         * @throws Error If neither the formatter nor the default formatter is set.
  			         *
  			         * @example
  			         *
  			         *     var string = cipherParams + '';
  			         *     var string = cipherParams.toString();
  			         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
  			         */
  			        toString: function (formatter) {
  			            return (formatter || this.formatter).stringify(this);
  			        }
  			    });

  			    /**
  			     * Format namespace.
  			     */
  			    var C_format = C.format = {};

  			    /**
  			     * OpenSSL formatting strategy.
  			     */
  			    var OpenSSLFormatter = C_format.OpenSSL = {
  			        /**
  			         * Converts a cipher params object to an OpenSSL-compatible string.
  			         *
  			         * @param {CipherParams} cipherParams The cipher params object.
  			         *
  			         * @return {string} The OpenSSL-compatible string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
  			         */
  			        stringify: function (cipherParams) {
  			            var wordArray;

  			            // Shortcuts
  			            var ciphertext = cipherParams.ciphertext;
  			            var salt = cipherParams.salt;

  			            // Format
  			            if (salt) {
  			                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
  			            } else {
  			                wordArray = ciphertext;
  			            }

  			            return wordArray.toString(Base64);
  			        },

  			        /**
  			         * Converts an OpenSSL-compatible string to a cipher params object.
  			         *
  			         * @param {string} openSSLStr The OpenSSL-compatible string.
  			         *
  			         * @return {CipherParams} The cipher params object.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
  			         */
  			        parse: function (openSSLStr) {
  			            var salt;

  			            // Parse base64
  			            var ciphertext = Base64.parse(openSSLStr);

  			            // Shortcut
  			            var ciphertextWords = ciphertext.words;

  			            // Test for salt
  			            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
  			                // Extract salt
  			                salt = WordArray.create(ciphertextWords.slice(2, 4));

  			                // Remove salt from ciphertext
  			                ciphertextWords.splice(0, 4);
  			                ciphertext.sigBytes -= 16;
  			            }

  			            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
  			        }
  			    };

  			    /**
  			     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
  			     */
  			    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
  			         */
  			        cfg: Base.extend({
  			            format: OpenSSLFormatter
  			        }),

  			        /**
  			         * Encrypts a message.
  			         *
  			         * @param {Cipher} cipher The cipher algorithm to use.
  			         * @param {WordArray|string} message The message to encrypt.
  			         * @param {WordArray} key The key.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {CipherParams} A cipher params object.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
  			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
  			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
  			         */
  			        encrypt: function (cipher, message, key, cfg) {
  			            // Apply config defaults
  			            cfg = this.cfg.extend(cfg);

  			            // Encrypt
  			            var encryptor = cipher.createEncryptor(key, cfg);
  			            var ciphertext = encryptor.finalize(message);

  			            // Shortcut
  			            var cipherCfg = encryptor.cfg;

  			            // Create and return serializable cipher params
  			            return CipherParams.create({
  			                ciphertext: ciphertext,
  			                key: key,
  			                iv: cipherCfg.iv,
  			                algorithm: cipher,
  			                mode: cipherCfg.mode,
  			                padding: cipherCfg.padding,
  			                blockSize: cipher.blockSize,
  			                formatter: cfg.format
  			            });
  			        },

  			        /**
  			         * Decrypts serialized ciphertext.
  			         *
  			         * @param {Cipher} cipher The cipher algorithm to use.
  			         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
  			         * @param {WordArray} key The key.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {WordArray} The plaintext.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
  			         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
  			         */
  			        decrypt: function (cipher, ciphertext, key, cfg) {
  			            // Apply config defaults
  			            cfg = this.cfg.extend(cfg);

  			            // Convert string to CipherParams
  			            ciphertext = this._parse(ciphertext, cfg.format);

  			            // Decrypt
  			            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

  			            return plaintext;
  			        },

  			        /**
  			         * Converts serialized ciphertext to CipherParams,
  			         * else assumed CipherParams already and returns ciphertext unchanged.
  			         *
  			         * @param {CipherParams|string} ciphertext The ciphertext.
  			         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
  			         *
  			         * @return {CipherParams} The unserialized ciphertext.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
  			         */
  			        _parse: function (ciphertext, format) {
  			            if (typeof ciphertext == 'string') {
  			                return format.parse(ciphertext, this);
  			            } else {
  			                return ciphertext;
  			            }
  			        }
  			    });

  			    /**
  			     * Key derivation function namespace.
  			     */
  			    var C_kdf = C.kdf = {};

  			    /**
  			     * OpenSSL key derivation function.
  			     */
  			    var OpenSSLKdf = C_kdf.OpenSSL = {
  			        /**
  			         * Derives a key and IV from a password.
  			         *
  			         * @param {string} password The password to derive from.
  			         * @param {number} keySize The size in words of the key to generate.
  			         * @param {number} ivSize The size in words of the IV to generate.
  			         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
  			         *
  			         * @return {CipherParams} A cipher params object with the key, IV, and salt.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
  			         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
  			         */
  			        execute: function (password, keySize, ivSize, salt, hasher) {
  			            // Generate random salt
  			            if (!salt) {
  			                salt = WordArray.random(64/8);
  			            }

  			            // Derive key and IV
  			            if (!hasher) {
  			                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
  			            } else {
  			                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);
  			            }


  			            // Separate key and IV
  			            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
  			            key.sigBytes = keySize * 4;

  			            // Return params
  			            return CipherParams.create({ key: key, iv: iv, salt: salt });
  			        }
  			    };

  			    /**
  			     * A serializable cipher wrapper that derives the key from a password,
  			     * and returns ciphertext as a serializable cipher params object.
  			     */
  			    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
  			         */
  			        cfg: SerializableCipher.cfg.extend({
  			            kdf: OpenSSLKdf
  			        }),

  			        /**
  			         * Encrypts a message using a password.
  			         *
  			         * @param {Cipher} cipher The cipher algorithm to use.
  			         * @param {WordArray|string} message The message to encrypt.
  			         * @param {string} password The password.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {CipherParams} A cipher params object.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
  			         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
  			         */
  			        encrypt: function (cipher, message, password, cfg) {
  			            // Apply config defaults
  			            cfg = this.cfg.extend(cfg);

  			            // Derive key and other params
  			            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);

  			            // Add IV to config
  			            cfg.iv = derivedParams.iv;

  			            // Encrypt
  			            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

  			            // Mix in derived params
  			            ciphertext.mixIn(derivedParams);

  			            return ciphertext;
  			        },

  			        /**
  			         * Decrypts serialized ciphertext using a password.
  			         *
  			         * @param {Cipher} cipher The cipher algorithm to use.
  			         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
  			         * @param {string} password The password.
  			         * @param {Object} cfg (Optional) The configuration options to use for this operation.
  			         *
  			         * @return {WordArray} The plaintext.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
  			         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
  			         */
  			        decrypt: function (cipher, ciphertext, password, cfg) {
  			            // Apply config defaults
  			            cfg = this.cfg.extend(cfg);

  			            // Convert string to CipherParams
  			            ciphertext = this._parse(ciphertext, cfg.format);

  			            // Derive key and other params
  			            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);

  			            // Add IV to config
  			            cfg.iv = derivedParams.iv;

  			            // Decrypt
  			            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

  			            return plaintext;
  			        }
  			    });
  			}());


  		})); 
  	} (cipherCore));
  	return cipherCore.exports;
  }

  var modeCfb = {exports: {}};

  var hasRequiredModeCfb;

  function requireModeCfb () {
  	if (hasRequiredModeCfb) return modeCfb.exports;
  	hasRequiredModeCfb = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Cipher Feedback block mode.
  			 */
  			CryptoJS.mode.CFB = (function () {
  			    var CFB = CryptoJS.lib.BlockCipherMode.extend();

  			    CFB.Encryptor = CFB.extend({
  			        processBlock: function (words, offset) {
  			            // Shortcuts
  			            var cipher = this._cipher;
  			            var blockSize = cipher.blockSize;

  			            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

  			            // Remember this block to use with next block
  			            this._prevBlock = words.slice(offset, offset + blockSize);
  			        }
  			    });

  			    CFB.Decryptor = CFB.extend({
  			        processBlock: function (words, offset) {
  			            // Shortcuts
  			            var cipher = this._cipher;
  			            var blockSize = cipher.blockSize;

  			            // Remember this block to use with next block
  			            var thisBlock = words.slice(offset, offset + blockSize);

  			            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

  			            // This block becomes the previous block
  			            this._prevBlock = thisBlock;
  			        }
  			    });

  			    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
  			        var keystream;

  			        // Shortcut
  			        var iv = this._iv;

  			        // Generate keystream
  			        if (iv) {
  			            keystream = iv.slice(0);

  			            // Remove IV for subsequent blocks
  			            this._iv = undefined;
  			        } else {
  			            keystream = this._prevBlock;
  			        }
  			        cipher.encryptBlock(keystream, 0);

  			        // Encrypt
  			        for (var i = 0; i < blockSize; i++) {
  			            words[offset + i] ^= keystream[i];
  			        }
  			    }

  			    return CFB;
  			}());


  			return CryptoJS.mode.CFB;

  		})); 
  	} (modeCfb));
  	return modeCfb.exports;
  }

  var modeCtr = {exports: {}};

  var hasRequiredModeCtr;

  function requireModeCtr () {
  	if (hasRequiredModeCtr) return modeCtr.exports;
  	hasRequiredModeCtr = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Counter block mode.
  			 */
  			CryptoJS.mode.CTR = (function () {
  			    var CTR = CryptoJS.lib.BlockCipherMode.extend();

  			    var Encryptor = CTR.Encryptor = CTR.extend({
  			        processBlock: function (words, offset) {
  			            // Shortcuts
  			            var cipher = this._cipher;
  			            var blockSize = cipher.blockSize;
  			            var iv = this._iv;
  			            var counter = this._counter;

  			            // Generate keystream
  			            if (iv) {
  			                counter = this._counter = iv.slice(0);

  			                // Remove IV for subsequent blocks
  			                this._iv = undefined;
  			            }
  			            var keystream = counter.slice(0);
  			            cipher.encryptBlock(keystream, 0);

  			            // Increment counter
  			            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;

  			            // Encrypt
  			            for (var i = 0; i < blockSize; i++) {
  			                words[offset + i] ^= keystream[i];
  			            }
  			        }
  			    });

  			    CTR.Decryptor = Encryptor;

  			    return CTR;
  			}());


  			return CryptoJS.mode.CTR;

  		})); 
  	} (modeCtr));
  	return modeCtr.exports;
  }

  var modeCtrGladman = {exports: {}};

  var hasRequiredModeCtrGladman;

  function requireModeCtrGladman () {
  	if (hasRequiredModeCtrGladman) return modeCtrGladman.exports;
  	hasRequiredModeCtrGladman = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/** @preserve
  			 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
  			 * derived from CryptoJS.mode.CTR
  			 * Jan Hruby jhruby.web@gmail.com
  			 */
  			CryptoJS.mode.CTRGladman = (function () {
  			    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

  				function incWord(word)
  				{
  					if (((word >> 24) & 0xff) === 0xff) { //overflow
  					var b1 = (word >> 16)&0xff;
  					var b2 = (word >> 8)&0xff;
  					var b3 = word & 0xff;

  					if (b1 === 0xff) // overflow b1
  					{
  					b1 = 0;
  					if (b2 === 0xff)
  					{
  						b2 = 0;
  						if (b3 === 0xff)
  						{
  							b3 = 0;
  						}
  						else
  						{
  							++b3;
  						}
  					}
  					else
  					{
  						++b2;
  					}
  					}
  					else
  					{
  					++b1;
  					}

  					word = 0;
  					word += (b1 << 16);
  					word += (b2 << 8);
  					word += b3;
  					}
  					else
  					{
  					word += (0x01 << 24);
  					}
  					return word;
  				}

  				function incCounter(counter)
  				{
  					if ((counter[0] = incWord(counter[0])) === 0)
  					{
  						// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
  						counter[1] = incWord(counter[1]);
  					}
  					return counter;
  				}

  			    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
  			        processBlock: function (words, offset) {
  			            // Shortcuts
  			            var cipher = this._cipher;
  			            var blockSize = cipher.blockSize;
  			            var iv = this._iv;
  			            var counter = this._counter;

  			            // Generate keystream
  			            if (iv) {
  			                counter = this._counter = iv.slice(0);

  			                // Remove IV for subsequent blocks
  			                this._iv = undefined;
  			            }

  						incCounter(counter);

  						var keystream = counter.slice(0);
  			            cipher.encryptBlock(keystream, 0);

  			            // Encrypt
  			            for (var i = 0; i < blockSize; i++) {
  			                words[offset + i] ^= keystream[i];
  			            }
  			        }
  			    });

  			    CTRGladman.Decryptor = Encryptor;

  			    return CTRGladman;
  			}());




  			return CryptoJS.mode.CTRGladman;

  		})); 
  	} (modeCtrGladman));
  	return modeCtrGladman.exports;
  }

  var modeOfb = {exports: {}};

  var hasRequiredModeOfb;

  function requireModeOfb () {
  	if (hasRequiredModeOfb) return modeOfb.exports;
  	hasRequiredModeOfb = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Output Feedback block mode.
  			 */
  			CryptoJS.mode.OFB = (function () {
  			    var OFB = CryptoJS.lib.BlockCipherMode.extend();

  			    var Encryptor = OFB.Encryptor = OFB.extend({
  			        processBlock: function (words, offset) {
  			            // Shortcuts
  			            var cipher = this._cipher;
  			            var blockSize = cipher.blockSize;
  			            var iv = this._iv;
  			            var keystream = this._keystream;

  			            // Generate keystream
  			            if (iv) {
  			                keystream = this._keystream = iv.slice(0);

  			                // Remove IV for subsequent blocks
  			                this._iv = undefined;
  			            }
  			            cipher.encryptBlock(keystream, 0);

  			            // Encrypt
  			            for (var i = 0; i < blockSize; i++) {
  			                words[offset + i] ^= keystream[i];
  			            }
  			        }
  			    });

  			    OFB.Decryptor = Encryptor;

  			    return OFB;
  			}());


  			return CryptoJS.mode.OFB;

  		})); 
  	} (modeOfb));
  	return modeOfb.exports;
  }

  var modeEcb = {exports: {}};

  var hasRequiredModeEcb;

  function requireModeEcb () {
  	if (hasRequiredModeEcb) return modeEcb.exports;
  	hasRequiredModeEcb = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Electronic Codebook block mode.
  			 */
  			CryptoJS.mode.ECB = (function () {
  			    var ECB = CryptoJS.lib.BlockCipherMode.extend();

  			    ECB.Encryptor = ECB.extend({
  			        processBlock: function (words, offset) {
  			            this._cipher.encryptBlock(words, offset);
  			        }
  			    });

  			    ECB.Decryptor = ECB.extend({
  			        processBlock: function (words, offset) {
  			            this._cipher.decryptBlock(words, offset);
  			        }
  			    });

  			    return ECB;
  			}());


  			return CryptoJS.mode.ECB;

  		})); 
  	} (modeEcb));
  	return modeEcb.exports;
  }

  var padAnsix923 = {exports: {}};

  var hasRequiredPadAnsix923;

  function requirePadAnsix923 () {
  	if (hasRequiredPadAnsix923) return padAnsix923.exports;
  	hasRequiredPadAnsix923 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * ANSI X.923 padding strategy.
  			 */
  			CryptoJS.pad.AnsiX923 = {
  			    pad: function (data, blockSize) {
  			        // Shortcuts
  			        var dataSigBytes = data.sigBytes;
  			        var blockSizeBytes = blockSize * 4;

  			        // Count padding bytes
  			        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

  			        // Compute last byte position
  			        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

  			        // Pad
  			        data.clamp();
  			        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
  			        data.sigBytes += nPaddingBytes;
  			    },

  			    unpad: function (data) {
  			        // Get number of padding bytes from last byte
  			        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

  			        // Remove padding
  			        data.sigBytes -= nPaddingBytes;
  			    }
  			};


  			return CryptoJS.pad.Ansix923;

  		})); 
  	} (padAnsix923));
  	return padAnsix923.exports;
  }

  var padIso10126 = {exports: {}};

  var hasRequiredPadIso10126;

  function requirePadIso10126 () {
  	if (hasRequiredPadIso10126) return padIso10126.exports;
  	hasRequiredPadIso10126 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * ISO 10126 padding strategy.
  			 */
  			CryptoJS.pad.Iso10126 = {
  			    pad: function (data, blockSize) {
  			        // Shortcut
  			        var blockSizeBytes = blockSize * 4;

  			        // Count padding bytes
  			        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

  			        // Pad
  			        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
  			             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
  			    },

  			    unpad: function (data) {
  			        // Get number of padding bytes from last byte
  			        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

  			        // Remove padding
  			        data.sigBytes -= nPaddingBytes;
  			    }
  			};


  			return CryptoJS.pad.Iso10126;

  		})); 
  	} (padIso10126));
  	return padIso10126.exports;
  }

  var padIso97971 = {exports: {}};

  var hasRequiredPadIso97971;

  function requirePadIso97971 () {
  	if (hasRequiredPadIso97971) return padIso97971.exports;
  	hasRequiredPadIso97971 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * ISO/IEC 9797-1 Padding Method 2.
  			 */
  			CryptoJS.pad.Iso97971 = {
  			    pad: function (data, blockSize) {
  			        // Add 0x80 byte
  			        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

  			        // Zero pad the rest
  			        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
  			    },

  			    unpad: function (data) {
  			        // Remove zero padding
  			        CryptoJS.pad.ZeroPadding.unpad(data);

  			        // Remove one more byte -- the 0x80 byte
  			        data.sigBytes--;
  			    }
  			};


  			return CryptoJS.pad.Iso97971;

  		})); 
  	} (padIso97971));
  	return padIso97971.exports;
  }

  var padZeropadding = {exports: {}};

  var hasRequiredPadZeropadding;

  function requirePadZeropadding () {
  	if (hasRequiredPadZeropadding) return padZeropadding.exports;
  	hasRequiredPadZeropadding = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * Zero padding strategy.
  			 */
  			CryptoJS.pad.ZeroPadding = {
  			    pad: function (data, blockSize) {
  			        // Shortcut
  			        var blockSizeBytes = blockSize * 4;

  			        // Pad
  			        data.clamp();
  			        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
  			    },

  			    unpad: function (data) {
  			        // Shortcut
  			        var dataWords = data.words;

  			        // Unpad
  			        var i = data.sigBytes - 1;
  			        for (var i = data.sigBytes - 1; i >= 0; i--) {
  			            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
  			                data.sigBytes = i + 1;
  			                break;
  			            }
  			        }
  			    }
  			};


  			return CryptoJS.pad.ZeroPadding;

  		})); 
  	} (padZeropadding));
  	return padZeropadding.exports;
  }

  var padNopadding = {exports: {}};

  var hasRequiredPadNopadding;

  function requirePadNopadding () {
  	if (hasRequiredPadNopadding) return padNopadding.exports;
  	hasRequiredPadNopadding = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			/**
  			 * A noop padding strategy.
  			 */
  			CryptoJS.pad.NoPadding = {
  			    pad: function () {
  			    },

  			    unpad: function () {
  			    }
  			};


  			return CryptoJS.pad.NoPadding;

  		})); 
  	} (padNopadding));
  	return padNopadding.exports;
  }

  var formatHex = {exports: {}};

  var hasRequiredFormatHex;

  function requireFormatHex () {
  	if (hasRequiredFormatHex) return formatHex.exports;
  	hasRequiredFormatHex = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function (undefined$1) {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var CipherParams = C_lib.CipherParams;
  			    var C_enc = C.enc;
  			    var Hex = C_enc.Hex;
  			    var C_format = C.format;

  			    C_format.Hex = {
  			        /**
  			         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
  			         *
  			         * @param {CipherParams} cipherParams The cipher params object.
  			         *
  			         * @return {string} The hexadecimally encoded string.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
  			         */
  			        stringify: function (cipherParams) {
  			            return cipherParams.ciphertext.toString(Hex);
  			        },

  			        /**
  			         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
  			         *
  			         * @param {string} input The hexadecimally encoded string.
  			         *
  			         * @return {CipherParams} The cipher params object.
  			         *
  			         * @static
  			         *
  			         * @example
  			         *
  			         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
  			         */
  			        parse: function (input) {
  			            var ciphertext = Hex.parse(input);
  			            return CipherParams.create({ ciphertext: ciphertext });
  			        }
  			    };
  			}());


  			return CryptoJS.format.Hex;

  		})); 
  	} (formatHex));
  	return formatHex.exports;
  }

  var aes = {exports: {}};

  var hasRequiredAes;

  function requireAes () {
  	if (hasRequiredAes) return aes.exports;
  	hasRequiredAes = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var BlockCipher = C_lib.BlockCipher;
  			    var C_algo = C.algo;

  			    // Lookup tables
  			    var SBOX = [];
  			    var INV_SBOX = [];
  			    var SUB_MIX_0 = [];
  			    var SUB_MIX_1 = [];
  			    var SUB_MIX_2 = [];
  			    var SUB_MIX_3 = [];
  			    var INV_SUB_MIX_0 = [];
  			    var INV_SUB_MIX_1 = [];
  			    var INV_SUB_MIX_2 = [];
  			    var INV_SUB_MIX_3 = [];

  			    // Compute lookup tables
  			    (function () {
  			        // Compute double table
  			        var d = [];
  			        for (var i = 0; i < 256; i++) {
  			            if (i < 128) {
  			                d[i] = i << 1;
  			            } else {
  			                d[i] = (i << 1) ^ 0x11b;
  			            }
  			        }

  			        // Walk GF(2^8)
  			        var x = 0;
  			        var xi = 0;
  			        for (var i = 0; i < 256; i++) {
  			            // Compute sbox
  			            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
  			            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
  			            SBOX[x] = sx;
  			            INV_SBOX[sx] = x;

  			            // Compute multiplication
  			            var x2 = d[x];
  			            var x4 = d[x2];
  			            var x8 = d[x4];

  			            // Compute sub bytes, mix columns tables
  			            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
  			            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
  			            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
  			            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
  			            SUB_MIX_3[x] = t;

  			            // Compute inv sub bytes, inv mix columns tables
  			            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
  			            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
  			            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
  			            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
  			            INV_SUB_MIX_3[sx] = t;

  			            // Compute next counter
  			            if (!x) {
  			                x = xi = 1;
  			            } else {
  			                x = x2 ^ d[d[d[x8 ^ x2]]];
  			                xi ^= d[d[xi]];
  			            }
  			        }
  			    }());

  			    // Precomputed Rcon lookup
  			    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

  			    /**
  			     * AES block cipher algorithm.
  			     */
  			    var AES = C_algo.AES = BlockCipher.extend({
  			        _doReset: function () {
  			            var t;

  			            // Skip reset of nRounds has been set before and key did not change
  			            if (this._nRounds && this._keyPriorReset === this._key) {
  			                return;
  			            }

  			            // Shortcuts
  			            var key = this._keyPriorReset = this._key;
  			            var keyWords = key.words;
  			            var keySize = key.sigBytes / 4;

  			            // Compute number of rounds
  			            var nRounds = this._nRounds = keySize + 6;

  			            // Compute number of key schedule rows
  			            var ksRows = (nRounds + 1) * 4;

  			            // Compute key schedule
  			            var keySchedule = this._keySchedule = [];
  			            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
  			                if (ksRow < keySize) {
  			                    keySchedule[ksRow] = keyWords[ksRow];
  			                } else {
  			                    t = keySchedule[ksRow - 1];

  			                    if (!(ksRow % keySize)) {
  			                        // Rot word
  			                        t = (t << 8) | (t >>> 24);

  			                        // Sub word
  			                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

  			                        // Mix Rcon
  			                        t ^= RCON[(ksRow / keySize) | 0] << 24;
  			                    } else if (keySize > 6 && ksRow % keySize == 4) {
  			                        // Sub word
  			                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
  			                    }

  			                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
  			                }
  			            }

  			            // Compute inv key schedule
  			            var invKeySchedule = this._invKeySchedule = [];
  			            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
  			                var ksRow = ksRows - invKsRow;

  			                if (invKsRow % 4) {
  			                    var t = keySchedule[ksRow];
  			                } else {
  			                    var t = keySchedule[ksRow - 4];
  			                }

  			                if (invKsRow < 4 || ksRow <= 4) {
  			                    invKeySchedule[invKsRow] = t;
  			                } else {
  			                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
  			                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
  			                }
  			            }
  			        },

  			        encryptBlock: function (M, offset) {
  			            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
  			        },

  			        decryptBlock: function (M, offset) {
  			            // Swap 2nd and 4th rows
  			            var t = M[offset + 1];
  			            M[offset + 1] = M[offset + 3];
  			            M[offset + 3] = t;

  			            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

  			            // Inv swap 2nd and 4th rows
  			            var t = M[offset + 1];
  			            M[offset + 1] = M[offset + 3];
  			            M[offset + 3] = t;
  			        },

  			        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
  			            // Shortcut
  			            var nRounds = this._nRounds;

  			            // Get input, add round key
  			            var s0 = M[offset]     ^ keySchedule[0];
  			            var s1 = M[offset + 1] ^ keySchedule[1];
  			            var s2 = M[offset + 2] ^ keySchedule[2];
  			            var s3 = M[offset + 3] ^ keySchedule[3];

  			            // Key schedule row counter
  			            var ksRow = 4;

  			            // Rounds
  			            for (var round = 1; round < nRounds; round++) {
  			                // Shift rows, sub bytes, mix columns, add round key
  			                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
  			                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
  			                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
  			                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

  			                // Update state
  			                s0 = t0;
  			                s1 = t1;
  			                s2 = t2;
  			                s3 = t3;
  			            }

  			            // Shift rows, sub bytes, add round key
  			            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
  			            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
  			            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
  			            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

  			            // Set output
  			            M[offset]     = t0;
  			            M[offset + 1] = t1;
  			            M[offset + 2] = t2;
  			            M[offset + 3] = t3;
  			        },

  			        keySize: 256/32
  			    });

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
  			     */
  			    C.AES = BlockCipher._createHelper(AES);
  			}());


  			return CryptoJS.AES;

  		})); 
  	} (aes));
  	return aes.exports;
  }

  var tripledes = {exports: {}};

  var hasRequiredTripledes;

  function requireTripledes () {
  	if (hasRequiredTripledes) return tripledes.exports;
  	hasRequiredTripledes = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var WordArray = C_lib.WordArray;
  			    var BlockCipher = C_lib.BlockCipher;
  			    var C_algo = C.algo;

  			    // Permuted Choice 1 constants
  			    var PC1 = [
  			        57, 49, 41, 33, 25, 17, 9,  1,
  			        58, 50, 42, 34, 26, 18, 10, 2,
  			        59, 51, 43, 35, 27, 19, 11, 3,
  			        60, 52, 44, 36, 63, 55, 47, 39,
  			        31, 23, 15, 7,  62, 54, 46, 38,
  			        30, 22, 14, 6,  61, 53, 45, 37,
  			        29, 21, 13, 5,  28, 20, 12, 4
  			    ];

  			    // Permuted Choice 2 constants
  			    var PC2 = [
  			        14, 17, 11, 24, 1,  5,
  			        3,  28, 15, 6,  21, 10,
  			        23, 19, 12, 4,  26, 8,
  			        16, 7,  27, 20, 13, 2,
  			        41, 52, 31, 37, 47, 55,
  			        30, 40, 51, 45, 33, 48,
  			        44, 49, 39, 56, 34, 53,
  			        46, 42, 50, 36, 29, 32
  			    ];

  			    // Cumulative bit shift constants
  			    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

  			    // SBOXes and round permutation constants
  			    var SBOX_P = [
  			        {
  			            0x0: 0x808200,
  			            0x10000000: 0x8000,
  			            0x20000000: 0x808002,
  			            0x30000000: 0x2,
  			            0x40000000: 0x200,
  			            0x50000000: 0x808202,
  			            0x60000000: 0x800202,
  			            0x70000000: 0x800000,
  			            0x80000000: 0x202,
  			            0x90000000: 0x800200,
  			            0xa0000000: 0x8200,
  			            0xb0000000: 0x808000,
  			            0xc0000000: 0x8002,
  			            0xd0000000: 0x800002,
  			            0xe0000000: 0x0,
  			            0xf0000000: 0x8202,
  			            0x8000000: 0x0,
  			            0x18000000: 0x808202,
  			            0x28000000: 0x8202,
  			            0x38000000: 0x8000,
  			            0x48000000: 0x808200,
  			            0x58000000: 0x200,
  			            0x68000000: 0x808002,
  			            0x78000000: 0x2,
  			            0x88000000: 0x800200,
  			            0x98000000: 0x8200,
  			            0xa8000000: 0x808000,
  			            0xb8000000: 0x800202,
  			            0xc8000000: 0x800002,
  			            0xd8000000: 0x8002,
  			            0xe8000000: 0x202,
  			            0xf8000000: 0x800000,
  			            0x1: 0x8000,
  			            0x10000001: 0x2,
  			            0x20000001: 0x808200,
  			            0x30000001: 0x800000,
  			            0x40000001: 0x808002,
  			            0x50000001: 0x8200,
  			            0x60000001: 0x200,
  			            0x70000001: 0x800202,
  			            0x80000001: 0x808202,
  			            0x90000001: 0x808000,
  			            0xa0000001: 0x800002,
  			            0xb0000001: 0x8202,
  			            0xc0000001: 0x202,
  			            0xd0000001: 0x800200,
  			            0xe0000001: 0x8002,
  			            0xf0000001: 0x0,
  			            0x8000001: 0x808202,
  			            0x18000001: 0x808000,
  			            0x28000001: 0x800000,
  			            0x38000001: 0x200,
  			            0x48000001: 0x8000,
  			            0x58000001: 0x800002,
  			            0x68000001: 0x2,
  			            0x78000001: 0x8202,
  			            0x88000001: 0x8002,
  			            0x98000001: 0x800202,
  			            0xa8000001: 0x202,
  			            0xb8000001: 0x808200,
  			            0xc8000001: 0x800200,
  			            0xd8000001: 0x0,
  			            0xe8000001: 0x8200,
  			            0xf8000001: 0x808002
  			        },
  			        {
  			            0x0: 0x40084010,
  			            0x1000000: 0x4000,
  			            0x2000000: 0x80000,
  			            0x3000000: 0x40080010,
  			            0x4000000: 0x40000010,
  			            0x5000000: 0x40084000,
  			            0x6000000: 0x40004000,
  			            0x7000000: 0x10,
  			            0x8000000: 0x84000,
  			            0x9000000: 0x40004010,
  			            0xa000000: 0x40000000,
  			            0xb000000: 0x84010,
  			            0xc000000: 0x80010,
  			            0xd000000: 0x0,
  			            0xe000000: 0x4010,
  			            0xf000000: 0x40080000,
  			            0x800000: 0x40004000,
  			            0x1800000: 0x84010,
  			            0x2800000: 0x10,
  			            0x3800000: 0x40004010,
  			            0x4800000: 0x40084010,
  			            0x5800000: 0x40000000,
  			            0x6800000: 0x80000,
  			            0x7800000: 0x40080010,
  			            0x8800000: 0x80010,
  			            0x9800000: 0x0,
  			            0xa800000: 0x4000,
  			            0xb800000: 0x40080000,
  			            0xc800000: 0x40000010,
  			            0xd800000: 0x84000,
  			            0xe800000: 0x40084000,
  			            0xf800000: 0x4010,
  			            0x10000000: 0x0,
  			            0x11000000: 0x40080010,
  			            0x12000000: 0x40004010,
  			            0x13000000: 0x40084000,
  			            0x14000000: 0x40080000,
  			            0x15000000: 0x10,
  			            0x16000000: 0x84010,
  			            0x17000000: 0x4000,
  			            0x18000000: 0x4010,
  			            0x19000000: 0x80000,
  			            0x1a000000: 0x80010,
  			            0x1b000000: 0x40000010,
  			            0x1c000000: 0x84000,
  			            0x1d000000: 0x40004000,
  			            0x1e000000: 0x40000000,
  			            0x1f000000: 0x40084010,
  			            0x10800000: 0x84010,
  			            0x11800000: 0x80000,
  			            0x12800000: 0x40080000,
  			            0x13800000: 0x4000,
  			            0x14800000: 0x40004000,
  			            0x15800000: 0x40084010,
  			            0x16800000: 0x10,
  			            0x17800000: 0x40000000,
  			            0x18800000: 0x40084000,
  			            0x19800000: 0x40000010,
  			            0x1a800000: 0x40004010,
  			            0x1b800000: 0x80010,
  			            0x1c800000: 0x0,
  			            0x1d800000: 0x4010,
  			            0x1e800000: 0x40080010,
  			            0x1f800000: 0x84000
  			        },
  			        {
  			            0x0: 0x104,
  			            0x100000: 0x0,
  			            0x200000: 0x4000100,
  			            0x300000: 0x10104,
  			            0x400000: 0x10004,
  			            0x500000: 0x4000004,
  			            0x600000: 0x4010104,
  			            0x700000: 0x4010000,
  			            0x800000: 0x4000000,
  			            0x900000: 0x4010100,
  			            0xa00000: 0x10100,
  			            0xb00000: 0x4010004,
  			            0xc00000: 0x4000104,
  			            0xd00000: 0x10000,
  			            0xe00000: 0x4,
  			            0xf00000: 0x100,
  			            0x80000: 0x4010100,
  			            0x180000: 0x4010004,
  			            0x280000: 0x0,
  			            0x380000: 0x4000100,
  			            0x480000: 0x4000004,
  			            0x580000: 0x10000,
  			            0x680000: 0x10004,
  			            0x780000: 0x104,
  			            0x880000: 0x4,
  			            0x980000: 0x100,
  			            0xa80000: 0x4010000,
  			            0xb80000: 0x10104,
  			            0xc80000: 0x10100,
  			            0xd80000: 0x4000104,
  			            0xe80000: 0x4010104,
  			            0xf80000: 0x4000000,
  			            0x1000000: 0x4010100,
  			            0x1100000: 0x10004,
  			            0x1200000: 0x10000,
  			            0x1300000: 0x4000100,
  			            0x1400000: 0x100,
  			            0x1500000: 0x4010104,
  			            0x1600000: 0x4000004,
  			            0x1700000: 0x0,
  			            0x1800000: 0x4000104,
  			            0x1900000: 0x4000000,
  			            0x1a00000: 0x4,
  			            0x1b00000: 0x10100,
  			            0x1c00000: 0x4010000,
  			            0x1d00000: 0x104,
  			            0x1e00000: 0x10104,
  			            0x1f00000: 0x4010004,
  			            0x1080000: 0x4000000,
  			            0x1180000: 0x104,
  			            0x1280000: 0x4010100,
  			            0x1380000: 0x0,
  			            0x1480000: 0x10004,
  			            0x1580000: 0x4000100,
  			            0x1680000: 0x100,
  			            0x1780000: 0x4010004,
  			            0x1880000: 0x10000,
  			            0x1980000: 0x4010104,
  			            0x1a80000: 0x10104,
  			            0x1b80000: 0x4000004,
  			            0x1c80000: 0x4000104,
  			            0x1d80000: 0x4010000,
  			            0x1e80000: 0x4,
  			            0x1f80000: 0x10100
  			        },
  			        {
  			            0x0: 0x80401000,
  			            0x10000: 0x80001040,
  			            0x20000: 0x401040,
  			            0x30000: 0x80400000,
  			            0x40000: 0x0,
  			            0x50000: 0x401000,
  			            0x60000: 0x80000040,
  			            0x70000: 0x400040,
  			            0x80000: 0x80000000,
  			            0x90000: 0x400000,
  			            0xa0000: 0x40,
  			            0xb0000: 0x80001000,
  			            0xc0000: 0x80400040,
  			            0xd0000: 0x1040,
  			            0xe0000: 0x1000,
  			            0xf0000: 0x80401040,
  			            0x8000: 0x80001040,
  			            0x18000: 0x40,
  			            0x28000: 0x80400040,
  			            0x38000: 0x80001000,
  			            0x48000: 0x401000,
  			            0x58000: 0x80401040,
  			            0x68000: 0x0,
  			            0x78000: 0x80400000,
  			            0x88000: 0x1000,
  			            0x98000: 0x80401000,
  			            0xa8000: 0x400000,
  			            0xb8000: 0x1040,
  			            0xc8000: 0x80000000,
  			            0xd8000: 0x400040,
  			            0xe8000: 0x401040,
  			            0xf8000: 0x80000040,
  			            0x100000: 0x400040,
  			            0x110000: 0x401000,
  			            0x120000: 0x80000040,
  			            0x130000: 0x0,
  			            0x140000: 0x1040,
  			            0x150000: 0x80400040,
  			            0x160000: 0x80401000,
  			            0x170000: 0x80001040,
  			            0x180000: 0x80401040,
  			            0x190000: 0x80000000,
  			            0x1a0000: 0x80400000,
  			            0x1b0000: 0x401040,
  			            0x1c0000: 0x80001000,
  			            0x1d0000: 0x400000,
  			            0x1e0000: 0x40,
  			            0x1f0000: 0x1000,
  			            0x108000: 0x80400000,
  			            0x118000: 0x80401040,
  			            0x128000: 0x0,
  			            0x138000: 0x401000,
  			            0x148000: 0x400040,
  			            0x158000: 0x80000000,
  			            0x168000: 0x80001040,
  			            0x178000: 0x40,
  			            0x188000: 0x80000040,
  			            0x198000: 0x1000,
  			            0x1a8000: 0x80001000,
  			            0x1b8000: 0x80400040,
  			            0x1c8000: 0x1040,
  			            0x1d8000: 0x80401000,
  			            0x1e8000: 0x400000,
  			            0x1f8000: 0x401040
  			        },
  			        {
  			            0x0: 0x80,
  			            0x1000: 0x1040000,
  			            0x2000: 0x40000,
  			            0x3000: 0x20000000,
  			            0x4000: 0x20040080,
  			            0x5000: 0x1000080,
  			            0x6000: 0x21000080,
  			            0x7000: 0x40080,
  			            0x8000: 0x1000000,
  			            0x9000: 0x20040000,
  			            0xa000: 0x20000080,
  			            0xb000: 0x21040080,
  			            0xc000: 0x21040000,
  			            0xd000: 0x0,
  			            0xe000: 0x1040080,
  			            0xf000: 0x21000000,
  			            0x800: 0x1040080,
  			            0x1800: 0x21000080,
  			            0x2800: 0x80,
  			            0x3800: 0x1040000,
  			            0x4800: 0x40000,
  			            0x5800: 0x20040080,
  			            0x6800: 0x21040000,
  			            0x7800: 0x20000000,
  			            0x8800: 0x20040000,
  			            0x9800: 0x0,
  			            0xa800: 0x21040080,
  			            0xb800: 0x1000080,
  			            0xc800: 0x20000080,
  			            0xd800: 0x21000000,
  			            0xe800: 0x1000000,
  			            0xf800: 0x40080,
  			            0x10000: 0x40000,
  			            0x11000: 0x80,
  			            0x12000: 0x20000000,
  			            0x13000: 0x21000080,
  			            0x14000: 0x1000080,
  			            0x15000: 0x21040000,
  			            0x16000: 0x20040080,
  			            0x17000: 0x1000000,
  			            0x18000: 0x21040080,
  			            0x19000: 0x21000000,
  			            0x1a000: 0x1040000,
  			            0x1b000: 0x20040000,
  			            0x1c000: 0x40080,
  			            0x1d000: 0x20000080,
  			            0x1e000: 0x0,
  			            0x1f000: 0x1040080,
  			            0x10800: 0x21000080,
  			            0x11800: 0x1000000,
  			            0x12800: 0x1040000,
  			            0x13800: 0x20040080,
  			            0x14800: 0x20000000,
  			            0x15800: 0x1040080,
  			            0x16800: 0x80,
  			            0x17800: 0x21040000,
  			            0x18800: 0x40080,
  			            0x19800: 0x21040080,
  			            0x1a800: 0x0,
  			            0x1b800: 0x21000000,
  			            0x1c800: 0x1000080,
  			            0x1d800: 0x40000,
  			            0x1e800: 0x20040000,
  			            0x1f800: 0x20000080
  			        },
  			        {
  			            0x0: 0x10000008,
  			            0x100: 0x2000,
  			            0x200: 0x10200000,
  			            0x300: 0x10202008,
  			            0x400: 0x10002000,
  			            0x500: 0x200000,
  			            0x600: 0x200008,
  			            0x700: 0x10000000,
  			            0x800: 0x0,
  			            0x900: 0x10002008,
  			            0xa00: 0x202000,
  			            0xb00: 0x8,
  			            0xc00: 0x10200008,
  			            0xd00: 0x202008,
  			            0xe00: 0x2008,
  			            0xf00: 0x10202000,
  			            0x80: 0x10200000,
  			            0x180: 0x10202008,
  			            0x280: 0x8,
  			            0x380: 0x200000,
  			            0x480: 0x202008,
  			            0x580: 0x10000008,
  			            0x680: 0x10002000,
  			            0x780: 0x2008,
  			            0x880: 0x200008,
  			            0x980: 0x2000,
  			            0xa80: 0x10002008,
  			            0xb80: 0x10200008,
  			            0xc80: 0x0,
  			            0xd80: 0x10202000,
  			            0xe80: 0x202000,
  			            0xf80: 0x10000000,
  			            0x1000: 0x10002000,
  			            0x1100: 0x10200008,
  			            0x1200: 0x10202008,
  			            0x1300: 0x2008,
  			            0x1400: 0x200000,
  			            0x1500: 0x10000000,
  			            0x1600: 0x10000008,
  			            0x1700: 0x202000,
  			            0x1800: 0x202008,
  			            0x1900: 0x0,
  			            0x1a00: 0x8,
  			            0x1b00: 0x10200000,
  			            0x1c00: 0x2000,
  			            0x1d00: 0x10002008,
  			            0x1e00: 0x10202000,
  			            0x1f00: 0x200008,
  			            0x1080: 0x8,
  			            0x1180: 0x202000,
  			            0x1280: 0x200000,
  			            0x1380: 0x10000008,
  			            0x1480: 0x10002000,
  			            0x1580: 0x2008,
  			            0x1680: 0x10202008,
  			            0x1780: 0x10200000,
  			            0x1880: 0x10202000,
  			            0x1980: 0x10200008,
  			            0x1a80: 0x2000,
  			            0x1b80: 0x202008,
  			            0x1c80: 0x200008,
  			            0x1d80: 0x0,
  			            0x1e80: 0x10000000,
  			            0x1f80: 0x10002008
  			        },
  			        {
  			            0x0: 0x100000,
  			            0x10: 0x2000401,
  			            0x20: 0x400,
  			            0x30: 0x100401,
  			            0x40: 0x2100401,
  			            0x50: 0x0,
  			            0x60: 0x1,
  			            0x70: 0x2100001,
  			            0x80: 0x2000400,
  			            0x90: 0x100001,
  			            0xa0: 0x2000001,
  			            0xb0: 0x2100400,
  			            0xc0: 0x2100000,
  			            0xd0: 0x401,
  			            0xe0: 0x100400,
  			            0xf0: 0x2000000,
  			            0x8: 0x2100001,
  			            0x18: 0x0,
  			            0x28: 0x2000401,
  			            0x38: 0x2100400,
  			            0x48: 0x100000,
  			            0x58: 0x2000001,
  			            0x68: 0x2000000,
  			            0x78: 0x401,
  			            0x88: 0x100401,
  			            0x98: 0x2000400,
  			            0xa8: 0x2100000,
  			            0xb8: 0x100001,
  			            0xc8: 0x400,
  			            0xd8: 0x2100401,
  			            0xe8: 0x1,
  			            0xf8: 0x100400,
  			            0x100: 0x2000000,
  			            0x110: 0x100000,
  			            0x120: 0x2000401,
  			            0x130: 0x2100001,
  			            0x140: 0x100001,
  			            0x150: 0x2000400,
  			            0x160: 0x2100400,
  			            0x170: 0x100401,
  			            0x180: 0x401,
  			            0x190: 0x2100401,
  			            0x1a0: 0x100400,
  			            0x1b0: 0x1,
  			            0x1c0: 0x0,
  			            0x1d0: 0x2100000,
  			            0x1e0: 0x2000001,
  			            0x1f0: 0x400,
  			            0x108: 0x100400,
  			            0x118: 0x2000401,
  			            0x128: 0x2100001,
  			            0x138: 0x1,
  			            0x148: 0x2000000,
  			            0x158: 0x100000,
  			            0x168: 0x401,
  			            0x178: 0x2100400,
  			            0x188: 0x2000001,
  			            0x198: 0x2100000,
  			            0x1a8: 0x0,
  			            0x1b8: 0x2100401,
  			            0x1c8: 0x100401,
  			            0x1d8: 0x400,
  			            0x1e8: 0x2000400,
  			            0x1f8: 0x100001
  			        },
  			        {
  			            0x0: 0x8000820,
  			            0x1: 0x20000,
  			            0x2: 0x8000000,
  			            0x3: 0x20,
  			            0x4: 0x20020,
  			            0x5: 0x8020820,
  			            0x6: 0x8020800,
  			            0x7: 0x800,
  			            0x8: 0x8020000,
  			            0x9: 0x8000800,
  			            0xa: 0x20800,
  			            0xb: 0x8020020,
  			            0xc: 0x820,
  			            0xd: 0x0,
  			            0xe: 0x8000020,
  			            0xf: 0x20820,
  			            0x80000000: 0x800,
  			            0x80000001: 0x8020820,
  			            0x80000002: 0x8000820,
  			            0x80000003: 0x8000000,
  			            0x80000004: 0x8020000,
  			            0x80000005: 0x20800,
  			            0x80000006: 0x20820,
  			            0x80000007: 0x20,
  			            0x80000008: 0x8000020,
  			            0x80000009: 0x820,
  			            0x8000000a: 0x20020,
  			            0x8000000b: 0x8020800,
  			            0x8000000c: 0x0,
  			            0x8000000d: 0x8020020,
  			            0x8000000e: 0x8000800,
  			            0x8000000f: 0x20000,
  			            0x10: 0x20820,
  			            0x11: 0x8020800,
  			            0x12: 0x20,
  			            0x13: 0x800,
  			            0x14: 0x8000800,
  			            0x15: 0x8000020,
  			            0x16: 0x8020020,
  			            0x17: 0x20000,
  			            0x18: 0x0,
  			            0x19: 0x20020,
  			            0x1a: 0x8020000,
  			            0x1b: 0x8000820,
  			            0x1c: 0x8020820,
  			            0x1d: 0x20800,
  			            0x1e: 0x820,
  			            0x1f: 0x8000000,
  			            0x80000010: 0x20000,
  			            0x80000011: 0x800,
  			            0x80000012: 0x8020020,
  			            0x80000013: 0x20820,
  			            0x80000014: 0x20,
  			            0x80000015: 0x8020000,
  			            0x80000016: 0x8000000,
  			            0x80000017: 0x8000820,
  			            0x80000018: 0x8020820,
  			            0x80000019: 0x8000020,
  			            0x8000001a: 0x8000800,
  			            0x8000001b: 0x0,
  			            0x8000001c: 0x20800,
  			            0x8000001d: 0x820,
  			            0x8000001e: 0x20020,
  			            0x8000001f: 0x8020800
  			        }
  			    ];

  			    // Masks that select the SBOX input
  			    var SBOX_MASK = [
  			        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
  			        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
  			    ];

  			    /**
  			     * DES block cipher algorithm.
  			     */
  			    var DES = C_algo.DES = BlockCipher.extend({
  			        _doReset: function () {
  			            // Shortcuts
  			            var key = this._key;
  			            var keyWords = key.words;

  			            // Select 56 bits according to PC1
  			            var keyBits = [];
  			            for (var i = 0; i < 56; i++) {
  			                var keyBitPos = PC1[i] - 1;
  			                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
  			            }

  			            // Assemble 16 subkeys
  			            var subKeys = this._subKeys = [];
  			            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
  			                // Create subkey
  			                var subKey = subKeys[nSubKey] = [];

  			                // Shortcut
  			                var bitShift = BIT_SHIFTS[nSubKey];

  			                // Select 48 bits according to PC2
  			                for (var i = 0; i < 24; i++) {
  			                    // Select from the left 28 key bits
  			                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

  			                    // Select from the right 28 key bits
  			                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
  			                }

  			                // Since each subkey is applied to an expanded 32-bit input,
  			                // the subkey can be broken into 8 values scaled to 32-bits,
  			                // which allows the key to be used without expansion
  			                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
  			                for (var i = 1; i < 7; i++) {
  			                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
  			                }
  			                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
  			            }

  			            // Compute inverse subkeys
  			            var invSubKeys = this._invSubKeys = [];
  			            for (var i = 0; i < 16; i++) {
  			                invSubKeys[i] = subKeys[15 - i];
  			            }
  			        },

  			        encryptBlock: function (M, offset) {
  			            this._doCryptBlock(M, offset, this._subKeys);
  			        },

  			        decryptBlock: function (M, offset) {
  			            this._doCryptBlock(M, offset, this._invSubKeys);
  			        },

  			        _doCryptBlock: function (M, offset, subKeys) {
  			            // Get input
  			            this._lBlock = M[offset];
  			            this._rBlock = M[offset + 1];

  			            // Initial permutation
  			            exchangeLR.call(this, 4,  0x0f0f0f0f);
  			            exchangeLR.call(this, 16, 0x0000ffff);
  			            exchangeRL.call(this, 2,  0x33333333);
  			            exchangeRL.call(this, 8,  0x00ff00ff);
  			            exchangeLR.call(this, 1,  0x55555555);

  			            // Rounds
  			            for (var round = 0; round < 16; round++) {
  			                // Shortcuts
  			                var subKey = subKeys[round];
  			                var lBlock = this._lBlock;
  			                var rBlock = this._rBlock;

  			                // Feistel function
  			                var f = 0;
  			                for (var i = 0; i < 8; i++) {
  			                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
  			                }
  			                this._lBlock = rBlock;
  			                this._rBlock = lBlock ^ f;
  			            }

  			            // Undo swap from last round
  			            var t = this._lBlock;
  			            this._lBlock = this._rBlock;
  			            this._rBlock = t;

  			            // Final permutation
  			            exchangeLR.call(this, 1,  0x55555555);
  			            exchangeRL.call(this, 8,  0x00ff00ff);
  			            exchangeRL.call(this, 2,  0x33333333);
  			            exchangeLR.call(this, 16, 0x0000ffff);
  			            exchangeLR.call(this, 4,  0x0f0f0f0f);

  			            // Set output
  			            M[offset] = this._lBlock;
  			            M[offset + 1] = this._rBlock;
  			        },

  			        keySize: 64/32,

  			        ivSize: 64/32,

  			        blockSize: 64/32
  			    });

  			    // Swap bits across the left and right words
  			    function exchangeLR(offset, mask) {
  			        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
  			        this._rBlock ^= t;
  			        this._lBlock ^= t << offset;
  			    }

  			    function exchangeRL(offset, mask) {
  			        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
  			        this._lBlock ^= t;
  			        this._rBlock ^= t << offset;
  			    }

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
  			     */
  			    C.DES = BlockCipher._createHelper(DES);

  			    /**
  			     * Triple-DES block cipher algorithm.
  			     */
  			    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
  			        _doReset: function () {
  			            // Shortcuts
  			            var key = this._key;
  			            var keyWords = key.words;
  			            // Make sure the key length is valid (64, 128 or >= 192 bit)
  			            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
  			                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
  			            }

  			            // Extend the key according to the keying options defined in 3DES standard
  			            var key1 = keyWords.slice(0, 2);
  			            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
  			            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);

  			            // Create DES instances
  			            this._des1 = DES.createEncryptor(WordArray.create(key1));
  			            this._des2 = DES.createEncryptor(WordArray.create(key2));
  			            this._des3 = DES.createEncryptor(WordArray.create(key3));
  			        },

  			        encryptBlock: function (M, offset) {
  			            this._des1.encryptBlock(M, offset);
  			            this._des2.decryptBlock(M, offset);
  			            this._des3.encryptBlock(M, offset);
  			        },

  			        decryptBlock: function (M, offset) {
  			            this._des3.decryptBlock(M, offset);
  			            this._des2.encryptBlock(M, offset);
  			            this._des1.decryptBlock(M, offset);
  			        },

  			        keySize: 192/32,

  			        ivSize: 64/32,

  			        blockSize: 64/32
  			    });

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
  			     */
  			    C.TripleDES = BlockCipher._createHelper(TripleDES);
  			}());


  			return CryptoJS.TripleDES;

  		})); 
  	} (tripledes));
  	return tripledes.exports;
  }

  var rc4 = {exports: {}};

  var hasRequiredRc4;

  function requireRc4 () {
  	if (hasRequiredRc4) return rc4.exports;
  	hasRequiredRc4 = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var StreamCipher = C_lib.StreamCipher;
  			    var C_algo = C.algo;

  			    /**
  			     * RC4 stream cipher algorithm.
  			     */
  			    var RC4 = C_algo.RC4 = StreamCipher.extend({
  			        _doReset: function () {
  			            // Shortcuts
  			            var key = this._key;
  			            var keyWords = key.words;
  			            var keySigBytes = key.sigBytes;

  			            // Init sbox
  			            var S = this._S = [];
  			            for (var i = 0; i < 256; i++) {
  			                S[i] = i;
  			            }

  			            // Key setup
  			            for (var i = 0, j = 0; i < 256; i++) {
  			                var keyByteIndex = i % keySigBytes;
  			                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

  			                j = (j + S[i] + keyByte) % 256;

  			                // Swap
  			                var t = S[i];
  			                S[i] = S[j];
  			                S[j] = t;
  			            }

  			            // Counters
  			            this._i = this._j = 0;
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            M[offset] ^= generateKeystreamWord.call(this);
  			        },

  			        keySize: 256/32,

  			        ivSize: 0
  			    });

  			    function generateKeystreamWord() {
  			        // Shortcuts
  			        var S = this._S;
  			        var i = this._i;
  			        var j = this._j;

  			        // Generate keystream word
  			        var keystreamWord = 0;
  			        for (var n = 0; n < 4; n++) {
  			            i = (i + 1) % 256;
  			            j = (j + S[i]) % 256;

  			            // Swap
  			            var t = S[i];
  			            S[i] = S[j];
  			            S[j] = t;

  			            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
  			        }

  			        // Update counters
  			        this._i = i;
  			        this._j = j;

  			        return keystreamWord;
  			    }

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
  			     */
  			    C.RC4 = StreamCipher._createHelper(RC4);

  			    /**
  			     * Modified RC4 stream cipher algorithm.
  			     */
  			    var RC4Drop = C_algo.RC4Drop = RC4.extend({
  			        /**
  			         * Configuration options.
  			         *
  			         * @property {number} drop The number of keystream words to drop. Default 192
  			         */
  			        cfg: RC4.cfg.extend({
  			            drop: 192
  			        }),

  			        _doReset: function () {
  			            RC4._doReset.call(this);

  			            // Drop
  			            for (var i = this.cfg.drop; i > 0; i--) {
  			                generateKeystreamWord.call(this);
  			            }
  			        }
  			    });

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
  			     */
  			    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
  			}());


  			return CryptoJS.RC4;

  		})); 
  	} (rc4));
  	return rc4.exports;
  }

  var rabbit = {exports: {}};

  var hasRequiredRabbit;

  function requireRabbit () {
  	if (hasRequiredRabbit) return rabbit.exports;
  	hasRequiredRabbit = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var StreamCipher = C_lib.StreamCipher;
  			    var C_algo = C.algo;

  			    // Reusable objects
  			    var S  = [];
  			    var C_ = [];
  			    var G  = [];

  			    /**
  			     * Rabbit stream cipher algorithm
  			     */
  			    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
  			        _doReset: function () {
  			            // Shortcuts
  			            var K = this._key.words;
  			            var iv = this.cfg.iv;

  			            // Swap endian
  			            for (var i = 0; i < 4; i++) {
  			                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
  			                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
  			            }

  			            // Generate initial state values
  			            var X = this._X = [
  			                K[0], (K[3] << 16) | (K[2] >>> 16),
  			                K[1], (K[0] << 16) | (K[3] >>> 16),
  			                K[2], (K[1] << 16) | (K[0] >>> 16),
  			                K[3], (K[2] << 16) | (K[1] >>> 16)
  			            ];

  			            // Generate initial counter values
  			            var C = this._C = [
  			                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
  			                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
  			                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
  			                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
  			            ];

  			            // Carry bit
  			            this._b = 0;

  			            // Iterate the system four times
  			            for (var i = 0; i < 4; i++) {
  			                nextState.call(this);
  			            }

  			            // Modify the counters
  			            for (var i = 0; i < 8; i++) {
  			                C[i] ^= X[(i + 4) & 7];
  			            }

  			            // IV setup
  			            if (iv) {
  			                // Shortcuts
  			                var IV = iv.words;
  			                var IV_0 = IV[0];
  			                var IV_1 = IV[1];

  			                // Generate four subvectors
  			                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
  			                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
  			                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
  			                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

  			                // Modify counter values
  			                C[0] ^= i0;
  			                C[1] ^= i1;
  			                C[2] ^= i2;
  			                C[3] ^= i3;
  			                C[4] ^= i0;
  			                C[5] ^= i1;
  			                C[6] ^= i2;
  			                C[7] ^= i3;

  			                // Iterate the system four times
  			                for (var i = 0; i < 4; i++) {
  			                    nextState.call(this);
  			                }
  			            }
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcut
  			            var X = this._X;

  			            // Iterate the system
  			            nextState.call(this);

  			            // Generate four keystream words
  			            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
  			            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
  			            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
  			            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

  			            for (var i = 0; i < 4; i++) {
  			                // Swap endian
  			                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
  			                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

  			                // Encrypt
  			                M[offset + i] ^= S[i];
  			            }
  			        },

  			        blockSize: 128/32,

  			        ivSize: 64/32
  			    });

  			    function nextState() {
  			        // Shortcuts
  			        var X = this._X;
  			        var C = this._C;

  			        // Save old counter values
  			        for (var i = 0; i < 8; i++) {
  			            C_[i] = C[i];
  			        }

  			        // Calculate new counter values
  			        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
  			        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
  			        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
  			        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
  			        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
  			        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
  			        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
  			        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
  			        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

  			        // Calculate the g-values
  			        for (var i = 0; i < 8; i++) {
  			            var gx = X[i] + C[i];

  			            // Construct high and low argument for squaring
  			            var ga = gx & 0xffff;
  			            var gb = gx >>> 16;

  			            // Calculate high and low result of squaring
  			            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
  			            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

  			            // High XOR low
  			            G[i] = gh ^ gl;
  			        }

  			        // Calculate new state values
  			        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
  			        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
  			        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
  			        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
  			        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
  			        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
  			        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
  			        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
  			    }

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
  			     */
  			    C.Rabbit = StreamCipher._createHelper(Rabbit);
  			}());


  			return CryptoJS.Rabbit;

  		})); 
  	} (rabbit));
  	return rabbit.exports;
  }

  var rabbitLegacy = {exports: {}};

  var hasRequiredRabbitLegacy;

  function requireRabbitLegacy () {
  	if (hasRequiredRabbitLegacy) return rabbitLegacy.exports;
  	hasRequiredRabbitLegacy = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var StreamCipher = C_lib.StreamCipher;
  			    var C_algo = C.algo;

  			    // Reusable objects
  			    var S  = [];
  			    var C_ = [];
  			    var G  = [];

  			    /**
  			     * Rabbit stream cipher algorithm.
  			     *
  			     * This is a legacy version that neglected to convert the key to little-endian.
  			     * This error doesn't affect the cipher's security,
  			     * but it does affect its compatibility with other implementations.
  			     */
  			    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
  			        _doReset: function () {
  			            // Shortcuts
  			            var K = this._key.words;
  			            var iv = this.cfg.iv;

  			            // Generate initial state values
  			            var X = this._X = [
  			                K[0], (K[3] << 16) | (K[2] >>> 16),
  			                K[1], (K[0] << 16) | (K[3] >>> 16),
  			                K[2], (K[1] << 16) | (K[0] >>> 16),
  			                K[3], (K[2] << 16) | (K[1] >>> 16)
  			            ];

  			            // Generate initial counter values
  			            var C = this._C = [
  			                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
  			                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
  			                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
  			                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
  			            ];

  			            // Carry bit
  			            this._b = 0;

  			            // Iterate the system four times
  			            for (var i = 0; i < 4; i++) {
  			                nextState.call(this);
  			            }

  			            // Modify the counters
  			            for (var i = 0; i < 8; i++) {
  			                C[i] ^= X[(i + 4) & 7];
  			            }

  			            // IV setup
  			            if (iv) {
  			                // Shortcuts
  			                var IV = iv.words;
  			                var IV_0 = IV[0];
  			                var IV_1 = IV[1];

  			                // Generate four subvectors
  			                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
  			                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
  			                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
  			                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

  			                // Modify counter values
  			                C[0] ^= i0;
  			                C[1] ^= i1;
  			                C[2] ^= i2;
  			                C[3] ^= i3;
  			                C[4] ^= i0;
  			                C[5] ^= i1;
  			                C[6] ^= i2;
  			                C[7] ^= i3;

  			                // Iterate the system four times
  			                for (var i = 0; i < 4; i++) {
  			                    nextState.call(this);
  			                }
  			            }
  			        },

  			        _doProcessBlock: function (M, offset) {
  			            // Shortcut
  			            var X = this._X;

  			            // Iterate the system
  			            nextState.call(this);

  			            // Generate four keystream words
  			            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
  			            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
  			            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
  			            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

  			            for (var i = 0; i < 4; i++) {
  			                // Swap endian
  			                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
  			                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

  			                // Encrypt
  			                M[offset + i] ^= S[i];
  			            }
  			        },

  			        blockSize: 128/32,

  			        ivSize: 64/32
  			    });

  			    function nextState() {
  			        // Shortcuts
  			        var X = this._X;
  			        var C = this._C;

  			        // Save old counter values
  			        for (var i = 0; i < 8; i++) {
  			            C_[i] = C[i];
  			        }

  			        // Calculate new counter values
  			        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
  			        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
  			        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
  			        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
  			        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
  			        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
  			        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
  			        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
  			        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

  			        // Calculate the g-values
  			        for (var i = 0; i < 8; i++) {
  			            var gx = X[i] + C[i];

  			            // Construct high and low argument for squaring
  			            var ga = gx & 0xffff;
  			            var gb = gx >>> 16;

  			            // Calculate high and low result of squaring
  			            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
  			            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

  			            // High XOR low
  			            G[i] = gh ^ gl;
  			        }

  			        // Calculate new state values
  			        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
  			        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
  			        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
  			        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
  			        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
  			        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
  			        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
  			        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
  			    }

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
  			     */
  			    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
  			}());


  			return CryptoJS.RabbitLegacy;

  		})); 
  	} (rabbitLegacy));
  	return rabbitLegacy.exports;
  }

  var blowfish = {exports: {}};

  var hasRequiredBlowfish;

  function requireBlowfish () {
  	if (hasRequiredBlowfish) return blowfish.exports;
  	hasRequiredBlowfish = 1;
  	(function (module, exports) {
  (function (root, factory, undef) {
  			{
  				// CommonJS
  				module.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
  			}
  		}(commonjsGlobal, function (CryptoJS) {

  			(function () {
  			    // Shortcuts
  			    var C = CryptoJS;
  			    var C_lib = C.lib;
  			    var BlockCipher = C_lib.BlockCipher;
  			    var C_algo = C.algo;

  			    const N = 16;

  			    //Origin pbox and sbox, derived from PI
  			    const ORIG_P = [
  			        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,
  			        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
  			        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,
  			        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
  			        0x9216D5D9, 0x8979FB1B
  			    ];

  			    const ORIG_S = [
  			        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,
  			            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,
  			            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,
  			            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,
  			            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,
  			            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,
  			            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,
  			            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,
  			            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,
  			            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,
  			            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,
  			            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,
  			            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,
  			            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,
  			            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,
  			            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,
  			            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,
  			            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,
  			            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,
  			            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,
  			            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,
  			            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,
  			            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,
  			            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,
  			            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,
  			            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,
  			            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,
  			            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,
  			            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,
  			            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,
  			            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,
  			            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,
  			            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,
  			            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,
  			            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,
  			            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,
  			            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,
  			            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,
  			            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,
  			            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,
  			            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,
  			            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,
  			            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,
  			            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,
  			            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,
  			            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,
  			            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,
  			            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,
  			            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,
  			            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,
  			            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,
  			            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,
  			            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,
  			            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,
  			            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,
  			            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,
  			            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,
  			            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,
  			            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,
  			            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,
  			            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,
  			            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,
  			            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,
  			            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],
  			        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,
  			            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,
  			            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,
  			            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,
  			            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,
  			            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,
  			            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,
  			            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,
  			            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,
  			            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,
  			            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,
  			            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,
  			            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,
  			            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,
  			            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,
  			            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,
  			            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,
  			            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,
  			            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,
  			            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,
  			            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,
  			            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,
  			            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,
  			            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,
  			            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,
  			            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,
  			            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,
  			            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,
  			            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,
  			            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,
  			            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,
  			            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,
  			            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,
  			            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,
  			            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,
  			            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,
  			            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,
  			            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,
  			            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,
  			            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,
  			            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,
  			            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,
  			            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,
  			            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,
  			            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,
  			            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,
  			            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,
  			            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,
  			            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,
  			            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,
  			            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,
  			            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,
  			            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,
  			            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,
  			            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,
  			            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,
  			            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,
  			            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,
  			            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,
  			            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,
  			            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,
  			            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,
  			            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,
  			            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],
  			        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,
  			            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,
  			            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,
  			            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,
  			            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,
  			            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,
  			            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,
  			            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,
  			            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,
  			            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,
  			            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,
  			            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,
  			            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,
  			            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,
  			            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,
  			            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,
  			            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,
  			            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,
  			            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,
  			            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,
  			            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,
  			            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,
  			            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,
  			            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,
  			            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,
  			            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,
  			            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,
  			            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,
  			            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,
  			            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,
  			            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,
  			            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,
  			            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,
  			            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,
  			            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,
  			            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,
  			            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,
  			            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,
  			            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,
  			            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,
  			            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,
  			            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,
  			            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,
  			            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,
  			            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,
  			            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,
  			            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,
  			            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,
  			            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,
  			            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,
  			            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,
  			            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,
  			            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,
  			            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,
  			            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,
  			            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,
  			            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,
  			            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,
  			            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,
  			            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,
  			            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,
  			            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,
  			            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,
  			            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],
  			        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,
  			            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,
  			            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,
  			            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,
  			            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,
  			            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,
  			            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,
  			            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,
  			            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,
  			            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,
  			            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,
  			            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,
  			            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,
  			            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,
  			            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,
  			            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,
  			            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,
  			            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,
  			            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,
  			            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,
  			            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,
  			            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,
  			            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,
  			            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,
  			            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,
  			            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,
  			            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,
  			            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,
  			            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,
  			            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,
  			            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,
  			            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,
  			            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,
  			            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,
  			            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,
  			            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,
  			            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,
  			            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,
  			            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,
  			            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,
  			            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,
  			            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,
  			            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,
  			            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,
  			            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,
  			            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,
  			            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,
  			            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,
  			            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,
  			            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,
  			            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,
  			            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,
  			            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,
  			            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,
  			            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,
  			            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,
  			            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,
  			            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,
  			            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,
  			            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,
  			            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,
  			            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,
  			            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,
  			            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]
  			    ];

  			    var BLOWFISH_CTX = {
  			        pbox: [],
  			        sbox: []
  			    };

  			    function F(ctx, x){
  			        let a = (x >> 24) & 0xFF;
  			        let b = (x >> 16) & 0xFF;
  			        let c = (x >> 8) & 0xFF;
  			        let d = x & 0xFF;

  			        let y = ctx.sbox[0][a] + ctx.sbox[1][b];
  			        y = y ^ ctx.sbox[2][c];
  			        y = y + ctx.sbox[3][d];

  			        return y;
  			    }

  			    function BlowFish_Encrypt(ctx, left, right){
  			        let Xl = left;
  			        let Xr = right;
  			        let temp;

  			        for(let i = 0; i < N; ++i){
  			            Xl = Xl ^ ctx.pbox[i];
  			            Xr = F(ctx, Xl) ^ Xr;

  			            temp = Xl;
  			            Xl = Xr;
  			            Xr = temp;
  			        }

  			        temp = Xl;
  			        Xl = Xr;
  			        Xr = temp;

  			        Xr = Xr ^ ctx.pbox[N];
  			        Xl = Xl ^ ctx.pbox[N + 1];

  			        return {left: Xl, right: Xr};
  			    }

  			    function BlowFish_Decrypt(ctx, left, right){
  			        let Xl = left;
  			        let Xr = right;
  			        let temp;

  			        for(let i = N + 1; i > 1; --i){
  			            Xl = Xl ^ ctx.pbox[i];
  			            Xr = F(ctx, Xl) ^ Xr;

  			            temp = Xl;
  			            Xl = Xr;
  			            Xr = temp;
  			        }

  			        temp = Xl;
  			        Xl = Xr;
  			        Xr = temp;

  			        Xr = Xr ^ ctx.pbox[1];
  			        Xl = Xl ^ ctx.pbox[0];

  			        return {left: Xl, right: Xr};
  			    }

  			    /**
  			     * Initialization ctx's pbox and sbox.
  			     *
  			     * @param {Object} ctx The object has pbox and sbox.
  			     * @param {Array} key An array of 32-bit words.
  			     * @param {int} keysize The length of the key.
  			     *
  			     * @example
  			     *
  			     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);
  			     */
  			    function BlowFishInit(ctx, key, keysize)
  			    {
  			        for(let Row = 0; Row < 4; Row++)
  			        {
  			            ctx.sbox[Row] = [];
  			            for(let Col = 0; Col < 256; Col++)
  			            {
  			                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
  			            }
  			        }

  			        let keyIndex = 0;
  			        for(let index = 0; index < N + 2; index++)
  			        {
  			            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
  			            keyIndex++;
  			            if(keyIndex >= keysize)
  			            {
  			                keyIndex = 0;
  			            }
  			        }

  			        let Data1 = 0;
  			        let Data2 = 0;
  			        let res = 0;
  			        for(let i = 0; i < N + 2; i += 2)
  			        {
  			            res = BlowFish_Encrypt(ctx, Data1, Data2);
  			            Data1 = res.left;
  			            Data2 = res.right;
  			            ctx.pbox[i] = Data1;
  			            ctx.pbox[i + 1] = Data2;
  			        }

  			        for(let i = 0; i < 4; i++)
  			        {
  			            for(let j = 0; j < 256; j += 2)
  			            {
  			                res = BlowFish_Encrypt(ctx, Data1, Data2);
  			                Data1 = res.left;
  			                Data2 = res.right;
  			                ctx.sbox[i][j] = Data1;
  			                ctx.sbox[i][j + 1] = Data2;
  			            }
  			        }

  			        return true;
  			    }

  			    /**
  			     * Blowfish block cipher algorithm.
  			     */
  			    var Blowfish = C_algo.Blowfish = BlockCipher.extend({
  			        _doReset: function () {
  			            // Skip reset of nRounds has been set before and key did not change
  			            if (this._keyPriorReset === this._key) {
  			                return;
  			            }

  			            // Shortcuts
  			            var key = this._keyPriorReset = this._key;
  			            var keyWords = key.words;
  			            var keySize = key.sigBytes / 4;

  			            //Initialization pbox and sbox
  			            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
  			        },

  			        encryptBlock: function (M, offset) {
  			            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
  			            M[offset] = res.left;
  			            M[offset + 1] = res.right;
  			        },

  			        decryptBlock: function (M, offset) {
  			            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
  			            M[offset] = res.left;
  			            M[offset + 1] = res.right;
  			        },

  			        blockSize: 64/32,

  			        keySize: 128/32,

  			        ivSize: 64/32
  			    });

  			    /**
  			     * Shortcut functions to the cipher's object interface.
  			     *
  			     * @example
  			     *
  			     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);
  			     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);
  			     */
  			    C.Blowfish = BlockCipher._createHelper(Blowfish);
  			}());


  			return CryptoJS.Blowfish;

  		})); 
  	} (blowfish));
  	return blowfish.exports;
  }

  (function (module, exports) {
  (function (root, factory, undef) {
  		{
  			// CommonJS
  			module.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
  		}
  	}(commonjsGlobal, function (CryptoJS) {

  		return CryptoJS;

  	})); 
  } (cryptoJs));

  var cryptoJsExports = cryptoJs.exports;
  var crypto = /*@__PURE__*/getDefaultExportFromCjs(cryptoJsExports);

  var util$5 = {
    sha1: function sha1(signStr) {
      return crypto.SHA1(signStr).toString();
    },
    sha1_hmac: function sha1_hmac(signStr, SecretKey) {
      return crypto.HmacSHA1(signStr, SecretKey).toString();
    },
    getParamKeylist: function getParamKeylist(obj) {
      var list = Object.keys(obj);
      return list.sort(function (a, b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        return a === b ? 0 : a > b ? 1 : -1;
      });
    },
    getHeaderKeylist: function getHeaderKeylist(obj) {
      var list = [];
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var lowerKey = key.toLowerCase();
        if (obj[key] && (lowerKey === 'content-type' || lowerKey === 'content-md5' || lowerKey === 'host' || lowerKey[0] === 'x')) {
          list.push(key);
        }
      }
      return list.sort(function (a, b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        return a === b ? 0 : a > b ? 1 : -1;
      });
    },
    camSafeUrlEncode: function camSafeUrlEncode(str) {
      return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    },
    obj2str: function obj2str(obj, getKeylist) {
      var i, key, val;
      var list = [];
      var keyList = getKeylist(obj);
      for (i = 0; i < keyList.length; i++) {
        key = keyList[i];
        val = obj[key] === undefined ? '' : '' + obj[key];
        key = key.toLowerCase();
        key = util$5.camSafeUrlEncode(key);
        val = util$5.camSafeUrlEncode(val) || '';
        list.push(key + '=' + val);
      }
      return list.join('&');
    }
  };
  function sign(opt) {
    var _util$getHeaderKeylis, _util$getParamKeylist;
    opt = opt || {};
    var _opt = opt,
      SecretId = _opt.SecretId,
      SecretKey = _opt.SecretKey;
    var method = (opt.method || 'get').toLowerCase();
    var queryParams = Object.assign({}, opt.query || {});
    var headersParams = Object.assign({}, opt.headers || {});
    if (!SecretId) {
      throw new ClsSDKError('missing param SecretId');
    }
    if (!SecretKey) {
      throw new ClsSDKError('missing param SecretKey');
    }
    // 签名有效起止时间
    var now = Math.floor(systemClock.now() / 1000) - 1;
    var exp = now;
    var Expires = opt.expires;
    if (Expires === undefined) {
      exp += 900; // 签名过期时间为当前 + 900s
    } else {
      exp += Expires * 1 || 0;
    }
    // 要用到的 Authorization 参数列表
    var SignAlgorithm = 'sha1';
    var SignTime = "".concat(now, ";").concat(exp);
    var KeyTime = "".concat(now, ";").concat(exp);
    var HeaderList = (_util$getHeaderKeylis = util$5.getHeaderKeylist(headersParams)) === null || _util$getHeaderKeylis === void 0 ? void 0 : _util$getHeaderKeylis.join(';').toLowerCase();
    var UrlParamList = (_util$getParamKeylist = util$5.getParamKeylist(queryParams)) === null || _util$getParamKeylist === void 0 ? void 0 : _util$getParamKeylist.join(';').toLowerCase();
    // 签名算法说明文档：https://cloud.tencent.com/document/product/614/12445
    // 步骤一：拼接 HttpRequestInfo
    var FormatedParameters = util$5.obj2str(queryParams, util$5.getParamKeylist);
    var FormatedHeaders = util$5.obj2str(headersParams, util$5.getHeaderKeylist);
    var HttpRequestInfo = [method.toLowerCase(), "/".concat(opt.api || ''), FormatedParameters, FormatedHeaders, ''].join('\n');
    // 步骤二：拼接 StringToSign
    var StringToSign = ['sha1', KeyTime, util$5.sha1(HttpRequestInfo), ''].join('\n');
    // 步骤三：生成 SignKey
    var SignKey = util$5.sha1_hmac(KeyTime, SecretKey);
    // 步骤四：计算 Signature
    var Signature = util$5.sha1_hmac(StringToSign, SignKey);
    // 步骤五：构造 Authorization
    var authorization = ["q-sign-algorithm=".concat(SignAlgorithm), "q-ak=".concat(SecretId), "q-sign-time=".concat(SignTime), "q-key-time=".concat(KeyTime), 'q-header-list=' + HeaderList, 'q-url-param-list=' + UrlParamList, "q-signature=".concat(Signature)].join('&');
    return authorization;
  }

  var indexMinimal = {};

  var minimal$1 = {};

  var aspromise = asPromise;

  /**
   * Callback as used by {@link util.asPromise}.
   * @typedef asPromiseCallback
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {...*} params Additional arguments
   * @returns {undefined}
   */

  /**
   * Returns a promise from a node-style callback function.
   * @memberof util
   * @param {asPromiseCallback} fn Function to call
   * @param {*} ctx Function context
   * @param {...*} params Function arguments
   * @returns {Promise<*>} Promisified function
   */
  function asPromise(fn, ctx/*, varargs */) {
      var params  = new Array(arguments.length - 1),
          offset  = 0,
          index   = 2,
          pending = true;
      while (index < arguments.length)
          params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err/*, varargs */) {
              if (pending) {
                  pending = false;
                  if (err)
                      reject(err);
                  else {
                      var params = new Array(arguments.length - 1),
                          offset = 0;
                      while (offset < params.length)
                          params[offset++] = arguments[offset];
                      resolve.apply(null, params);
                  }
              }
          };
          try {
              fn.apply(ctx || null, params);
          } catch (err) {
              if (pending) {
                  pending = false;
                  reject(err);
              }
          }
      });
  }

  var base64$1 = {};

  (function (exports) {

  	/**
  	 * A minimal base64 implementation for number arrays.
  	 * @memberof util
  	 * @namespace
  	 */
  	var base64 = exports;

  	/**
  	 * Calculates the byte length of a base64 encoded string.
  	 * @param {string} string Base64 encoded string
  	 * @returns {number} Byte length
  	 */
  	base64.length = function length(string) {
  	    var p = string.length;
  	    if (!p)
  	        return 0;
  	    var n = 0;
  	    while (--p % 4 > 1 && string.charAt(p) === "=")
  	        ++n;
  	    return Math.ceil(string.length * 3) / 4 - n;
  	};

  	// Base64 encoding table
  	var b64 = new Array(64);

  	// Base64 decoding table
  	var s64 = new Array(123);

  	// 65..90, 97..122, 48..57, 43, 47
  	for (var i = 0; i < 64;)
  	    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

  	/**
  	 * Encodes a buffer to a base64 encoded string.
  	 * @param {Uint8Array} buffer Source buffer
  	 * @param {number} start Source start
  	 * @param {number} end Source end
  	 * @returns {string} Base64 encoded string
  	 */
  	base64.encode = function encode(buffer, start, end) {
  	    var parts = null,
  	        chunk = [];
  	    var i = 0, // output index
  	        j = 0, // goto index
  	        t;     // temporary
  	    while (start < end) {
  	        var b = buffer[start++];
  	        switch (j) {
  	            case 0:
  	                chunk[i++] = b64[b >> 2];
  	                t = (b & 3) << 4;
  	                j = 1;
  	                break;
  	            case 1:
  	                chunk[i++] = b64[t | b >> 4];
  	                t = (b & 15) << 2;
  	                j = 2;
  	                break;
  	            case 2:
  	                chunk[i++] = b64[t | b >> 6];
  	                chunk[i++] = b64[b & 63];
  	                j = 0;
  	                break;
  	        }
  	        if (i > 8191) {
  	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
  	            i = 0;
  	        }
  	    }
  	    if (j) {
  	        chunk[i++] = b64[t];
  	        chunk[i++] = 61;
  	        if (j === 1)
  	            chunk[i++] = 61;
  	    }
  	    if (parts) {
  	        if (i)
  	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
  	        return parts.join("");
  	    }
  	    return String.fromCharCode.apply(String, chunk.slice(0, i));
  	};

  	var invalidEncoding = "invalid encoding";

  	/**
  	 * Decodes a base64 encoded string to a buffer.
  	 * @param {string} string Source string
  	 * @param {Uint8Array} buffer Destination buffer
  	 * @param {number} offset Destination offset
  	 * @returns {number} Number of bytes written
  	 * @throws {Error} If encoding is invalid
  	 */
  	base64.decode = function decode(string, buffer, offset) {
  	    var start = offset;
  	    var j = 0, // goto index
  	        t;     // temporary
  	    for (var i = 0; i < string.length;) {
  	        var c = string.charCodeAt(i++);
  	        if (c === 61 && j > 1)
  	            break;
  	        if ((c = s64[c]) === undefined)
  	            throw Error(invalidEncoding);
  	        switch (j) {
  	            case 0:
  	                t = c;
  	                j = 1;
  	                break;
  	            case 1:
  	                buffer[offset++] = t << 2 | (c & 48) >> 4;
  	                t = c;
  	                j = 2;
  	                break;
  	            case 2:
  	                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
  	                t = c;
  	                j = 3;
  	                break;
  	            case 3:
  	                buffer[offset++] = (t & 3) << 6 | c;
  	                j = 0;
  	                break;
  	        }
  	    }
  	    if (j === 1)
  	        throw Error(invalidEncoding);
  	    return offset - start;
  	};

  	/**
  	 * Tests if the specified string appears to be base64 encoded.
  	 * @param {string} string String to test
  	 * @returns {boolean} `true` if probably base64 encoded, otherwise false
  	 */
  	base64.test = function test(string) {
  	    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  	}; 
  } (base64$1));

  var eventemitter = EventEmitter;

  /**
   * Constructs a new event emitter instance.
   * @classdesc A minimal event emitter.
   * @memberof util
   * @constructor
   */
  function EventEmitter() {

      /**
       * Registered listeners.
       * @type {Object.<string,*>}
       * @private
       */
      this._listeners = {};
  }

  /**
   * Registers an event listener.
   * @param {string} evt Event name
   * @param {function} fn Listener
   * @param {*} [ctx] Listener context
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn  : fn,
          ctx : ctx || this
      });
      return this;
  };

  /**
   * Removes an event listener or any matching listeners if arguments are omitted.
   * @param {string} [evt] Event name. Removes all listeners if omitted.
   * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === undefined)
          this._listeners = {};
      else {
          if (fn === undefined)
              this._listeners[evt] = [];
          else {
              var listeners = this._listeners[evt];
              for (var i = 0; i < listeners.length;)
                  if (listeners[i].fn === fn)
                      listeners.splice(i, 1);
                  else
                      ++i;
          }
      }
      return this;
  };

  /**
   * Emits an event by calling its listeners with the specified arguments.
   * @param {string} evt Event name
   * @param {...*} args Arguments
   * @returns {util.EventEmitter} `this`
   */
  EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
          var args = [],
              i = 1;
          for (; i < arguments.length;)
              args.push(arguments[i++]);
          for (i = 0; i < listeners.length;)
              listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
  };

  var float = factory(factory);

  /**
   * Reads / writes floats / doubles from / to buffers.
   * @name util.float
   * @namespace
   */

  /**
   * Writes a 32 bit float to a buffer using little endian byte order.
   * @name util.float.writeFloatLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 32 bit float to a buffer using big endian byte order.
   * @name util.float.writeFloatBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 32 bit float from a buffer using little endian byte order.
   * @name util.float.readFloatLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 32 bit float from a buffer using big endian byte order.
   * @name util.float.readFloatBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Writes a 64 bit double to a buffer using little endian byte order.
   * @name util.float.writeDoubleLE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Writes a 64 bit double to a buffer using big endian byte order.
   * @name util.float.writeDoubleBE
   * @function
   * @param {number} val Value to write
   * @param {Uint8Array} buf Target buffer
   * @param {number} pos Target buffer offset
   * @returns {undefined}
   */

  /**
   * Reads a 64 bit double from a buffer using little endian byte order.
   * @name util.float.readDoubleLE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  /**
   * Reads a 64 bit double from a buffer using big endian byte order.
   * @name util.float.readDoubleBE
   * @function
   * @param {Uint8Array} buf Source buffer
   * @param {number} pos Source buffer offset
   * @returns {number} Value read
   */

  // Factory function for the purpose of node-based testing in modified global environments
  function factory(exports) {

      // float: typed array
      if (typeof Float32Array !== "undefined") (function() {

          var f32 = new Float32Array([ -0 ]),
              f8b = new Uint8Array(f32.buffer),
              le  = f8b[3] === 128;

          function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
          }

          function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos    ] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          /* istanbul ignore next */
          exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

          function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
          }

          function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos    ];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
          }

          /* istanbul ignore next */
          exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          /* istanbul ignore next */
          exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

      // float: ieee754
      })(); else (function() {

          function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0)
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
              else if (isNaN(val))
                  writeUint(2143289344, buf, pos);
              else if (val > 3.4028234663852886e+38) // +-Infinity
                  writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 1.1754943508222875e-38) // denormal
                  writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
              else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2),
                      mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                  writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
          }

          exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

          function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos),
                  sign = (uint >> 31) * 2 + 1,
                  exponent = uint >>> 23 & 255,
                  mantissa = uint & 8388607;
              return exponent === 255
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 1.401298464324817e-45 * mantissa
                  : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }

          exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

      })();

      // double: typed array
      if (typeof Float64Array !== "undefined") (function() {

          var f64 = new Float64Array([-0]),
              f8b = new Uint8Array(f64.buffer),
              le  = f8b[7] === 128;

          function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
          }

          function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos    ] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
          }

          /* istanbul ignore next */
          exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          /* istanbul ignore next */
          exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

          function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos    ];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
          }

          function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos    ];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
          }

          /* istanbul ignore next */
          exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          /* istanbul ignore next */
          exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

      // double: ieee754
      })(); else (function() {

          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                  val = -val;
              if (val === 0) {
                  writeUint(0, buf, pos + off0);
                  writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
              } else if (isNaN(val)) {
                  writeUint(0, buf, pos + off0);
                  writeUint(2146959360, buf, pos + off1);
              } else if (val > 1.7976931348623157e+308) { // +-Infinity
                  writeUint(0, buf, pos + off0);
                  writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                  var mantissa;
                  if (val < 2.2250738585072014e-308) { // denormal
                      mantissa = val / 5e-324;
                      writeUint(mantissa >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                  } else {
                      var exponent = Math.floor(Math.log(val) / Math.LN2);
                      if (exponent === 1024)
                          exponent = 1023;
                      mantissa = val * Math.pow(2, -exponent);
                      writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                      writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                  }
              }
          }

          exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0),
                  hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1,
                  exponent = hi >>> 20 & 2047,
                  mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047
                  ? mantissa
                  ? NaN
                  : sign * Infinity
                  : exponent === 0 // denormal
                  ? sign * 5e-324 * mantissa
                  : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }

          exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

      })();

      return exports;
  }

  // uint helpers

  function writeUintLE(val, buf, pos) {
      buf[pos    ] =  val        & 255;
      buf[pos + 1] =  val >>> 8  & 255;
      buf[pos + 2] =  val >>> 16 & 255;
      buf[pos + 3] =  val >>> 24;
  }

  function writeUintBE(val, buf, pos) {
      buf[pos    ] =  val >>> 24;
      buf[pos + 1] =  val >>> 16 & 255;
      buf[pos + 2] =  val >>> 8  & 255;
      buf[pos + 3] =  val        & 255;
  }

  function readUintLE(buf, pos) {
      return (buf[pos    ]
            | buf[pos + 1] << 8
            | buf[pos + 2] << 16
            | buf[pos + 3] << 24) >>> 0;
  }

  function readUintBE(buf, pos) {
      return (buf[pos    ] << 24
            | buf[pos + 1] << 16
            | buf[pos + 2] << 8
            | buf[pos + 3]) >>> 0;
  }

  var inquire_1 = inquire;

  /**
   * Requires a module only if available.
   * @memberof util
   * @param {string} moduleName Module to require
   * @returns {?Object} Required module if available and not empty, otherwise `null`
   */
  function inquire(moduleName) {
      try {
          var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
          if (mod && (mod.length || Object.keys(mod).length))
              return mod;
      } catch (e) {} // eslint-disable-line no-empty
      return null;
  }

  var utf8$2 = {};

  (function (exports) {

  	/**
  	 * A minimal UTF8 implementation for number arrays.
  	 * @memberof util
  	 * @namespace
  	 */
  	var utf8 = exports;

  	/**
  	 * Calculates the UTF8 byte length of a string.
  	 * @param {string} string String
  	 * @returns {number} Byte length
  	 */
  	utf8.length = function utf8_length(string) {
  	    var len = 0,
  	        c = 0;
  	    for (var i = 0; i < string.length; ++i) {
  	        c = string.charCodeAt(i);
  	        if (c < 128)
  	            len += 1;
  	        else if (c < 2048)
  	            len += 2;
  	        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
  	            ++i;
  	            len += 4;
  	        } else
  	            len += 3;
  	    }
  	    return len;
  	};

  	/**
  	 * Reads UTF8 bytes as a string.
  	 * @param {Uint8Array} buffer Source buffer
  	 * @param {number} start Source start
  	 * @param {number} end Source end
  	 * @returns {string} String read
  	 */
  	utf8.read = function utf8_read(buffer, start, end) {
  	    var len = end - start;
  	    if (len < 1)
  	        return "";
  	    var parts = null,
  	        chunk = [],
  	        i = 0, // char offset
  	        t;     // temporary
  	    while (start < end) {
  	        t = buffer[start++];
  	        if (t < 128)
  	            chunk[i++] = t;
  	        else if (t > 191 && t < 224)
  	            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
  	        else if (t > 239 && t < 365) {
  	            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
  	            chunk[i++] = 0xD800 + (t >> 10);
  	            chunk[i++] = 0xDC00 + (t & 1023);
  	        } else
  	            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
  	        if (i > 8191) {
  	            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
  	            i = 0;
  	        }
  	    }
  	    if (parts) {
  	        if (i)
  	            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
  	        return parts.join("");
  	    }
  	    return String.fromCharCode.apply(String, chunk.slice(0, i));
  	};

  	/**
  	 * Writes a string as UTF8 bytes.
  	 * @param {string} string Source string
  	 * @param {Uint8Array} buffer Destination buffer
  	 * @param {number} offset Destination offset
  	 * @returns {number} Bytes written
  	 */
  	utf8.write = function utf8_write(string, buffer, offset) {
  	    var start = offset,
  	        c1, // character 1
  	        c2; // character 2
  	    for (var i = 0; i < string.length; ++i) {
  	        c1 = string.charCodeAt(i);
  	        if (c1 < 128) {
  	            buffer[offset++] = c1;
  	        } else if (c1 < 2048) {
  	            buffer[offset++] = c1 >> 6       | 192;
  	            buffer[offset++] = c1       & 63 | 128;
  	        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
  	            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
  	            ++i;
  	            buffer[offset++] = c1 >> 18      | 240;
  	            buffer[offset++] = c1 >> 12 & 63 | 128;
  	            buffer[offset++] = c1 >> 6  & 63 | 128;
  	            buffer[offset++] = c1       & 63 | 128;
  	        } else {
  	            buffer[offset++] = c1 >> 12      | 224;
  	            buffer[offset++] = c1 >> 6  & 63 | 128;
  	            buffer[offset++] = c1       & 63 | 128;
  	        }
  	    }
  	    return offset - start;
  	}; 
  } (utf8$2));

  var pool_1 = pool;

  /**
   * An allocator as used by {@link util.pool}.
   * @typedef PoolAllocator
   * @type {function}
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */

  /**
   * A slicer as used by {@link util.pool}.
   * @typedef PoolSlicer
   * @type {function}
   * @param {number} start Start offset
   * @param {number} end End offset
   * @returns {Uint8Array} Buffer slice
   * @this {Uint8Array}
   */

  /**
   * A general purpose buffer pool.
   * @memberof util
   * @function
   * @param {PoolAllocator} alloc Allocator
   * @param {PoolSlicer} slice Slicer
   * @param {number} [size=8192] Slab size
   * @returns {PoolAllocator} Pooled allocator
   */
  function pool(alloc, slice, size) {
      var SIZE   = size || 8192;
      var MAX    = SIZE >>> 1;
      var slab   = null;
      var offset = SIZE;
      return function pool_alloc(size) {
          if (size < 1 || size > MAX)
              return alloc(size);
          if (offset + size > SIZE) {
              slab = alloc(SIZE);
              offset = 0;
          }
          var buf = slice.call(slab, offset, offset += size);
          if (offset & 7) // align to 32 bit
              offset = (offset | 7) + 1;
          return buf;
      };
  }

  var longbits;
  var hasRequiredLongbits;

  function requireLongbits () {
  	if (hasRequiredLongbits) return longbits;
  	hasRequiredLongbits = 1;
  	longbits = LongBits;

  	var util = requireMinimal();

  	/**
  	 * Constructs new long bits.
  	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
  	 * @memberof util
  	 * @constructor
  	 * @param {number} lo Low 32 bits, unsigned
  	 * @param {number} hi High 32 bits, unsigned
  	 */
  	function LongBits(lo, hi) {

  	    // note that the casts below are theoretically unnecessary as of today, but older statically
  	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

  	    /**
  	     * Low bits.
  	     * @type {number}
  	     */
  	    this.lo = lo >>> 0;

  	    /**
  	     * High bits.
  	     * @type {number}
  	     */
  	    this.hi = hi >>> 0;
  	}

  	/**
  	 * Zero bits.
  	 * @memberof util.LongBits
  	 * @type {util.LongBits}
  	 */
  	var zero = LongBits.zero = new LongBits(0, 0);

  	zero.toNumber = function() { return 0; };
  	zero.zzEncode = zero.zzDecode = function() { return this; };
  	zero.length = function() { return 1; };

  	/**
  	 * Zero hash.
  	 * @memberof util.LongBits
  	 * @type {string}
  	 */
  	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

  	/**
  	 * Constructs new long bits from the specified number.
  	 * @param {number} value Value
  	 * @returns {util.LongBits} Instance
  	 */
  	LongBits.fromNumber = function fromNumber(value) {
  	    if (value === 0)
  	        return zero;
  	    var sign = value < 0;
  	    if (sign)
  	        value = -value;
  	    var lo = value >>> 0,
  	        hi = (value - lo) / 4294967296 >>> 0;
  	    if (sign) {
  	        hi = ~hi >>> 0;
  	        lo = ~lo >>> 0;
  	        if (++lo > 4294967295) {
  	            lo = 0;
  	            if (++hi > 4294967295)
  	                hi = 0;
  	        }
  	    }
  	    return new LongBits(lo, hi);
  	};

  	/**
  	 * Constructs new long bits from a number, long or string.
  	 * @param {Long|number|string} value Value
  	 * @returns {util.LongBits} Instance
  	 */
  	LongBits.from = function from(value) {
  	    if (typeof value === "number")
  	        return LongBits.fromNumber(value);
  	    if (util.isString(value)) {
  	        /* istanbul ignore else */
  	        if (util.Long)
  	            value = util.Long.fromString(value);
  	        else
  	            return LongBits.fromNumber(parseInt(value, 10));
  	    }
  	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  	};

  	/**
  	 * Converts this long bits to a possibly unsafe JavaScript number.
  	 * @param {boolean} [unsigned=false] Whether unsigned or not
  	 * @returns {number} Possibly unsafe number
  	 */
  	LongBits.prototype.toNumber = function toNumber(unsigned) {
  	    if (!unsigned && this.hi >>> 31) {
  	        var lo = ~this.lo + 1 >>> 0,
  	            hi = ~this.hi     >>> 0;
  	        if (!lo)
  	            hi = hi + 1 >>> 0;
  	        return -(lo + hi * 4294967296);
  	    }
  	    return this.lo + this.hi * 4294967296;
  	};

  	/**
  	 * Converts this long bits to a long.
  	 * @param {boolean} [unsigned=false] Whether unsigned or not
  	 * @returns {Long} Long
  	 */
  	LongBits.prototype.toLong = function toLong(unsigned) {
  	    return util.Long
  	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
  	        /* istanbul ignore next */
  	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  	};

  	var charCodeAt = String.prototype.charCodeAt;

  	/**
  	 * Constructs new long bits from the specified 8 characters long hash.
  	 * @param {string} hash Hash
  	 * @returns {util.LongBits} Bits
  	 */
  	LongBits.fromHash = function fromHash(hash) {
  	    if (hash === zeroHash)
  	        return zero;
  	    return new LongBits(
  	        ( charCodeAt.call(hash, 0)
  	        | charCodeAt.call(hash, 1) << 8
  	        | charCodeAt.call(hash, 2) << 16
  	        | charCodeAt.call(hash, 3) << 24) >>> 0
  	    ,
  	        ( charCodeAt.call(hash, 4)
  	        | charCodeAt.call(hash, 5) << 8
  	        | charCodeAt.call(hash, 6) << 16
  	        | charCodeAt.call(hash, 7) << 24) >>> 0
  	    );
  	};

  	/**
  	 * Converts this long bits to a 8 characters long hash.
  	 * @returns {string} Hash
  	 */
  	LongBits.prototype.toHash = function toHash() {
  	    return String.fromCharCode(
  	        this.lo        & 255,
  	        this.lo >>> 8  & 255,
  	        this.lo >>> 16 & 255,
  	        this.lo >>> 24      ,
  	        this.hi        & 255,
  	        this.hi >>> 8  & 255,
  	        this.hi >>> 16 & 255,
  	        this.hi >>> 24
  	    );
  	};

  	/**
  	 * Zig-zag encodes this long bits.
  	 * @returns {util.LongBits} `this`
  	 */
  	LongBits.prototype.zzEncode = function zzEncode() {
  	    var mask =   this.hi >> 31;
  	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
  	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
  	    return this;
  	};

  	/**
  	 * Zig-zag decodes this long bits.
  	 * @returns {util.LongBits} `this`
  	 */
  	LongBits.prototype.zzDecode = function zzDecode() {
  	    var mask = -(this.lo & 1);
  	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
  	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
  	    return this;
  	};

  	/**
  	 * Calculates the length of this longbits when encoded as a varint.
  	 * @returns {number} Length
  	 */
  	LongBits.prototype.length = function length() {
  	    var part0 =  this.lo,
  	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
  	        part2 =  this.hi >>> 24;
  	    return part2 === 0
  	         ? part1 === 0
  	           ? part0 < 16384
  	             ? part0 < 128 ? 1 : 2
  	             : part0 < 2097152 ? 3 : 4
  	           : part1 < 16384
  	             ? part1 < 128 ? 5 : 6
  	             : part1 < 2097152 ? 7 : 8
  	         : part2 < 128 ? 9 : 10;
  	};
  	return longbits;
  }

  var hasRequiredMinimal;

  function requireMinimal () {
  	if (hasRequiredMinimal) return minimal$1;
  	hasRequiredMinimal = 1;
  	(function (exports) {
  		var util = exports;

  		// used to return a Promise where callback is omitted
  		util.asPromise = aspromise;

  		// converts to / from base64 encoded strings
  		util.base64 = base64$1;

  		// base class of rpc.Service
  		util.EventEmitter = eventemitter;

  		// float handling accross browsers
  		util.float = float;

  		// requires modules optionally and hides the call from bundlers
  		util.inquire = inquire_1;

  		// converts to / from utf8 encoded strings
  		util.utf8 = utf8$2;

  		// provides a node-like buffer pool in the browser
  		util.pool = pool_1;

  		// utility to work with the low and high bits of a 64 bit value
  		util.LongBits = requireLongbits();

  		/**
  		 * Whether running within node or not.
  		 * @memberof util
  		 * @type {boolean}
  		 */
  		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
  		                   && commonjsGlobal
  		                   && commonjsGlobal.process
  		                   && commonjsGlobal.process.versions
  		                   && commonjsGlobal.process.versions.node);

  		/**
  		 * Global object reference.
  		 * @memberof util
  		 * @type {Object}
  		 */
  		util.global = util.isNode && commonjsGlobal
  		           || typeof window !== "undefined" && window
  		           || typeof self   !== "undefined" && self
  		           || commonjsGlobal; // eslint-disable-line no-invalid-this

  		/**
  		 * An immuable empty array.
  		 * @memberof util
  		 * @type {Array.<*>}
  		 * @const
  		 */
  		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

  		/**
  		 * An immutable empty object.
  		 * @type {Object}
  		 * @const
  		 */
  		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

  		/**
  		 * Tests if the specified value is an integer.
  		 * @function
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is an integer
  		 */
  		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
  		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  		};

  		/**
  		 * Tests if the specified value is a string.
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is a string
  		 */
  		util.isString = function isString(value) {
  		    return typeof value === "string" || value instanceof String;
  		};

  		/**
  		 * Tests if the specified value is a non-null object.
  		 * @param {*} value Value to test
  		 * @returns {boolean} `true` if the value is a non-null object
  		 */
  		util.isObject = function isObject(value) {
  		    return value && typeof value === "object";
  		};

  		/**
  		 * Checks if a property on a message is considered to be present.
  		 * This is an alias of {@link util.isSet}.
  		 * @function
  		 * @param {Object} obj Plain object or message instance
  		 * @param {string} prop Property name
  		 * @returns {boolean} `true` if considered to be present, otherwise `false`
  		 */
  		util.isset =

  		/**
  		 * Checks if a property on a message is considered to be present.
  		 * @param {Object} obj Plain object or message instance
  		 * @param {string} prop Property name
  		 * @returns {boolean} `true` if considered to be present, otherwise `false`
  		 */
  		util.isSet = function isSet(obj, prop) {
  		    var value = obj[prop];
  		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
  		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
  		    return false;
  		};

  		/**
  		 * Any compatible Buffer instance.
  		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
  		 * @interface Buffer
  		 * @extends Uint8Array
  		 */

  		/**
  		 * Node's Buffer class if available.
  		 * @type {Constructor<Buffer>}
  		 */
  		util.Buffer = (function() {
  		    try {
  		        var Buffer = util.inquire("buffer").Buffer;
  		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
  		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
  		    } catch (e) {
  		        /* istanbul ignore next */
  		        return null;
  		    }
  		})();

  		// Internal alias of or polyfull for Buffer.from.
  		util._Buffer_from = null;

  		// Internal alias of or polyfill for Buffer.allocUnsafe.
  		util._Buffer_allocUnsafe = null;

  		/**
  		 * Creates a new buffer of whatever type supported by the environment.
  		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
  		 * @returns {Uint8Array|Buffer} Buffer
  		 */
  		util.newBuffer = function newBuffer(sizeOrArray) {
  		    /* istanbul ignore next */
  		    return typeof sizeOrArray === "number"
  		        ? util.Buffer
  		            ? util._Buffer_allocUnsafe(sizeOrArray)
  		            : new util.Array(sizeOrArray)
  		        : util.Buffer
  		            ? util._Buffer_from(sizeOrArray)
  		            : typeof Uint8Array === "undefined"
  		                ? sizeOrArray
  		                : new Uint8Array(sizeOrArray);
  		};

  		/**
  		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
  		 * @type {Constructor<Uint8Array>}
  		 */
  		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

  		/**
  		 * Any compatible Long instance.
  		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
  		 * @interface Long
  		 * @property {number} low Low bits
  		 * @property {number} high High bits
  		 * @property {boolean} unsigned Whether unsigned or not
  		 */

  		/**
  		 * Long.js's Long class if available.
  		 * @type {Constructor<Long>}
  		 */
  		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
  		         || /* istanbul ignore next */ util.global.Long
  		         || util.inquire("long");

  		/**
  		 * Regular expression used to verify 2 bit (`bool`) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key2Re = /^true|false|0|1$/;

  		/**
  		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

  		/**
  		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
  		 * @type {RegExp}
  		 * @const
  		 */
  		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

  		/**
  		 * Converts a number or long to an 8 characters long hash string.
  		 * @param {Long|number} value Value to convert
  		 * @returns {string} Hash
  		 */
  		util.longToHash = function longToHash(value) {
  		    return value
  		        ? util.LongBits.from(value).toHash()
  		        : util.LongBits.zeroHash;
  		};

  		/**
  		 * Converts an 8 characters long hash string to a long or number.
  		 * @param {string} hash Hash
  		 * @param {boolean} [unsigned=false] Whether unsigned or not
  		 * @returns {Long|number} Original value
  		 */
  		util.longFromHash = function longFromHash(hash, unsigned) {
  		    var bits = util.LongBits.fromHash(hash);
  		    if (util.Long)
  		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
  		    return bits.toNumber(Boolean(unsigned));
  		};

  		/**
  		 * Merges the properties of the source object into the destination object.
  		 * @memberof util
  		 * @param {Object.<string,*>} dst Destination object
  		 * @param {Object.<string,*>} src Source object
  		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
  		 * @returns {Object.<string,*>} Destination object
  		 */
  		function merge(dst, src, ifNotSet) { // used by converters
  		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
  		        if (dst[keys[i]] === undefined || !ifNotSet)
  		            dst[keys[i]] = src[keys[i]];
  		    return dst;
  		}

  		util.merge = merge;

  		/**
  		 * Converts the first character of a string to lower case.
  		 * @param {string} str String to convert
  		 * @returns {string} Converted string
  		 */
  		util.lcFirst = function lcFirst(str) {
  		    return str.charAt(0).toLowerCase() + str.substring(1);
  		};

  		/**
  		 * Creates a custom error constructor.
  		 * @memberof util
  		 * @param {string} name Error name
  		 * @returns {Constructor<Error>} Custom error constructor
  		 */
  		function newError(name) {

  		    function CustomError(message, properties) {

  		        if (!(this instanceof CustomError))
  		            return new CustomError(message, properties);

  		        // Error.call(this, message);
  		        // ^ just returns a new error instance because the ctor can be called as a function

  		        Object.defineProperty(this, "message", { get: function() { return message; } });

  		        /* istanbul ignore next */
  		        if (Error.captureStackTrace) // node
  		            Error.captureStackTrace(this, CustomError);
  		        else
  		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

  		        if (properties)
  		            merge(this, properties);
  		    }

  		    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

  		    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

  		    CustomError.prototype.toString = function toString() {
  		        return this.name + ": " + this.message;
  		    };

  		    return CustomError;
  		}

  		util.newError = newError;

  		/**
  		 * Constructs a new protocol error.
  		 * @classdesc Error subclass indicating a protocol specifc error.
  		 * @memberof util
  		 * @extends Error
  		 * @template T extends Message<T>
  		 * @constructor
  		 * @param {string} message Error message
  		 * @param {Object.<string,*>} [properties] Additional properties
  		 * @example
  		 * try {
  		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
  		 * } catch (e) {
  		 *     if (e instanceof ProtocolError && e.instance)
  		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
  		 * }
  		 */
  		util.ProtocolError = newError("ProtocolError");

  		/**
  		 * So far decoded message instance.
  		 * @name util.ProtocolError#instance
  		 * @type {Message<T>}
  		 */

  		/**
  		 * A OneOf getter as returned by {@link util.oneOfGetter}.
  		 * @typedef OneOfGetter
  		 * @type {function}
  		 * @returns {string|undefined} Set field name, if any
  		 */

  		/**
  		 * Builds a getter for a oneof's present field name.
  		 * @param {string[]} fieldNames Field names
  		 * @returns {OneOfGetter} Unbound getter
  		 */
  		util.oneOfGetter = function getOneOf(fieldNames) {
  		    var fieldMap = {};
  		    for (var i = 0; i < fieldNames.length; ++i)
  		        fieldMap[fieldNames[i]] = 1;

  		    /**
  		     * @returns {string|undefined} Set field name, if any
  		     * @this Object
  		     * @ignore
  		     */
  		    return function() { // eslint-disable-line consistent-return
  		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
  		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
  		                return keys[i];
  		    };
  		};

  		/**
  		 * A OneOf setter as returned by {@link util.oneOfSetter}.
  		 * @typedef OneOfSetter
  		 * @type {function}
  		 * @param {string|undefined} value Field name
  		 * @returns {undefined}
  		 */

  		/**
  		 * Builds a setter for a oneof's present field name.
  		 * @param {string[]} fieldNames Field names
  		 * @returns {OneOfSetter} Unbound setter
  		 */
  		util.oneOfSetter = function setOneOf(fieldNames) {

  		    /**
  		     * @param {string} name Field name
  		     * @returns {undefined}
  		     * @this Object
  		     * @ignore
  		     */
  		    return function(name) {
  		        for (var i = 0; i < fieldNames.length; ++i)
  		            if (fieldNames[i] !== name)
  		                delete this[fieldNames[i]];
  		    };
  		};

  		/**
  		 * Default conversion options used for {@link Message#toJSON} implementations.
  		 *
  		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
  		 *
  		 * - Longs become strings
  		 * - Enums become string keys
  		 * - Bytes become base64 encoded strings
  		 * - (Sub-)Messages become plain objects
  		 * - Maps become plain objects with all string keys
  		 * - Repeated fields become arrays
  		 * - NaN and Infinity for float and double fields become strings
  		 *
  		 * @type {IConversionOptions}
  		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
  		 */
  		util.toJSONOptions = {
  		    longs: String,
  		    enums: String,
  		    bytes: String,
  		    json: true
  		};

  		// Sets up buffer utility according to the environment (called in index-minimal)
  		util._configure = function() {
  		    var Buffer = util.Buffer;
  		    /* istanbul ignore if */
  		    if (!Buffer) {
  		        util._Buffer_from = util._Buffer_allocUnsafe = null;
  		        return;
  		    }
  		    // because node 4.x buffers are incompatible & immutable
  		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
  		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
  		        /* istanbul ignore next */
  		        function Buffer_from(value, encoding) {
  		            return new Buffer(value, encoding);
  		        };
  		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
  		        /* istanbul ignore next */
  		        function Buffer_allocUnsafe(size) {
  		            return new Buffer(size);
  		        };
  		}; 
  	} (minimal$1));
  	return minimal$1;
  }

  var writer = Writer$1;

  var util$4      = requireMinimal();

  var BufferWriter$1; // cyclic

  var LongBits$1  = util$4.LongBits,
      base64    = util$4.base64,
      utf8$1      = util$4.utf8;

  /**
   * Constructs a new writer operation instance.
   * @classdesc Scheduled writer operation.
   * @constructor
   * @param {function(*, Uint8Array, number)} fn Function to call
   * @param {number} len Value byte length
   * @param {*} val Value to write
   * @ignore
   */
  function Op(fn, len, val) {

      /**
       * Function to call.
       * @type {function(Uint8Array, number, *)}
       */
      this.fn = fn;

      /**
       * Value byte length.
       * @type {number}
       */
      this.len = len;

      /**
       * Next operation.
       * @type {Writer.Op|undefined}
       */
      this.next = undefined;

      /**
       * Value to write.
       * @type {*}
       */
      this.val = val; // type varies
  }

  /* istanbul ignore next */
  function noop() {} // eslint-disable-line no-empty-function

  /**
   * Constructs a new writer state instance.
   * @classdesc Copied writer state.
   * @memberof Writer
   * @constructor
   * @param {Writer} writer Writer to copy state from
   * @ignore
   */
  function State(writer) {

      /**
       * Current head.
       * @type {Writer.Op}
       */
      this.head = writer.head;

      /**
       * Current tail.
       * @type {Writer.Op}
       */
      this.tail = writer.tail;

      /**
       * Current buffer length.
       * @type {number}
       */
      this.len = writer.len;

      /**
       * Next state.
       * @type {State|null}
       */
      this.next = writer.states;
  }

  /**
   * Constructs a new writer instance.
   * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   */
  function Writer$1() {

      /**
       * Current length.
       * @type {number}
       */
      this.len = 0;

      /**
       * Operations head.
       * @type {Object}
       */
      this.head = new Op(noop, 0, 0);

      /**
       * Operations tail
       * @type {Object}
       */
      this.tail = this.head;

      /**
       * Linked forked states.
       * @type {Object|null}
       */
      this.states = null;

      // When a value is written, the writer calculates its byte length and puts it into a linked
      // list of operations to perform when finish() is called. This both allows us to allocate
      // buffers of the exact required size and reduces the amount of work we have to do compared
      // to first calculating over objects and then encoding over objects. In our case, the encoding
      // part is just a linked list walk calling operations with already prepared values.
  }

  var create$1 = function create() {
      return util$4.Buffer
          ? function create_buffer_setup() {
              return (Writer$1.create = function create_buffer() {
                  return new BufferWriter$1();
              })();
          }
          /* istanbul ignore next */
          : function create_array() {
              return new Writer$1();
          };
  };

  /**
   * Creates a new writer.
   * @function
   * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
   */
  Writer$1.create = create$1();

  /**
   * Allocates a buffer of the specified size.
   * @param {number} size Buffer size
   * @returns {Uint8Array} Buffer
   */
  Writer$1.alloc = function alloc(size) {
      return new util$4.Array(size);
  };

  // Use Uint8Array buffer pool in the browser, just like node does with buffers
  /* istanbul ignore else */
  if (util$4.Array !== Array)
      Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);

  /**
   * Pushes a new operation to the queue.
   * @param {function(Uint8Array, number, *)} fn Function to call
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @returns {Writer} `this`
   * @private
   */
  Writer$1.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
  };

  function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
  }

  function writeVarint32(val, buf, pos) {
      while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
      }
      buf[pos] = val;
  }

  /**
   * Constructs a new varint writer operation instance.
   * @classdesc Scheduled varint writer operation.
   * @extends Op
   * @constructor
   * @param {number} len Value byte length
   * @param {number} val Value to write
   * @ignore
   */
  function VarintOp(len, val) {
      this.len = len;
      this.next = undefined;
      this.val = val;
  }

  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;

  /**
   * Writes an unsigned 32 bit value as a varint.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.uint32 = function write_uint32(value) {
      // here, the call to this.push has been inlined and a varint specific Op subclass is used.
      // uint32 is by far the most frequently used operation and benefits significantly from this.
      this.len += (this.tail = this.tail.next = new VarintOp(
          (value = value >>> 0)
                  < 128       ? 1
          : value < 16384     ? 2
          : value < 2097152   ? 3
          : value < 268435456 ? 4
          :                     5,
      value)).len;
      return this;
  };

  /**
   * Writes a signed 32 bit value as a varint.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.int32 = function write_int32(value) {
      return value < 0
          ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) // 10 bytes per spec
          : this.uint32(value);
  };

  /**
   * Writes a 32 bit value as a varint, zig-zag encoded.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };

  function writeVarint64(val, buf, pos) {
      while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
      }
      while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
  }

  /**
   * Writes an unsigned 64 bit value as a varint.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer$1.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a signed 64 bit value as a varint.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer$1.prototype.int64 = Writer$1.prototype.uint64;

  /**
   * Writes a signed 64 bit value as a varint, zig-zag encoded.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer$1.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits$1.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
  };

  /**
   * Writes a boolish value as a varint.
   * @param {boolean} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
  };

  function writeFixed32(val, buf, pos) {
      buf[pos    ] =  val         & 255;
      buf[pos + 1] =  val >>> 8   & 255;
      buf[pos + 2] =  val >>> 16  & 255;
      buf[pos + 3] =  val >>> 24;
  }

  /**
   * Writes an unsigned 32 bit value as fixed 32 bits.
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
  };

  /**
   * Writes a signed 32 bit value as fixed 32 bits.
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;

  /**
   * Writes an unsigned 64 bit value as fixed 64 bits.
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer$1.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits$1.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };

  /**
   * Writes a signed 64 bit value as fixed 64 bits.
   * @function
   * @param {Long|number|string} value Value to write
   * @returns {Writer} `this`
   * @throws {TypeError} If `value` is a string and no long library is present.
   */
  Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;

  /**
   * Writes a float (32 bit).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.float = function write_float(value) {
      return this._push(util$4.float.writeFloatLE, 4, value);
  };

  /**
   * Writes a double (64 bit float).
   * @function
   * @param {number} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.double = function write_double(value) {
      return this._push(util$4.float.writeDoubleLE, 8, value);
  };

  var writeBytes = util$4.Array.prototype.set
      ? function writeBytes_set(val, buf, pos) {
          buf.set(val, pos); // also works for plain array values
      }
      /* istanbul ignore next */
      : function writeBytes_for(val, buf, pos) {
          for (var i = 0; i < val.length; ++i)
              buf[pos + i] = val[i];
      };

  /**
   * Writes a sequence of bytes.
   * @param {Uint8Array|string} value Buffer or base64 encoded string to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
          return this._push(writeByte, 1, 0);
      if (util$4.isString(value)) {
          var buf = Writer$1.alloc(len = base64.length(value));
          base64.decode(value, buf, 0);
          value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
  };

  /**
   * Writes a string.
   * @param {string} value Value to write
   * @returns {Writer} `this`
   */
  Writer$1.prototype.string = function write_string(value) {
      var len = utf8$1.length(value);
      return len
          ? this.uint32(len)._push(utf8$1.write, len, value)
          : this._push(writeByte, 1, 0);
  };

  /**
   * Forks this writer's state by pushing it to a stack.
   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
   * @returns {Writer} `this`
   */
  Writer$1.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
  };

  /**
   * Resets this instance to the last state.
   * @returns {Writer} `this`
   */
  Writer$1.prototype.reset = function reset() {
      if (this.states) {
          this.head   = this.states.head;
          this.tail   = this.states.tail;
          this.len    = this.states.len;
          this.states = this.states.next;
      } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len  = 0;
      }
      return this;
  };

  /**
   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
   * @returns {Writer} `this`
   */
  Writer$1.prototype.ldelim = function ldelim() {
      var head = this.head,
          tail = this.tail,
          len  = this.len;
      this.reset().uint32(len);
      if (len) {
          this.tail.next = head.next; // skip noop
          this.tail = tail;
          this.len += len;
      }
      return this;
  };

  /**
   * Finishes the write operation.
   * @returns {Uint8Array} Finished buffer
   */
  Writer$1.prototype.finish = function finish() {
      var head = this.head.next, // skip noop
          buf  = this.constructor.alloc(this.len),
          pos  = 0;
      while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
      }
      // this.head = this.tail = null;
      return buf;
  };

  Writer$1._configure = function(BufferWriter_) {
      BufferWriter$1 = BufferWriter_;
      Writer$1.create = create$1();
      BufferWriter$1._configure();
  };

  var writer_buffer = BufferWriter;

  // extends Writer
  var Writer = writer;
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

  var util$3 = requireMinimal();

  /**
   * Constructs a new buffer writer instance.
   * @classdesc Wire format writer using node buffers.
   * @extends Writer
   * @constructor
   */
  function BufferWriter() {
      Writer.call(this);
  }

  BufferWriter._configure = function () {
      /**
       * Allocates a buffer of the specified size.
       * @function
       * @param {number} size Buffer size
       * @returns {Buffer} Buffer
       */
      BufferWriter.alloc = util$3._Buffer_allocUnsafe;

      BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set"
          ? function writeBytesBuffer_set(val, buf, pos) {
            buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
            // also works for plain array values
          }
          /* istanbul ignore next */
          : function writeBytesBuffer_copy(val, buf, pos) {
            if (val.copy) // Buffer values
              val.copy(buf, pos, 0, val.length);
            else for (var i = 0; i < val.length;) // plain array values
              buf[pos++] = val[i++];
          };
  };


  /**
   * @override
   */
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util$3.isString(value))
          value = util$3._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
  };

  function writeStringBuffer(val, buf, pos) {
      if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
          util$3.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
          buf.utf8Write(val, pos);
      else
          buf.write(val, pos);
  }

  /**
   * @override
   */
  BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util$3.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
          this._push(writeStringBuffer, len, value);
      return this;
  };


  /**
   * Finishes the write operation.
   * @name BufferWriter#finish
   * @function
   * @returns {Buffer} Finished buffer
   */

  BufferWriter._configure();

  var reader = Reader$1;

  var util$2      = requireMinimal();

  var BufferReader$1; // cyclic

  var LongBits  = util$2.LongBits,
      utf8      = util$2.utf8;

  /* istanbul ignore next */
  function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }

  /**
   * Constructs a new reader instance using the specified buffer.
   * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
   * @constructor
   * @param {Uint8Array} buffer Buffer to read from
   */
  function Reader$1(buffer) {

      /**
       * Read buffer.
       * @type {Uint8Array}
       */
      this.buf = buffer;

      /**
       * Read buffer position.
       * @type {number}
       */
      this.pos = 0;

      /**
       * Read buffer length.
       * @type {number}
       */
      this.len = buffer.length;
  }

  var create_array = typeof Uint8Array !== "undefined"
      ? function create_typed_array(buffer) {
          if (buffer instanceof Uint8Array || Array.isArray(buffer))
              return new Reader$1(buffer);
          throw Error("illegal buffer");
      }
      /* istanbul ignore next */
      : function create_array(buffer) {
          if (Array.isArray(buffer))
              return new Reader$1(buffer);
          throw Error("illegal buffer");
      };

  var create = function create() {
      return util$2.Buffer
          ? function create_buffer_setup(buffer) {
              return (Reader$1.create = function create_buffer(buffer) {
                  return util$2.Buffer.isBuffer(buffer)
                      ? new BufferReader$1(buffer)
                      /* istanbul ignore next */
                      : create_array(buffer);
              })(buffer);
          }
          /* istanbul ignore next */
          : create_array;
  };

  /**
   * Creates a new reader using the specified buffer.
   * @function
   * @param {Uint8Array|Buffer} buffer Buffer to read from
   * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
   * @throws {Error} If `buffer` is not a valid buffer
   */
  Reader$1.create = create();

  Reader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */ util$2.Array.prototype.slice;

  /**
   * Reads a varint as an unsigned 32 bit value.
   * @function
   * @returns {number} Value read
   */
  Reader$1.prototype.uint32 = (function read_uint32_setup() {
      var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
      return function read_uint32() {
          value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
          value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

          /* istanbul ignore if */
          if ((this.pos += 5) > this.len) {
              this.pos = this.len;
              throw indexOutOfRange(this, 10);
          }
          return value;
      };
  })();

  /**
   * Reads a varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader$1.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
  };

  /**
   * Reads a zig-zag encoded varint as a signed 32 bit value.
   * @returns {number} Value read
   */
  Reader$1.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readLongVarint() {
      // tends to deopt with local vars for octet etc.
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) { // fast route (lo)
          for (; i < 4; ++i) {
              // 1st..4th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 5th
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
          if (this.buf[this.pos++] < 128)
              return bits;
          i = 0;
      } else {
          for (; i < 3; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 1st..3th
              bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
          // 4th
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
      }
      if (this.len - this.pos > 4) { // fast route (hi)
          for (; i < 5; ++i) {
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      } else {
          for (; i < 5; ++i) {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
              // 6th..10th
              bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
              if (this.buf[this.pos++] < 128)
                  return bits;
          }
      }
      /* istanbul ignore next */
      throw Error("invalid varint encoding");
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads a varint as a signed 64 bit value.
   * @name Reader#int64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as an unsigned 64 bit value.
   * @name Reader#uint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a zig-zag encoded varint as a signed 64 bit value.
   * @name Reader#sint64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a varint as a boolean.
   * @returns {boolean} Value read
   */
  Reader$1.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
  };

  function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
      return (buf[end - 4]
            | buf[end - 3] << 8
            | buf[end - 2] << 16
            | buf[end - 1] << 24) >>> 0;
  }

  /**
   * Reads fixed 32 bits as an unsigned 32 bit integer.
   * @returns {number} Value read
   */
  Reader$1.prototype.fixed32 = function read_fixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4);
  };

  /**
   * Reads fixed 32 bits as a signed 32 bit integer.
   * @returns {number} Value read
   */
  Reader$1.prototype.sfixed32 = function read_sfixed32() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      return readFixed32_end(this.buf, this.pos += 4) | 0;
  };

  /* eslint-disable no-invalid-this */

  function readFixed64(/* this: Reader */) {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);

      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }

  /* eslint-enable no-invalid-this */

  /**
   * Reads fixed 64 bits.
   * @name Reader#fixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads zig-zag encoded fixed 64 bits.
   * @name Reader#sfixed64
   * @function
   * @returns {Long} Value read
   */

  /**
   * Reads a float (32 bit) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader$1.prototype.float = function read_float() {

      /* istanbul ignore if */
      if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);

      var value = util$2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
  };

  /**
   * Reads a double (64 bit float) as a number.
   * @function
   * @returns {number} Value read
   */
  Reader$1.prototype.double = function read_double() {

      /* istanbul ignore if */
      if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);

      var value = util$2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
  };

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @returns {Uint8Array} Value read
   */
  Reader$1.prototype.bytes = function read_bytes() {
      var length = this.uint32(),
          start  = this.pos,
          end    = this.pos + length;

      /* istanbul ignore if */
      if (end > this.len)
          throw indexOutOfRange(this, length);

      this.pos += length;
      if (Array.isArray(this.buf)) // plain array
          return this.buf.slice(start, end);
      return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
          ? new this.buf.constructor(0)
          : this._slice.call(this.buf, start, end);
  };

  /**
   * Reads a string preceeded by its byte length as a varint.
   * @returns {string} Value read
   */
  Reader$1.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
  };

  /**
   * Skips the specified number of bytes if specified, otherwise skips a varint.
   * @param {number} [length] Length if known, otherwise a varint is assumed
   * @returns {Reader} `this`
   */
  Reader$1.prototype.skip = function skip(length) {
      if (typeof length === "number") {
          /* istanbul ignore if */
          if (this.pos + length > this.len)
              throw indexOutOfRange(this, length);
          this.pos += length;
      } else {
          do {
              /* istanbul ignore if */
              if (this.pos >= this.len)
                  throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
      }
      return this;
  };

  /**
   * Skips the next element of the specified wire type.
   * @param {number} wireType Wire type received
   * @returns {Reader} `this`
   */
  Reader$1.prototype.skipType = function(wireType) {
      switch (wireType) {
          case 0:
              this.skip();
              break;
          case 1:
              this.skip(8);
              break;
          case 2:
              this.skip(this.uint32());
              break;
          case 3:
              while ((wireType = this.uint32() & 7) !== 4) {
                  this.skipType(wireType);
              }
              break;
          case 5:
              this.skip(4);
              break;

          /* istanbul ignore next */
          default:
              throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
  };

  Reader$1._configure = function(BufferReader_) {
      BufferReader$1 = BufferReader_;
      Reader$1.create = create();
      BufferReader$1._configure();

      var fn = util$2.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
      util$2.merge(Reader$1.prototype, {

          int64: function read_int64() {
              return readLongVarint.call(this)[fn](false);
          },

          uint64: function read_uint64() {
              return readLongVarint.call(this)[fn](true);
          },

          sint64: function read_sint64() {
              return readLongVarint.call(this).zzDecode()[fn](false);
          },

          fixed64: function read_fixed64() {
              return readFixed64.call(this)[fn](true);
          },

          sfixed64: function read_sfixed64() {
              return readFixed64.call(this)[fn](false);
          }

      });
  };

  var reader_buffer = BufferReader;

  // extends Reader
  var Reader = reader;
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

  var util$1 = requireMinimal();

  /**
   * Constructs a new buffer reader instance.
   * @classdesc Wire format reader using node buffers.
   * @extends Reader
   * @constructor
   * @param {Buffer} buffer Buffer to read from
   */
  function BufferReader(buffer) {
      Reader.call(this, buffer);

      /**
       * Read buffer.
       * @name BufferReader#buf
       * @type {Buffer}
       */
  }

  BufferReader._configure = function () {
      /* istanbul ignore else */
      if (util$1.Buffer)
          BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
  };


  /**
   * @override
   */
  BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32(); // modifies pos
      return this.buf.utf8Slice
          ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
          : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };

  /**
   * Reads a sequence of bytes preceeded by its length as a varint.
   * @name BufferReader#bytes
   * @function
   * @returns {Buffer} Value read
   */

  BufferReader._configure();

  var rpc = {};

  var service = Service;

  var util = requireMinimal();

  // Extends EventEmitter
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

  /**
   * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
   *
   * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
   * @typedef rpc.ServiceMethodCallback
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {Error|null} error Error, if any
   * @param {TRes} [response] Response message
   * @returns {undefined}
   */

  /**
   * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
   * @typedef rpc.ServiceMethod
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   * @type {function}
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
   * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
   */

  /**
   * Constructs a new RPC service instance.
   * @classdesc An RPC service as returned by {@link Service#create}.
   * @exports rpc.Service
   * @extends util.EventEmitter
   * @constructor
   * @param {RPCImpl} rpcImpl RPC implementation
   * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
   * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
   */
  function Service(rpcImpl, requestDelimited, responseDelimited) {

      if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");

      util.EventEmitter.call(this);

      /**
       * RPC implementation. Becomes `null` once the service is ended.
       * @type {RPCImpl|null}
       */
      this.rpcImpl = rpcImpl;

      /**
       * Whether requests are length-delimited.
       * @type {boolean}
       */
      this.requestDelimited = Boolean(requestDelimited);

      /**
       * Whether responses are length-delimited.
       * @type {boolean}
       */
      this.responseDelimited = Boolean(responseDelimited);
  }

  /**
   * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
   * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
   * @param {Constructor<TReq>} requestCtor Request constructor
   * @param {Constructor<TRes>} responseCtor Response constructor
   * @param {TReq|Properties<TReq>} request Request message or plain object
   * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
   * @returns {undefined}
   * @template TReq extends Message<TReq>
   * @template TRes extends Message<TRes>
   */
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

      if (!request)
          throw TypeError("request must be specified");

      var self = this;
      if (!callback)
          return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

      if (!self.rpcImpl) {
          setTimeout(function() { callback(Error("already ended")); }, 0);
          return undefined;
      }

      try {
          return self.rpcImpl(
              method,
              requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
              function rpcCallback(err, response) {

                  if (err) {
                      self.emit("error", err, method);
                      return callback(err);
                  }

                  if (response === null) {
                      self.end(/* endedByRPC */ true);
                      return undefined;
                  }

                  if (!(response instanceof responseCtor)) {
                      try {
                          response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                      } catch (err) {
                          self.emit("error", err, method);
                          return callback(err);
                      }
                  }

                  self.emit("data", response, method);
                  return callback(null, response);
              }
          );
      } catch (err) {
          self.emit("error", err, method);
          setTimeout(function() { callback(err); }, 0);
          return undefined;
      }
  };

  /**
   * Ends this service and emits the `end` event.
   * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
   * @returns {rpc.Service} `this`
   */
  Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
          if (!endedByRPC) // signal end to rpcImpl
              this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
      }
      return this;
  };

  (function (exports) {

  	/**
  	 * Streaming RPC helpers.
  	 * @namespace
  	 */
  	var rpc = exports;

  	/**
  	 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
  	 * @typedef RPCImpl
  	 * @type {function}
  	 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
  	 * @param {Uint8Array} requestData Request data
  	 * @param {RPCImplCallback} callback Callback function
  	 * @returns {undefined}
  	 * @example
  	 * function rpcImpl(method, requestData, callback) {
  	 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
  	 *         throw Error("no such method");
  	 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
  	 *         callback(err, responseData);
  	 *     });
  	 * }
  	 */

  	/**
  	 * Node-style callback as used by {@link RPCImpl}.
  	 * @typedef RPCImplCallback
  	 * @type {function}
  	 * @param {Error|null} error Error, if any, otherwise `null`
  	 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
  	 * @returns {undefined}
  	 */

  	rpc.Service = service; 
  } (rpc));

  var roots = {};

  (function (exports) {
  	var protobuf = exports;

  	/**
  	 * Build type, one of `"full"`, `"light"` or `"minimal"`.
  	 * @name build
  	 * @type {string}
  	 * @const
  	 */
  	protobuf.build = "minimal";

  	// Serialization
  	protobuf.Writer       = writer;
  	protobuf.BufferWriter = writer_buffer;
  	protobuf.Reader       = reader;
  	protobuf.BufferReader = reader_buffer;

  	// Utility
  	protobuf.util         = requireMinimal();
  	protobuf.rpc          = rpc;
  	protobuf.roots        = roots;
  	protobuf.configure    = configure;

  	/* istanbul ignore next */
  	/**
  	 * Reconfigures the library according to the environment.
  	 * @returns {undefined}
  	 */
  	function configure() {
  	    protobuf.util._configure();
  	    protobuf.Writer._configure(protobuf.BufferWriter);
  	    protobuf.Reader._configure(protobuf.BufferReader);
  	}

  	// Set up buffer utility according to the environment
  	configure(); 
  } (indexMinimal));

  var minimal = indexMinimal;

  /*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

  var $protobuf = minimal;

  // Common aliases
  var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

  // Exported root namespace
  var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

  $root.cls = (function() {

      /**
       * Namespace cls.
       * @exports cls
       * @namespace
       */
      var cls = {};

      cls.Log = (function() {

          /**
           * Properties of a Log.
           * @memberof cls
           * @interface ILog
           * @property {number|Long} time Log time
           * @property {Array.<cls.Log.IContent>|null} [contents] Log contents
           */

          /**
           * Constructs a new Log.
           * @memberof cls
           * @classdesc Represents a Log.
           * @implements ILog
           * @constructor
           * @param {cls.ILog=} [properties] Properties to set
           */
          function Log(properties) {
              this.contents = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * Log time.
           * @member {number|Long} time
           * @memberof cls.Log
           * @instance
           */
          Log.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

          /**
           * Log contents.
           * @member {Array.<cls.Log.IContent>} contents
           * @memberof cls.Log
           * @instance
           */
          Log.prototype.contents = $util.emptyArray;

          /**
           * Creates a new Log instance using the specified properties.
           * @function create
           * @memberof cls.Log
           * @static
           * @param {cls.ILog=} [properties] Properties to set
           * @returns {cls.Log} Log instance
           */
          Log.create = function create(properties) {
              return new Log(properties);
          };

          /**
           * Encodes the specified Log message. Does not implicitly {@link cls.Log.verify|verify} messages.
           * @function encode
           * @memberof cls.Log
           * @static
           * @param {cls.ILog} message Log message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Log.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
              if (message.contents != null && message.contents.length)
                  for (var i = 0; i < message.contents.length; ++i)
                      $root.cls.Log.Content.encode(message.contents[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified Log message, length delimited. Does not implicitly {@link cls.Log.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cls.Log
           * @static
           * @param {cls.ILog} message Log message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Log.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Log message from the specified reader or buffer.
           * @function decode
           * @memberof cls.Log
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cls.Log} Log
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Log.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cls.Log();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.time = reader.int64();
                      break;
                  case 2:
                      if (!(message.contents && message.contents.length))
                          message.contents = [];
                      message.contents.push($root.cls.Log.Content.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              if (!message.hasOwnProperty("time"))
                  throw $util.ProtocolError("missing required 'time'", { instance: message });
              return message;
          };

          /**
           * Decodes a Log message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cls.Log
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cls.Log} Log
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Log.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Log message.
           * @function verify
           * @memberof cls.Log
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Log.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                  return "time: integer|Long expected";
              if (message.contents != null && message.hasOwnProperty("contents")) {
                  if (!Array.isArray(message.contents))
                      return "contents: array expected";
                  for (var i = 0; i < message.contents.length; ++i) {
                      var error = $root.cls.Log.Content.verify(message.contents[i]);
                      if (error)
                          return "contents." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a Log message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cls.Log
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cls.Log} Log
           */
          Log.fromObject = function fromObject(object) {
              if (object instanceof $root.cls.Log)
                  return object;
              var message = new $root.cls.Log();
              if (object.time != null)
                  if ($util.Long)
                      (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                  else if (typeof object.time === "string")
                      message.time = parseInt(object.time, 10);
                  else if (typeof object.time === "number")
                      message.time = object.time;
                  else if (typeof object.time === "object")
                      message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
              if (object.contents) {
                  if (!Array.isArray(object.contents))
                      throw TypeError(".cls.Log.contents: array expected");
                  message.contents = [];
                  for (var i = 0; i < object.contents.length; ++i) {
                      if (typeof object.contents[i] !== "object")
                          throw TypeError(".cls.Log.contents: object expected");
                      message.contents[i] = $root.cls.Log.Content.fromObject(object.contents[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a Log message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cls.Log
           * @static
           * @param {cls.Log} message Log
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Log.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.contents = [];
              if (options.defaults)
                  if ($util.Long) {
                      var long = new $util.Long(0, 0, false);
                      object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                      object.time = options.longs === String ? "0" : 0;
              if (message.time != null && message.hasOwnProperty("time"))
                  if (typeof message.time === "number")
                      object.time = options.longs === String ? String(message.time) : message.time;
                  else
                      object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
              if (message.contents && message.contents.length) {
                  object.contents = [];
                  for (var j = 0; j < message.contents.length; ++j)
                      object.contents[j] = $root.cls.Log.Content.toObject(message.contents[j], options);
              }
              return object;
          };

          /**
           * Converts this Log to JSON.
           * @function toJSON
           * @memberof cls.Log
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Log.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          /**
           * Gets the default type url for Log
           * @function getTypeUrl
           * @memberof cls.Log
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/cls.Log";
          };

          Log.Content = (function() {

              /**
               * Properties of a Content.
               * @memberof cls.Log
               * @interface IContent
               * @property {string} key Content key
               * @property {string} value Content value
               */

              /**
               * Constructs a new Content.
               * @memberof cls.Log
               * @classdesc Represents a Content.
               * @implements IContent
               * @constructor
               * @param {cls.Log.IContent=} [properties] Properties to set
               */
              function Content(properties) {
                  if (properties)
                      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                          if (properties[keys[i]] != null)
                              this[keys[i]] = properties[keys[i]];
              }

              /**
               * Content key.
               * @member {string} key
               * @memberof cls.Log.Content
               * @instance
               */
              Content.prototype.key = "";

              /**
               * Content value.
               * @member {string} value
               * @memberof cls.Log.Content
               * @instance
               */
              Content.prototype.value = "";

              /**
               * Creates a new Content instance using the specified properties.
               * @function create
               * @memberof cls.Log.Content
               * @static
               * @param {cls.Log.IContent=} [properties] Properties to set
               * @returns {cls.Log.Content} Content instance
               */
              Content.create = function create(properties) {
                  return new Content(properties);
              };

              /**
               * Encodes the specified Content message. Does not implicitly {@link cls.Log.Content.verify|verify} messages.
               * @function encode
               * @memberof cls.Log.Content
               * @static
               * @param {cls.Log.IContent} message Content message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Content.encode = function encode(message, writer) {
                  if (!writer)
                      writer = $Writer.create();
                  writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                  return writer;
              };

              /**
               * Encodes the specified Content message, length delimited. Does not implicitly {@link cls.Log.Content.verify|verify} messages.
               * @function encodeDelimited
               * @memberof cls.Log.Content
               * @static
               * @param {cls.Log.IContent} message Content message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Content.encodeDelimited = function encodeDelimited(message, writer) {
                  return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a Content message from the specified reader or buffer.
               * @function decode
               * @memberof cls.Log.Content
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {cls.Log.Content} Content
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Content.decode = function decode(reader, length) {
                  if (!(reader instanceof $Reader))
                      reader = $Reader.create(reader);
                  var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cls.Log.Content();
                  while (reader.pos < end) {
                      var tag = reader.uint32();
                      switch (tag >>> 3) {
                      case 1:
                          message.key = reader.string();
                          break;
                      case 2:
                          message.value = reader.string();
                          break;
                      default:
                          reader.skipType(tag & 7);
                          break;
                      }
                  }
                  if (!message.hasOwnProperty("key"))
                      throw $util.ProtocolError("missing required 'key'", { instance: message });
                  if (!message.hasOwnProperty("value"))
                      throw $util.ProtocolError("missing required 'value'", { instance: message });
                  return message;
              };

              /**
               * Decodes a Content message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof cls.Log.Content
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {cls.Log.Content} Content
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Content.decodeDelimited = function decodeDelimited(reader) {
                  if (!(reader instanceof $Reader))
                      reader = new $Reader(reader);
                  return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a Content message.
               * @function verify
               * @memberof cls.Log.Content
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Content.verify = function verify(message) {
                  if (typeof message !== "object" || message === null)
                      return "object expected";
                  if (!$util.isString(message.key))
                      return "key: string expected";
                  if (!$util.isString(message.value))
                      return "value: string expected";
                  return null;
              };

              /**
               * Creates a Content message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof cls.Log.Content
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {cls.Log.Content} Content
               */
              Content.fromObject = function fromObject(object) {
                  if (object instanceof $root.cls.Log.Content)
                      return object;
                  var message = new $root.cls.Log.Content();
                  if (object.key != null)
                      message.key = String(object.key);
                  if (object.value != null)
                      message.value = String(object.value);
                  return message;
              };

              /**
               * Creates a plain object from a Content message. Also converts values to other types if specified.
               * @function toObject
               * @memberof cls.Log.Content
               * @static
               * @param {cls.Log.Content} message Content
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Content.toObject = function toObject(message, options) {
                  if (!options)
                      options = {};
                  var object = {};
                  if (options.defaults) {
                      object.key = "";
                      object.value = "";
                  }
                  if (message.key != null && message.hasOwnProperty("key"))
                      object.key = message.key;
                  if (message.value != null && message.hasOwnProperty("value"))
                      object.value = message.value;
                  return object;
              };

              /**
               * Converts this Content to JSON.
               * @function toJSON
               * @memberof cls.Log.Content
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Content.prototype.toJSON = function toJSON() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              };

              /**
               * Gets the default type url for Content
               * @function getTypeUrl
               * @memberof cls.Log.Content
               * @static
               * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
               * @returns {string} The default type url
               */
              Content.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                  if (typeUrlPrefix === undefined) {
                      typeUrlPrefix = "type.googleapis.com";
                  }
                  return typeUrlPrefix + "/cls.Log.Content";
              };

              return Content;
          })();

          return Log;
      })();

      cls.LogTag = (function() {

          /**
           * Properties of a LogTag.
           * @memberof cls
           * @interface ILogTag
           * @property {string} key LogTag key
           * @property {string} value LogTag value
           */

          /**
           * Constructs a new LogTag.
           * @memberof cls
           * @classdesc Represents a LogTag.
           * @implements ILogTag
           * @constructor
           * @param {cls.ILogTag=} [properties] Properties to set
           */
          function LogTag(properties) {
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * LogTag key.
           * @member {string} key
           * @memberof cls.LogTag
           * @instance
           */
          LogTag.prototype.key = "";

          /**
           * LogTag value.
           * @member {string} value
           * @memberof cls.LogTag
           * @instance
           */
          LogTag.prototype.value = "";

          /**
           * Creates a new LogTag instance using the specified properties.
           * @function create
           * @memberof cls.LogTag
           * @static
           * @param {cls.ILogTag=} [properties] Properties to set
           * @returns {cls.LogTag} LogTag instance
           */
          LogTag.create = function create(properties) {
              return new LogTag(properties);
          };

          /**
           * Encodes the specified LogTag message. Does not implicitly {@link cls.LogTag.verify|verify} messages.
           * @function encode
           * @memberof cls.LogTag
           * @static
           * @param {cls.ILogTag} message LogTag message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogTag.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
              writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
              return writer;
          };

          /**
           * Encodes the specified LogTag message, length delimited. Does not implicitly {@link cls.LogTag.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cls.LogTag
           * @static
           * @param {cls.ILogTag} message LogTag message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogTag.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LogTag message from the specified reader or buffer.
           * @function decode
           * @memberof cls.LogTag
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cls.LogTag} LogTag
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogTag.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cls.LogTag();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      message.key = reader.string();
                      break;
                  case 2:
                      message.value = reader.string();
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              if (!message.hasOwnProperty("key"))
                  throw $util.ProtocolError("missing required 'key'", { instance: message });
              if (!message.hasOwnProperty("value"))
                  throw $util.ProtocolError("missing required 'value'", { instance: message });
              return message;
          };

          /**
           * Decodes a LogTag message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cls.LogTag
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cls.LogTag} LogTag
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogTag.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LogTag message.
           * @function verify
           * @memberof cls.LogTag
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LogTag.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (!$util.isString(message.key))
                  return "key: string expected";
              if (!$util.isString(message.value))
                  return "value: string expected";
              return null;
          };

          /**
           * Creates a LogTag message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cls.LogTag
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cls.LogTag} LogTag
           */
          LogTag.fromObject = function fromObject(object) {
              if (object instanceof $root.cls.LogTag)
                  return object;
              var message = new $root.cls.LogTag();
              if (object.key != null)
                  message.key = String(object.key);
              if (object.value != null)
                  message.value = String(object.value);
              return message;
          };

          /**
           * Creates a plain object from a LogTag message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cls.LogTag
           * @static
           * @param {cls.LogTag} message LogTag
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LogTag.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.defaults) {
                  object.key = "";
                  object.value = "";
              }
              if (message.key != null && message.hasOwnProperty("key"))
                  object.key = message.key;
              if (message.value != null && message.hasOwnProperty("value"))
                  object.value = message.value;
              return object;
          };

          /**
           * Converts this LogTag to JSON.
           * @function toJSON
           * @memberof cls.LogTag
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LogTag.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          /**
           * Gets the default type url for LogTag
           * @function getTypeUrl
           * @memberof cls.LogTag
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          LogTag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/cls.LogTag";
          };

          return LogTag;
      })();

      cls.LogGroup = (function() {

          /**
           * Properties of a LogGroup.
           * @memberof cls
           * @interface ILogGroup
           * @property {Array.<cls.ILog>|null} [logs] LogGroup logs
           * @property {string|null} [contextFlow] LogGroup contextFlow
           * @property {string|null} [filename] LogGroup filename
           * @property {string|null} [source] LogGroup source
           * @property {Array.<cls.ILogTag>|null} [logTags] LogGroup logTags
           */

          /**
           * Constructs a new LogGroup.
           * @memberof cls
           * @classdesc Represents a LogGroup.
           * @implements ILogGroup
           * @constructor
           * @param {cls.ILogGroup=} [properties] Properties to set
           */
          function LogGroup(properties) {
              this.logs = [];
              this.logTags = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * LogGroup logs.
           * @member {Array.<cls.ILog>} logs
           * @memberof cls.LogGroup
           * @instance
           */
          LogGroup.prototype.logs = $util.emptyArray;

          /**
           * LogGroup contextFlow.
           * @member {string} contextFlow
           * @memberof cls.LogGroup
           * @instance
           */
          LogGroup.prototype.contextFlow = "";

          /**
           * LogGroup filename.
           * @member {string} filename
           * @memberof cls.LogGroup
           * @instance
           */
          LogGroup.prototype.filename = "";

          /**
           * LogGroup source.
           * @member {string} source
           * @memberof cls.LogGroup
           * @instance
           */
          LogGroup.prototype.source = "";

          /**
           * LogGroup logTags.
           * @member {Array.<cls.ILogTag>} logTags
           * @memberof cls.LogGroup
           * @instance
           */
          LogGroup.prototype.logTags = $util.emptyArray;

          /**
           * Creates a new LogGroup instance using the specified properties.
           * @function create
           * @memberof cls.LogGroup
           * @static
           * @param {cls.ILogGroup=} [properties] Properties to set
           * @returns {cls.LogGroup} LogGroup instance
           */
          LogGroup.create = function create(properties) {
              return new LogGroup(properties);
          };

          /**
           * Encodes the specified LogGroup message. Does not implicitly {@link cls.LogGroup.verify|verify} messages.
           * @function encode
           * @memberof cls.LogGroup
           * @static
           * @param {cls.ILogGroup} message LogGroup message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogGroup.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.logs != null && message.logs.length)
                  for (var i = 0; i < message.logs.length; ++i)
                      $root.cls.Log.encode(message.logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              if (message.contextFlow != null && Object.hasOwnProperty.call(message, "contextFlow"))
                  writer.uint32(/* id 2, wireType 2 =*/18).string(message.contextFlow);
              if (message.filename != null && Object.hasOwnProperty.call(message, "filename"))
                  writer.uint32(/* id 3, wireType 2 =*/26).string(message.filename);
              if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                  writer.uint32(/* id 4, wireType 2 =*/34).string(message.source);
              if (message.logTags != null && message.logTags.length)
                  for (var i = 0; i < message.logTags.length; ++i)
                      $root.cls.LogTag.encode(message.logTags[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified LogGroup message, length delimited. Does not implicitly {@link cls.LogGroup.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cls.LogGroup
           * @static
           * @param {cls.ILogGroup} message LogGroup message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogGroup.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LogGroup message from the specified reader or buffer.
           * @function decode
           * @memberof cls.LogGroup
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cls.LogGroup} LogGroup
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogGroup.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cls.LogGroup();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.logs && message.logs.length))
                          message.logs = [];
                      message.logs.push($root.cls.Log.decode(reader, reader.uint32()));
                      break;
                  case 2:
                      message.contextFlow = reader.string();
                      break;
                  case 3:
                      message.filename = reader.string();
                      break;
                  case 4:
                      message.source = reader.string();
                      break;
                  case 5:
                      if (!(message.logTags && message.logTags.length))
                          message.logTags = [];
                      message.logTags.push($root.cls.LogTag.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a LogGroup message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cls.LogGroup
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cls.LogGroup} LogGroup
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogGroup.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LogGroup message.
           * @function verify
           * @memberof cls.LogGroup
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LogGroup.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.logs != null && message.hasOwnProperty("logs")) {
                  if (!Array.isArray(message.logs))
                      return "logs: array expected";
                  for (var i = 0; i < message.logs.length; ++i) {
                      var error = $root.cls.Log.verify(message.logs[i]);
                      if (error)
                          return "logs." + error;
                  }
              }
              if (message.contextFlow != null && message.hasOwnProperty("contextFlow"))
                  if (!$util.isString(message.contextFlow))
                      return "contextFlow: string expected";
              if (message.filename != null && message.hasOwnProperty("filename"))
                  if (!$util.isString(message.filename))
                      return "filename: string expected";
              if (message.source != null && message.hasOwnProperty("source"))
                  if (!$util.isString(message.source))
                      return "source: string expected";
              if (message.logTags != null && message.hasOwnProperty("logTags")) {
                  if (!Array.isArray(message.logTags))
                      return "logTags: array expected";
                  for (var i = 0; i < message.logTags.length; ++i) {
                      var error = $root.cls.LogTag.verify(message.logTags[i]);
                      if (error)
                          return "logTags." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a LogGroup message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cls.LogGroup
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cls.LogGroup} LogGroup
           */
          LogGroup.fromObject = function fromObject(object) {
              if (object instanceof $root.cls.LogGroup)
                  return object;
              var message = new $root.cls.LogGroup();
              if (object.logs) {
                  if (!Array.isArray(object.logs))
                      throw TypeError(".cls.LogGroup.logs: array expected");
                  message.logs = [];
                  for (var i = 0; i < object.logs.length; ++i) {
                      if (typeof object.logs[i] !== "object")
                          throw TypeError(".cls.LogGroup.logs: object expected");
                      message.logs[i] = $root.cls.Log.fromObject(object.logs[i]);
                  }
              }
              if (object.contextFlow != null)
                  message.contextFlow = String(object.contextFlow);
              if (object.filename != null)
                  message.filename = String(object.filename);
              if (object.source != null)
                  message.source = String(object.source);
              if (object.logTags) {
                  if (!Array.isArray(object.logTags))
                      throw TypeError(".cls.LogGroup.logTags: array expected");
                  message.logTags = [];
                  for (var i = 0; i < object.logTags.length; ++i) {
                      if (typeof object.logTags[i] !== "object")
                          throw TypeError(".cls.LogGroup.logTags: object expected");
                      message.logTags[i] = $root.cls.LogTag.fromObject(object.logTags[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a LogGroup message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cls.LogGroup
           * @static
           * @param {cls.LogGroup} message LogGroup
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LogGroup.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults) {
                  object.logs = [];
                  object.logTags = [];
              }
              if (options.defaults) {
                  object.contextFlow = "";
                  object.filename = "";
                  object.source = "";
              }
              if (message.logs && message.logs.length) {
                  object.logs = [];
                  for (var j = 0; j < message.logs.length; ++j)
                      object.logs[j] = $root.cls.Log.toObject(message.logs[j], options);
              }
              if (message.contextFlow != null && message.hasOwnProperty("contextFlow"))
                  object.contextFlow = message.contextFlow;
              if (message.filename != null && message.hasOwnProperty("filename"))
                  object.filename = message.filename;
              if (message.source != null && message.hasOwnProperty("source"))
                  object.source = message.source;
              if (message.logTags && message.logTags.length) {
                  object.logTags = [];
                  for (var j = 0; j < message.logTags.length; ++j)
                      object.logTags[j] = $root.cls.LogTag.toObject(message.logTags[j], options);
              }
              return object;
          };

          /**
           * Converts this LogGroup to JSON.
           * @function toJSON
           * @memberof cls.LogGroup
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LogGroup.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          /**
           * Gets the default type url for LogGroup
           * @function getTypeUrl
           * @memberof cls.LogGroup
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          LogGroup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/cls.LogGroup";
          };

          return LogGroup;
      })();

      cls.LogGroupList = (function() {

          /**
           * Properties of a LogGroupList.
           * @memberof cls
           * @interface ILogGroupList
           * @property {Array.<cls.ILogGroup>|null} [logGroupList] LogGroupList logGroupList
           */

          /**
           * Constructs a new LogGroupList.
           * @memberof cls
           * @classdesc Represents a LogGroupList.
           * @implements ILogGroupList
           * @constructor
           * @param {cls.ILogGroupList=} [properties] Properties to set
           */
          function LogGroupList(properties) {
              this.logGroupList = [];
              if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      if (properties[keys[i]] != null)
                          this[keys[i]] = properties[keys[i]];
          }

          /**
           * LogGroupList logGroupList.
           * @member {Array.<cls.ILogGroup>} logGroupList
           * @memberof cls.LogGroupList
           * @instance
           */
          LogGroupList.prototype.logGroupList = $util.emptyArray;

          /**
           * Creates a new LogGroupList instance using the specified properties.
           * @function create
           * @memberof cls.LogGroupList
           * @static
           * @param {cls.ILogGroupList=} [properties] Properties to set
           * @returns {cls.LogGroupList} LogGroupList instance
           */
          LogGroupList.create = function create(properties) {
              return new LogGroupList(properties);
          };

          /**
           * Encodes the specified LogGroupList message. Does not implicitly {@link cls.LogGroupList.verify|verify} messages.
           * @function encode
           * @memberof cls.LogGroupList
           * @static
           * @param {cls.ILogGroupList} message LogGroupList message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogGroupList.encode = function encode(message, writer) {
              if (!writer)
                  writer = $Writer.create();
              if (message.logGroupList != null && message.logGroupList.length)
                  for (var i = 0; i < message.logGroupList.length; ++i)
                      $root.cls.LogGroup.encode(message.logGroupList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
              return writer;
          };

          /**
           * Encodes the specified LogGroupList message, length delimited. Does not implicitly {@link cls.LogGroupList.verify|verify} messages.
           * @function encodeDelimited
           * @memberof cls.LogGroupList
           * @static
           * @param {cls.ILogGroupList} message LogGroupList message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LogGroupList.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LogGroupList message from the specified reader or buffer.
           * @function decode
           * @memberof cls.LogGroupList
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {cls.LogGroupList} LogGroupList
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogGroupList.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
              var end = length === undefined ? reader.len : reader.pos + length, message = new $root.cls.LogGroupList();
              while (reader.pos < end) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                  case 1:
                      if (!(message.logGroupList && message.logGroupList.length))
                          message.logGroupList = [];
                      message.logGroupList.push($root.cls.LogGroup.decode(reader, reader.uint32()));
                      break;
                  default:
                      reader.skipType(tag & 7);
                      break;
                  }
              }
              return message;
          };

          /**
           * Decodes a LogGroupList message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof cls.LogGroupList
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {cls.LogGroupList} LogGroupList
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LogGroupList.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                  reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LogGroupList message.
           * @function verify
           * @memberof cls.LogGroupList
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LogGroupList.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                  return "object expected";
              if (message.logGroupList != null && message.hasOwnProperty("logGroupList")) {
                  if (!Array.isArray(message.logGroupList))
                      return "logGroupList: array expected";
                  for (var i = 0; i < message.logGroupList.length; ++i) {
                      var error = $root.cls.LogGroup.verify(message.logGroupList[i]);
                      if (error)
                          return "logGroupList." + error;
                  }
              }
              return null;
          };

          /**
           * Creates a LogGroupList message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof cls.LogGroupList
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {cls.LogGroupList} LogGroupList
           */
          LogGroupList.fromObject = function fromObject(object) {
              if (object instanceof $root.cls.LogGroupList)
                  return object;
              var message = new $root.cls.LogGroupList();
              if (object.logGroupList) {
                  if (!Array.isArray(object.logGroupList))
                      throw TypeError(".cls.LogGroupList.logGroupList: array expected");
                  message.logGroupList = [];
                  for (var i = 0; i < object.logGroupList.length; ++i) {
                      if (typeof object.logGroupList[i] !== "object")
                          throw TypeError(".cls.LogGroupList.logGroupList: object expected");
                      message.logGroupList[i] = $root.cls.LogGroup.fromObject(object.logGroupList[i]);
                  }
              }
              return message;
          };

          /**
           * Creates a plain object from a LogGroupList message. Also converts values to other types if specified.
           * @function toObject
           * @memberof cls.LogGroupList
           * @static
           * @param {cls.LogGroupList} message LogGroupList
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LogGroupList.toObject = function toObject(message, options) {
              if (!options)
                  options = {};
              var object = {};
              if (options.arrays || options.defaults)
                  object.logGroupList = [];
              if (message.logGroupList && message.logGroupList.length) {
                  object.logGroupList = [];
                  for (var j = 0; j < message.logGroupList.length; ++j)
                      object.logGroupList[j] = $root.cls.LogGroup.toObject(message.logGroupList[j], options);
              }
              return object;
          };

          /**
           * Converts this LogGroupList to JSON.
           * @function toJSON
           * @memberof cls.LogGroupList
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LogGroupList.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };

          /**
           * Gets the default type url for LogGroupList
           * @function getTypeUrl
           * @memberof cls.LogGroupList
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          LogGroupList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/cls.LogGroupList";
          };

          return LogGroupList;
      })();

      return cls;
  })();

  var cls = $root;

  // const lz4 = require('lz4');
  // const { lz4, CBuffer } = require('../../lib/lz4');
  // const lz4 = require('lz4js');
  var handleLogs = {
    formatLogGroup: function formatLogGroup(logs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var logGroup = new cls.cls.LogGroup();
      if (options.filename) {
        logGroup.filename = options.filename;
      }
      if (options.source) {
        logGroup.source = options.source;
      }
      logs.forEach(function (log) {
        var logItem = new cls.cls.Log();
        logItem.time = log.time;
        Object.keys(log.contents).forEach(function (key) {
          var o = log.contents[key];
          var value = isString$1(o) ? o : JSON.stringify(o);
          logItem.contents.push(new cls.cls.Log.Content({
            key: key,
            value: value
          }));
        });
        logGroup.logs.push(logItem);
      });
      // 校验日志格式是否正确
      var errMsg = cls.cls.LogGroup.verify(logGroup);
      if (errMsg) {
        throw new ClsSDKError("log format is incorrect: ".concat(errMsg));
      }
      return logGroup;
    },
    log2Buffer: function log2Buffer(logs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var clsList = new cls.cls.LogGroupList();
      var logGroup = handleLogs.formatLogGroup(logs, options);
      clsList.logGroupList.push(logGroup);
      // 将本地日志转换为 pb 格式
      var buffer = cls.cls.LogGroupList.encode(clsList).finish();
      return buffer;
      // const buffer = Buffer.from(JSON.stringify(logGroupList))
      // const input = new CBuffer(this.toArrayBuffer(buffer));
      // const maxOutputSize = lz4.encodeBound(input.length);
      // const output = new CBuffer(maxOutputSize);
      // const outputSize = lz4.encodeBlock(input, output);
      // let lz4Buffer = output.slice(0, outputSize);
      // lz4Buffer = btoa(encodeURIComponent(lz4Buffer));
      // // 将 pb 格式的日志进行 lz4 压缩
      // let lz4Buffer = Buffer.alloc(lz4.encodeBound(buffer.length));
      // const compressedSize = lz4.encodeBlock(buffer, lz4Buffer);
      // lz4Buffer = lz4Buffer.slice(0, compressedSize);
      // this.write(`./demo/proto_node.lz4`, lz4Buffer);
      // let uncompressed = Buffer.from(buffer.length);
      // const uncompressedSize = lz4.decodeBlock(lz4Buffer, uncompressed)
      // uncompressed = uncompressed.slice(0, uncompressedSize)
      // let lz4Buffer = lz4.compress(buffer, buffer.length);
      // lz4Buffer = this.toBuffer(lz4Buffer);
      // this.write(`./demo/proto_js.lz4`, lz4Buffer);
      // const depress = lz4.decompress(lz4Buffer);
      // this.write(`./demo/depress_js`, depress);
      // return lz4Buffer;
    },
    log2JSON: function log2JSON(logs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var source = options.source,
        filename = options.filename;
      var logGroup = _objectSpread2(_objectSpread2(_objectSpread2({}, filename && {
        filename: filename
      }), source && {
        source: source
      }), {}, {
        logs: logs.map(function (log) {
          var formatContents = log.contents;
          Object.keys(log.contents).forEach(function (key) {
            try {
              if (typeof formatContents[key] !== 'undefined') {
                formatContents[key] = formatContents[key].toString();
              } else {
                formatContents[key] = '';
              }
            } catch (error) {
              throw new ClsSDKError("log format is incorrect: ".concat(error.message));
            }
          });
          return {
            contents: log.contents,
            time: log.time
          };
        })
      });
      return JSON.stringify(logGroup);
    },
    log2ZhiyanJSON: function log2ZhiyanJSON(logs, topicId) {
      var logGroup = {
        topic: topicId,
        data: logs.map(function (log) {
          var formatContents = log.contents;
          Object.keys(log.contents).forEach(function (key) {
            try {
              if (typeof formatContents[key] !== 'undefined') {
                formatContents[key] = formatContents[key].toString();
              } else {
                formatContents[key] = '';
              }
            } catch (error) {
              throw new ClsSDKError("log format is incorrect: ".concat(error.message));
            }
          });
          return {
            fields: log.contents,
            timestamp: log.time
          };
        })
      };
      return JSON.stringify(logGroup);
    } // toArrayBuffer(buf) {
    //   const ab = new ArrayBuffer(buf.length);
    //   const view = new Uint8Array(ab);
    //   for (let i = 0; i < buf.length; ++i) {
    //     view[i] = buf[i];
    //   }
    //   return ab;
    // },
    // toBuffer(ab) {
    //   const buf = Buffer.alloc(ab.byteLength);
    //   const view = new Uint8Array(ab);
    //   for (let i = 0; i < buf.length; ++i) {
    //     buf[i] = view[i];
    //   }
    //   return buf;
    // },
  };

  /**
   * @class HttpConnection
   * @internal
   */
  var HttpConnection = /*#__PURE__*/function () {
    function HttpConnection(options) {
      var _options$autoFillSour, _options$api;
      _classCallCheck(this, HttpConnection);
      /**
       * 临时签名缓存
       */
      _defineProperty(this, "stsCache", []);
      _defineProperty(this, "CLS_HOST", 'cls.tencentcs.com');
      _defineProperty(this, "cancelRequestSource", axios$1.CancelToken.source());
      _defineProperty(this, "retryTimes", 3);
      // 默认重试次数
      _defineProperty(this, "topicId", '');
      _defineProperty(this, "autoFillSourceIp", false);
      _defineProperty(this, "api", {
        anony: '/tracklog',
        auth: '/structuredlog'
      });
      /**
       * 永久密钥 SecretId、SecretKey
       */
      _defineProperty(this, "credential", undefined);
      /**
       * 获取签名的回调方法
       */
      _defineProperty(this, "getAuthorization", undefined);
      _defineProperty(this, "ins", undefined);
      this.topicId = options.topicId;
      this.credential = options.credential;
      this.getAuthorization = options.getAuthorization;
      this.autoFillSourceIp = (_options$autoFillSour = options.autoFillSourceIp) !== null && _options$autoFillSour !== void 0 ? _options$autoFillSour : true;
      this.api = (_options$api = options.api) !== null && _options$api !== void 0 ? _options$api : {
        anony: '/tracklog',
        auth: '/structuredlog'
      };
      this.ins = this.getIns(options);
    }
    _createClass(HttpConnection, [{
      key: "needAuth",
      get:
      /**
       * 需要鉴权
       */
      function get() {
        return isNotEmpty(this.credential) || isNotEmpty(this.getAuthorization);
      }
    }, {
      key: "getIns",
      value: function getIns(options) {
        var _options$retry, _options$protocol;
        this.retryTimes = (_options$retry = options.retry) !== null && _options$retry !== void 0 ? _options$retry : 3;
        var protocol = (_options$protocol = options.protocol) !== null && _options$protocol !== void 0 ? _options$protocol : 'https';
        if (!isNotEmpty(options.region) && !isNotEmpty(options.endpoint)) {
          throw new ClsSDKError('region or endpoint are required');
        }
        var host = "".concat(options.region, ".").concat(this.CLS_HOST);
        if (options.region) {
          host = "".concat(options.region, ".").concat(this.CLS_HOST);
        } else if (options.endpoint) {
          host = options.endpoint;
        }
        var headers = this.getCommonHeaders(host);
        var axiosConfig = {
          baseURL: "".concat(protocol, "://").concat(host),
          headers: headers,
          timeout: 5000,
          cancelToken: this.cancelRequestSource.token,
          params: {
            topic_id: this.topicId
          }
        };
        if (options.agent) {
          var _options$agent = options.agent,
            httpAgent = _options$agent.httpAgent,
            httpsAgent = _options$agent.httpsAgent,
            proxy = _options$agent.proxy;
          protocol = options.agent.protocol || protocol;
          httpAgent && (axiosConfig.httpAgent = httpAgent);
          httpsAgent && (axiosConfig.httpsAgent = httpsAgent);
          proxy && (axiosConfig.proxy = proxy);
          options.proxy && (axiosConfig.proxy = proxy); // 直接挂载的代理变量优先级高于函数中获取的代理变量
        }
        var axiosIns = axios$1.create(axiosConfig);
        this.generateCancelToken(axiosIns);
        this.initMethods(axiosIns);
        this.setReqInterceptors(axiosIns);
        this.setResInterceptors(axiosIns);
        return axiosIns;
      }
    }, {
      key: "getCommonHeaders",
      value: function getCommonHeaders(host) {
        var headers = _objectSpread2({}, this.autoFillSourceIp && {
          'x-cls-add-source': '1'
        });
        if (this.needAuth) {
          headers['Content-Type'] = 'application/x-protobuf';
          headers['Host'] = host;
        } else {
          headers['Content-Type'] = 'application/json';
        }
        return headers;
      }
    }, {
      key: "initMethods",
      value: function initMethods(httpIns) {
        var _this = this;
        ['PUT', 'POST', 'GET', 'DELETE', 'HEAD'].forEach(function (method) {
          _this[method.toLowerCase()] = function (config) {
            var url = config.url;
            if (!url) throw new Error('url 不能为空');
            return httpIns(_objectSpread2({
              method: method
            }, config));
          };
        });
      }
      /**
       * 修改请求适配器
       * @param adapter
       */
    }, {
      key: "changeAdapter",
      value: function changeAdapter(adapter) {
        if (!this.ins) {
          throw new ClsSDKError('HttpConnection is not initialized');
        }
        this.ins.defaults.adapter = adapter;
      }
      /**
       * 取消当前所有请求
       */
    }, {
      key: "cancelRequest",
      value: function cancelRequest() {
        if (!this.ins) {
          throw new ClsSDKError('HttpConnection is not initialized');
        }
        this.cancelRequestSource.cancel('cancel');
        this.generateCancelToken(this.ins);
      }
      /**
       * 通用请求拦截器
       */
    }, {
      key: "setReqInterceptors",
      value: function setReqInterceptors(httpIns) {
        var _this2 = this;
        httpIns.interceptors.request.use( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config) {
            var headers, params, url, method, authData;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  headers = config.headers, params = config.params, url = config.url, method = config.method;
                  _context.next = 3;
                  return _this2._getAuthorization({
                    method: method,
                    headers: headers,
                    query: params,
                    api: (url === null || url === void 0 ? void 0 : url.replace(/^\//g, '')) || ''
                  });
                case 3:
                  authData = _context.sent;
                  if (authData) {
                    config.headers.Authorization = authData.Authorization;
                    authData.SecurityToken && (config.headers['x-cls-token'] = authData.SecurityToken);
                  }
                  return _context.abrupt("return", config);
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }(), function (error) {
          return Promise.resolve(error);
        });
      }
      /**
       * 通用响应拦截器
       */
    }, {
      key: "setResInterceptors",
      value: function setResInterceptors(httpIns) {
        var _this3 = this;
        httpIns.interceptors.response.use(function (response) {
          systemClock.handleOffset(response.headers.date);
          return response;
        }, /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(error) {
            var _error, _error$response, status, headers, config, data;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  if (!axios$1.isCancel(error)) {
                    _context2.next = 3;
                    break;
                  }
                  _error = {
                    code: 'canceled',
                    message: 'Operation canceled by the user.'
                  };
                  throw new ClsSDKError(_error);
                case 3:
                  if (!error.config.retryTimes) {
                    error.config.retryTimes = 0;
                  }
                  if (!error.response) {
                    _context2.next = 15;
                    break;
                  }
                  systemClock.handleOffset(error.response.headers.date);
                  // 请求已发出，但服务器响应的状态码不在 2xx 范围内
                  _error$response = error.response, status = _error$response.status, headers = _error$response.headers, config = _error$response.config, data = _error$response.data;
                  if (!(status !== 413 && config.retryTimes < _this3.retryTimes)) {
                    _context2.next = 14;
                    break;
                  }
                  config.retryTimes++;
                  // TODO: 需要校准时间
                  _context2.next = 11;
                  return wait(1000);
                case 11:
                  return _context2.abrupt("return", httpIns(config));
                case 14:
                  throw new ClsSDKError({
                    status: status,
                    headers: headers,
                    code: data.errorcode,
                    message: data.errormessage
                  });
                case 15:
                  throw new ClsSDKError({
                    code: error.code || error.message,
                    message: error.message
                  });
                case 16:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          return function (_x2) {
            return _ref2.apply(this, arguments);
          };
        }());
      }
      /**
       * 上传日志
       * @param logs
       * @returns  AxiosPromise
       */
    }, {
      key: "putLogs",
      value: function putLogs(logs) {
        if (!this.ins) {
          throw new ClsSDKError('HttpConnection is not initialized');
        }
        var authApi = typeof this.api === 'string' ? this.api : this.api.auth;
        var anonyApi = typeof this.api === 'string' ? this.api : this.api.anony;
        if (this.needAuth) {
          var data = handleLogs.log2Buffer(logs);
          return this.post({
            url: authApi,
            data: data
          });
        } else {
          var _data = handleLogs.log2JSON(logs);
          return this.post({
            url: anonyApi,
            data: _data
          });
        }
      }
    }, {
      key: "putZhiyanLogs",
      value: function putZhiyanLogs(logs) {
        if (!this.ins) {
          throw new ClsSDKError('HttpConnection is not initialized');
        }
        var data = handleLogs.log2ZhiyanJSON(logs, this.topicId);
        var anonyApi = typeof this.api === 'string' ? this.api : this.api.anony;
        return this.post({
          url: anonyApi,
          data: data
        });
      }
      /**
       * 生成取消请求的token种子
       * @param ins
       */
    }, {
      key: "generateCancelToken",
      value: function generateCancelToken(ins) {
        this.cancelRequestSource = axios$1.CancelToken.source();
        ins.defaults.cancelToken = this.cancelRequestSource.token;
      }
    }, {
      key: "_getAuthorization",
      value: function () {
        var _getAuthorization2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
          var _this4 = this,
            _stsData;
          var headers, stsData, authData;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                headers = HttpConnection.formatHeader(params.headers); // 有永久密钥则直接签名
                if (!this.credential) {
                  _context3.next = 3;
                  break;
                }
                return _context3.abrupt("return", HttpConnection.calcAuth(_objectSpread2(_objectSpread2(_objectSpread2({}, this.credential), params), {}, {
                  headers: headers
                })));
              case 3:
                stsData = undefined; // 从缓存中取可用的签名 sts
                (function () {
                  var i;
                  var AuthData;
                  for (i = _this4.stsCache.length - 1; i >= 0; i--) {
                    AuthData = _this4.stsCache[i];
                    var compareTime = Math.round(systemClock.now() / 1000) + 30;
                    if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
                      _this4.stsCache.splice(i, 1);
                      continue;
                    }
                    stsData = AuthData;
                    break;
                  }
                })();
                // 判断是否有缓存过可以使用的临时密钥
                if (!((_stsData = stsData) !== null && _stsData !== void 0 && _stsData.ExpiredTime && stsData.ExpiredTime - systemClock.now() / 1000 > 60)) {
                  _context3.next = 9;
                  break;
                }
                return _context3.abrupt("return", HttpConnection.calcAuth(_objectSpread2(_objectSpread2(_objectSpread2({}, params), {}, {
                  headers: headers
                }, stsData), {}, {
                  SecretId: stsData.TmpSecretId,
                  SecretKey: stsData.TmpSecretKey
                })));
              case 9:
                if (!this.getAuthorization) {
                  _context3.next = 24;
                  break;
                }
                _context3.next = 12;
                return this.getAuthorization({
                  method: params.method,
                  query: params.query,
                  headers: headers
                });
              case 12:
                authData = _context3.sent;
                if (!(typeof authData === 'string')) {
                  _context3.next = 17;
                  break;
                }
                return _context3.abrupt("return", {
                  Authorization: authData
                });
              case 17:
                if (!(authData.StartTime && authData.TmpSecretId && authData.TmpSecretKey && authData.Token && authData.ExpiredTime)) {
                  _context3.next = 23;
                  break;
                }
                stsData = authData;
                this.stsCache.push(stsData);
                return _context3.abrupt("return", HttpConnection.calcAuth(_objectSpread2(_objectSpread2(_objectSpread2({}, params), {}, {
                  headers: headers
                }, stsData), {}, {
                  SecretId: stsData.TmpSecretId,
                  SecretKey: stsData.TmpSecretKey
                })));
              case 23:
                throw new ClsSDKError('getAuthorization return value is not standardized.');
              case 24:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));
        function _getAuthorization(_x3) {
          return _getAuthorization2.apply(this, arguments);
        }
        return _getAuthorization;
      }()
    }], [{
      key: "formatHeader",
      value: function formatHeader(headers) {
        var commonHeaders = {};
        var CommonHeaderSet = new Set(['Content-Type', 'Host', 'Content-Length']);
        Object.keys(headers).forEach(function (key) {
          if (CommonHeaderSet.has(key)) {
            commonHeaders[key] = headers[key];
          }
        });
        return commonHeaders;
      }
    }, {
      key: "calcAuth",
      value: function calcAuth(options) {
        var Authorization = sign(options);
        var authData = {
          Authorization: Authorization,
          SecurityToken: options.SecurityToken || ''
        };
        return authData;
      }
    }]);
    return HttpConnection;
  }();

  var UploadState;
  (function (UploadState) {
    UploadState[UploadState["start"] = 0] = "start";
    UploadState[UploadState["waiting"] = 1] = "waiting";
    UploadState[UploadState["running"] = 2] = "running";
    UploadState[UploadState["stop"] = 3] = "stop";
  })(UploadState || (UploadState = {}));
  var Uploader = /*#__PURE__*/function () {
    function Uploader(_ref) {
      var _this$config$getAgent, _this$config, _this$config$autoFill;
      var config = _ref.config;
      _classCallCheck(this, Uploader);
      _defineProperty(this, "queue", []);
      _defineProperty(this, "state", UploadState.stop);
      this.config = config;
      this.http = new HttpConnection({
        region: this.config.region,
        api: this.config.api,
        endpoint: this.config.endpoint,
        topicId: this.config.topicId,
        agent: (_this$config$getAgent = (_this$config = this.config).getAgent) === null || _this$config$getAgent === void 0 ? void 0 : _this$config$getAgent.call(_this$config),
        proxy: this.config.proxy,
        credential: this.config.credential,
        getAuthorization: this.config.getAuthorization,
        autoFillSourceIp: (_this$config$autoFill = this.config.autoFillSourceIp) !== null && _this$config$autoFill !== void 0 ? _this$config$autoFill : !isNotEmpty(this.config.sourceIp)
      });
    }
    _createClass(Uploader, [{
      key: "start",
      value: function start() {
        this.state = UploadState.start;
        this.startNextBatch();
      }
      /**
       * 将要上传的日志添加至队列
       * @param logs
       */
    }, {
      key: "add",
      value: function add(logs) {
        var item = {
          index: this.queue.length,
          logs: logs
        };
        this.queue.push(item);
        this.startNextBatch();
      }
    }, {
      key: "startNextBatch",
      value: function () {
        var _startNextBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var uploadItem;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(this.state === UploadState.running)) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                this.state = UploadState.running;
              case 3:
                if (!(this.queue.length > 0 && this.isStart())) {
                  _context.next = 21;
                  break;
                }
                uploadItem = this.queue.shift();
                if (!uploadItem) {
                  _context.next = 19;
                  break;
                }
                _context.prev = 6;
                if (!(this.config.endpoint && this.config.endpoint.includes('zhiyan'))) {
                  _context.next = 12;
                  break;
                }
                _context.next = 10;
                return this.http.putZhiyanLogs(uploadItem.logs);
              case 10:
                _context.next = 14;
                break;
              case 12:
                _context.next = 14;
                return this.http.putLogs(uploadItem.logs);
              case 14:
                _context.next = 19;
                break;
              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](6);
                this.config.onError(_context.t0);
              case 19:
                _context.next = 3;
                break;
              case 21:
                this.state = UploadState.waiting;
              case 22:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[6, 16]]);
        }));
        function startNextBatch() {
          return _startNextBatch.apply(this, arguments);
        }
        return startNextBatch;
      }()
    }, {
      key: "isStart",
      value: function isStart() {
        return this.state !== UploadState.stop;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.http.cancelRequest();
        this.state = UploadState.stop;
      }
    }]);
    return Uploader;
  }();

  /**
   * CLS上传客户端
   * @public
   */
  var ClsClient = /*#__PURE__*/function () {
    /**
     * Creates an instance of clsclient.
     * @param options - 可选参数，不传则必须调用 init 函数进行初始化
     */
    function ClsClient(options) {
      _classCallCheck(this, ClsClient);
      /**
       * 内部检查缓存日志定时器
       */
      _defineProperty(this, "logTimer", undefined);
      _defineProperty(this, "checkCacheLocked", false);
      /**
       * 日志缓存队列(缓存写入时间按从小到大的顺序)
       */
      _defineProperty(this, "logList", []);
      /**
       * 标志cls上传器是否初始化
       */
      _defineProperty(this, "initTag", false);
      if (options) {
        this.init(options);
      }
    }
    /**
     * clsclient 初始化函数
     * @param options - 参数配置
     */
    _createClass(ClsClient, [{
      key: "init",
      value: function init(options) {
        this.config = new ClientConfig(options);
        this.uploader = new Uploader({
          config: this.config
        });
        this.initTag = true;
      }
      /**
       * 检查当前日志缓存，满足上传条件则加入队列
       */
    }, {
      key: "checkLogCaches",
      value: (function () {
        var _checkLogCaches = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var currCacheSize, immediate, firstLog, latestLogTime, now, offsetTime, delayTime;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!this.checkCacheLocked) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                currCacheSize = this.logList.length;
                if (!(currCacheSize === 0)) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return");
              case 5:
                // 清理掉之前正在执行的定时器
                clearTimeout(this.logTimer);
                this.checkCacheLocked = true;
                immediate = this.logList.some(function (log) {
                  return log.immediate;
                });
                if (!(!immediate && currCacheSize < this.config.maxRetainSize)) {
                  _context.next = 18;
                  break;
                }
                // 判断日志缓存里最早的一条日志的时间间隔是否已达到最大缓存间隔
                firstLog = this.logList[0];
                latestLogTime = firstLog.time;
                now = systemClock.now();
                offsetTime = (now - latestLogTime) / 1000;
                if (!(offsetTime < this.config.maxRetainDuration)) {
                  _context.next = 18;
                  break;
                }
                delayTime = this.config.maxRetainDuration - offsetTime + 1;
                this.checkCacheLocked = false;
                this.logTimer = setTimeout(this.checkLogCaches.bind(this), delayTime * 1000);
                return _context.abrupt("return");
              case 18:
                this.checkCacheLocked = false;
                // 立即将日志加入上传任务队列中
                this.uploader.add(this.logList.splice(0, currCacheSize));
                this.checkLogCaches();
              case 21:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function checkLogCaches() {
          return _checkLogCaches.apply(this, arguments);
        }
        return checkLogCaches;
      }()
      /**
       * 写入日志
       * @param log - 要上传的日志键值对
       * @param options - 可选参数
       *    immediate 是否立即上传
       * @example
       * ```
       *  立即上报：clsclient.log({ key: 'value' }, true);
       *  客户端控制上报：clsclient.log({ key: 'value' });
       * ```
       */
      )
    }, {
      key: "log",
      value: function log(_log, _immediate) {
        if (!this.initTag) {
          // 未调用初始化方法禁止日志上传
          throw new ClsSDKError('ClsClient initialization method not called!');
        }
        var immediate = _immediate !== null && _immediate !== void 0 ? _immediate : false;
        // TODO: 此处的时间使用本地时间可能会不正确，需要校准
        var clsLog = {
          contents: _log,
          time: Date.now(),
          immediate: immediate
        };
        this.logList.push(clsLog);
        this.checkLogCaches();
      }
      /**
       * Destorys clsclient
       */
    }, {
      key: "destory",
      value: function destory() {
        clearTimeout(this.logTimer);
        this.uploader.stop();
        this.initTag = false;
      }
    }]);
    return ClsClient;
  }();

  return ClsClient;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, main, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"cos-js-sdk-v5\",\"version\":\"1.7.1\",\"description\":\"JavaScript SDK for [腾讯云对象存储](https://cloud.tencent.com/product/cos)\",\"main\":\"dist/cos-js-sdk-v5.js\",\"types\":\"index.d.ts\",\"scripts\":{\"prettier\":\"prettier --write src demo/demo.js demo/CIDemos/*.js test/test.js server/sts.js lib/request.js index.d.ts\",\"server\":\"node server/sts.js\",\"dev\":\"cross-env NODE_ENV=development webpack -w --mode=development\",\"build\":\"cross-env NODE_ENV=production webpack --mode=production\",\"cos-auth.min.js\":\"uglifyjs ./demo/common/cos-auth.js -o ./demo/common/cos-auth.min.js -c -m\",\"test\":\"jest --runInBand --coverage\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/tencentyun/cos-js-sdk-v5.git\"},\"keywords\":[],\"author\":\"carsonxu\",\"license\":\"ISC\",\"bugs\":{\"url\":\"https://github.com/tencentyun/cos-js-sdk-v5/issues\"},\"homepage\":\"https://github.com/tencentyun/cos-js-sdk-v5#readme\",\"dependencies\":{\"@xmldom/xmldom\":\"^0.8.6\"},\"devDependencies\":{\"@babel/core\":\"7.17.9\",\"@babel/plugin-transform-runtime\":\"7.18.10\",\"@babel/preset-env\":\"7.16.11\",\"babel-loader\":\"8.2.5\",\"body-parser\":\"^1.18.3\",\"cross-env\":\"^5.2.0\",\"express\":\"^4.16.4\",\"jest\":\"^29.3.1\",\"jest-environment-jsdom\":\"^29.3.1\",\"prettier\":\"^3.0.1\",\"qcloud-cos-sts\":\"^3.0.2\",\"request\":\"^2.87.0\",\"terser-webpack-plugin\":\"4.2.3\",\"uglifyjs\":\"^2.4.11\",\"webpack\":\"4.46.0\",\"webpack-cli\":\"4.10.0\"}}");

/***/ }),

/***/ "./src/advance.js":
/*!************************!*\
  !*** ./src/advance.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
var session = __webpack_require__(/*! ./session */ "./src/session.js");
var Async = __webpack_require__(/*! ./async */ "./src/async.js");
var EventProxy = __webpack_require__(/*! ./event */ "./src/event.js").EventProxy;
var util = __webpack_require__(/*! ./util */ "./src/util.js");
var Tracker = __webpack_require__(/*! ./tracker */ "./src/tracker.js");

// 文件分块上传全过程，暴露的分块上传接口
function sliceUploadFile(params, callback) {
  var self = this;
  var ep = new EventProxy();
  var TaskId = params.TaskId;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var Body = params.Body;
  var ChunkSize = params.ChunkSize || params.SliceSize || self.options.ChunkSize;
  var AsyncLimit = params.AsyncLimit;
  var StorageClass = params.StorageClass;
  var ServerSideEncryption = params.ServerSideEncryption;
  var FileSize;
  var onProgress;
  var onHashProgress = params.onHashProgress;
  var tracker = params.tracker;
  tracker && tracker.setParams({
    chunkSize: ChunkSize
  });

  // 上传过程中出现错误，返回错误
  ep.on('error', function (err) {
    if (!self._isRunningTask(TaskId)) return;
    err.UploadId = params.UploadData.UploadId || '';
    return callback(err);
  });

  // 上传分块完成，开始 uploadSliceComplete 操作
  ep.on('upload_complete', function (UploadCompleteData) {
    var _UploadCompleteData = util.extend({
      UploadId: params.UploadData.UploadId || ''
    }, UploadCompleteData);
    callback(null, _UploadCompleteData);
  });

  // 上传分块完成，开始 uploadSliceComplete 操作
  ep.on('upload_slice_complete', function (UploadData) {
    var metaHeaders = {};
    util.each(params.Headers, function (val, k) {
      var shortKey = k.toLowerCase();
      if (shortKey.indexOf('x-cos-meta-') === 0 || shortKey === 'pic-operations') metaHeaders[k] = val;
    });
    uploadSliceComplete.call(self, {
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      UploadId: UploadData.UploadId,
      SliceList: UploadData.SliceList,
      Headers: metaHeaders,
      tracker: tracker
    }, function (err, data) {
      if (!self._isRunningTask(TaskId)) return;
      session.removeUsing(UploadData.UploadId);
      if (err) {
        onProgress(null, true);
        return ep.emit('error', err);
      }
      session.removeUploadId.call(self, UploadData.UploadId);
      onProgress({
        loaded: FileSize,
        total: FileSize
      }, true);
      ep.emit('upload_complete', data);
    });
  });

  // 获取 UploadId 完成，开始上传每个分片
  ep.on('get_upload_data_finish', function (UploadData) {
    // 处理 UploadId 缓存
    var uuid = session.getFileId(Body, params.ChunkSize, Bucket, Key);
    uuid && session.saveUploadId.call(self, uuid, UploadData.UploadId, self.options.UploadIdCacheLimit); // 缓存 UploadId
    session.setUsing(UploadData.UploadId); // 标记 UploadId 为正在使用

    // 获取 UploadId
    onProgress(null, true); // 任务状态开始 uploading
    uploadSliceList.call(self, {
      TaskId: TaskId,
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      Body: Body,
      FileSize: FileSize,
      SliceSize: ChunkSize,
      AsyncLimit: AsyncLimit,
      ServerSideEncryption: ServerSideEncryption,
      UploadData: UploadData,
      Headers: params.Headers,
      onProgress: onProgress,
      tracker: tracker
    }, function (err, data) {
      if (!self._isRunningTask(TaskId)) return;
      if (err) {
        onProgress(null, true);
        return ep.emit('error', err);
      }
      ep.emit('upload_slice_complete', data);
    });
  });

  // 开始获取文件 UploadId，里面会视情况计算 ETag，并比对，保证文件一致性，也优化上传
  ep.on('get_file_size_finish', function () {
    onProgress = util.throttleOnProgress.call(self, FileSize, params.onProgress);
    if (params.UploadData.UploadId) {
      ep.emit('get_upload_data_finish', params.UploadData);
    } else {
      var _params = util.extend({
        TaskId: TaskId,
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        Headers: params.Headers,
        StorageClass: StorageClass,
        Body: Body,
        FileSize: FileSize,
        SliceSize: ChunkSize,
        onHashProgress: onHashProgress,
        tracker: tracker
      }, params);
      getUploadIdAndPartList.call(self, _params, function (err, UploadData) {
        if (!self._isRunningTask(TaskId)) return;
        if (err) return ep.emit('error', err);
        params.UploadData.UploadId = UploadData.UploadId;
        params.UploadData.PartList = UploadData.PartList;
        ep.emit('get_upload_data_finish', params.UploadData);
      });
    }
  });

  // 获取上传文件大小
  FileSize = params.ContentLength;
  delete params.ContentLength;
  !params.Headers && (params.Headers = {});
  util.each(params.Headers, function (item, key) {
    if (key.toLowerCase() === 'content-length') {
      delete params.Headers[key];
    }
  });

  // 控制分片大小
  (function () {
    var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
    var AutoChunkSize = 1024 * 1024;
    for (var i = 0; i < SIZE.length; i++) {
      AutoChunkSize = SIZE[i] * 1024 * 1024;
      if (FileSize / AutoChunkSize <= self.options.MaxPartNumber) break;
    }
    params.ChunkSize = params.SliceSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
  })();

  // 开始上传
  if (FileSize === 0) {
    params.Body = '';
    params.ContentLength = 0;
    params.SkipTask = true;
    self.putObject(params, callback);
  } else {
    ep.emit('get_file_size_finish');
  }
}

// 获取上传任务的 UploadId
function getUploadIdAndPartList(params, callback) {
  var TaskId = params.TaskId;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var StorageClass = params.StorageClass;
  var self = this;

  // 计算 ETag
  var ETagMap = {};
  var FileSize = params.FileSize;
  var SliceSize = params.SliceSize;
  var SliceCount = Math.ceil(FileSize / SliceSize);
  var FinishSliceCount = 0;
  var FinishSize = 0;
  var onHashProgress = util.throttleOnProgress.call(self, FileSize, params.onHashProgress);
  var getChunkETag = function getChunkETag(PartNumber, callback) {
    var start = SliceSize * (PartNumber - 1);
    var end = Math.min(start + SliceSize, FileSize);
    var ChunkSize = end - start;
    if (ETagMap[PartNumber]) {
      callback(null, {
        PartNumber: PartNumber,
        ETag: ETagMap[PartNumber],
        Size: ChunkSize
      });
    } else {
      util.fileSlice(params.Body, start, end, false, function (chunkItem) {
        util.getFileMd5(chunkItem, function (err, md5) {
          if (err) return callback(util.error(err));
          var ETag = '"' + md5 + '"';
          ETagMap[PartNumber] = ETag;
          FinishSliceCount += 1;
          FinishSize += ChunkSize;
          onHashProgress({
            loaded: FinishSize,
            total: FileSize
          });
          callback(null, {
            PartNumber: PartNumber,
            ETag: ETag,
            Size: ChunkSize
          });
        });
      });
    }
  };

  // 通过和文件的 md5 对比，判断 UploadId 是否可用
  var isAvailableUploadList = function isAvailableUploadList(PartList, callback) {
    var PartCount = PartList.length;
    // 如果没有分片，通过
    if (PartCount === 0) {
      return callback(null, true);
    }
    // 检查分片数量
    if (PartCount > SliceCount) {
      return callback(null, false);
    }
    // 检查分片大小
    if (PartCount > 1) {
      var PartSliceSize = Math.max(PartList[0].Size, PartList[1].Size);
      if (PartSliceSize !== SliceSize) {
        return callback(null, false);
      }
    }
    // 逐个分片计算并检查 ETag 是否一致
    var next = function next(index) {
      if (index < PartCount) {
        var Part = PartList[index];
        getChunkETag(Part.PartNumber, function (err, chunk) {
          if (chunk && chunk.ETag === Part.ETag && chunk.Size === Part.Size) {
            next(index + 1);
          } else {
            callback(null, false);
          }
        });
      } else {
        callback(null, true);
      }
    };
    next(0);
  };
  var ep = new EventProxy();
  ep.on('error', function (errData) {
    if (!self._isRunningTask(TaskId)) return;
    return callback(errData);
  });

  // 存在 UploadId
  ep.on('upload_id_available', function (UploadData) {
    // 转换成 map
    var map = {};
    var list = [];
    util.each(UploadData.PartList, function (item) {
      map[item.PartNumber] = item;
    });
    for (var PartNumber = 1; PartNumber <= SliceCount; PartNumber++) {
      var item = map[PartNumber];
      if (item) {
        item.PartNumber = PartNumber;
        item.Uploaded = true;
      } else {
        item = {
          PartNumber: PartNumber,
          ETag: null,
          Uploaded: false
        };
      }
      list.push(item);
    }
    UploadData.PartList = list;
    callback(null, UploadData);
  });

  // 不存在 UploadId, 初始化生成 UploadId
  ep.on('no_available_upload_id', function () {
    if (!self._isRunningTask(TaskId)) return;
    var _params = util.extend({
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      Query: util.clone(params.Query),
      StorageClass: StorageClass,
      Body: params.Body,
      calledBySdk: 'sliceUploadFile',
      tracker: params.tracker
    }, params);
    var headers = util.clone(params.Headers);
    delete headers['x-cos-mime-limit'];
    _params.Headers = headers;
    self.multipartInit(_params, function (err, data) {
      if (!self._isRunningTask(TaskId)) return;
      if (err) return ep.emit('error', err);
      var UploadId = data.UploadId;
      if (!UploadId) {
        return callback(util.error(new Error('no such upload id')));
      }
      ep.emit('upload_id_available', {
        UploadId: UploadId,
        PartList: []
      });
    });
  });

  // 如果已存在 UploadId，找一个可以用的 UploadId
  ep.on('has_and_check_upload_id', function (UploadIdList) {
    // 串行地，找一个内容一致的 UploadId
    UploadIdList = UploadIdList.reverse();
    Async.eachLimit(UploadIdList, 1, function (UploadId, asyncCallback) {
      if (!self._isRunningTask(TaskId)) return;
      // 如果正在上传，跳过
      if (session.using[UploadId]) {
        asyncCallback(); // 检查下一个 UploadId
        return;
      }
      // 判断 UploadId 是否可用
      wholeMultipartListPart.call(self, {
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        UploadId: UploadId,
        tracker: params.tracker
      }, function (err, PartListData) {
        if (!self._isRunningTask(TaskId)) return;
        if (err) {
          session.removeUsing(UploadId);
          return ep.emit('error', err);
        }
        var PartList = PartListData.PartList;
        PartList.forEach(function (item) {
          item.PartNumber *= 1;
          item.Size *= 1;
          item.ETag = item.ETag || '';
        });
        isAvailableUploadList(PartList, function (err, isAvailable) {
          if (!self._isRunningTask(TaskId)) return;
          if (err) return ep.emit('error', err);
          if (isAvailable) {
            asyncCallback({
              UploadId: UploadId,
              PartList: PartList
            }); // 马上结束
          } else {
            asyncCallback(); // 检查下一个 UploadId
          }
        });
      });
    }, function (AvailableUploadData) {
      if (!self._isRunningTask(TaskId)) return;
      onHashProgress(null, true);
      if (AvailableUploadData && AvailableUploadData.UploadId) {
        ep.emit('upload_id_available', AvailableUploadData);
      } else {
        ep.emit('no_available_upload_id');
      }
    });
  });

  // 在本地缓存找可用的 UploadId
  ep.on('seek_local_avail_upload_id', function (RemoteUploadIdList) {
    // 在本地找可用的 UploadId
    var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key);
    var LocalUploadIdList = session.getUploadIdList.call(self, uuid);
    if (!uuid || !LocalUploadIdList) {
      ep.emit('has_and_check_upload_id', RemoteUploadIdList);
      return;
    }
    var next = function next(index) {
      // 如果本地找不到可用 UploadId，再一个个遍历校验远端
      if (index >= LocalUploadIdList.length) {
        ep.emit('has_and_check_upload_id', RemoteUploadIdList);
        return;
      }
      var UploadId = LocalUploadIdList[index];
      // 如果不在远端 UploadId 列表里，跳过并删除
      if (!util.isInArray(RemoteUploadIdList, UploadId)) {
        session.removeUploadId.call(self, UploadId);
        next(index + 1);
        return;
      }
      // 如果正在上传，跳过
      if (session.using[UploadId]) {
        next(index + 1);
        return;
      }
      // 判断 UploadId 是否存在线上
      wholeMultipartListPart.call(self, {
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        UploadId: UploadId,
        tracker: params.tracker
      }, function (err, PartListData) {
        if (!self._isRunningTask(TaskId)) return;
        if (err) {
          // 如果 UploadId 获取会出错，跳过并删除
          session.removeUploadId.call(self, UploadId);
          next(index + 1);
        } else {
          // 找到可用 UploadId
          ep.emit('upload_id_available', {
            UploadId: UploadId,
            PartList: PartListData.PartList
          });
        }
      });
    };
    next(0);
  });

  // 获取线上 UploadId 列表
  ep.on('get_remote_upload_id_list', function () {
    // 获取符合条件的 UploadId 列表，因为同一个文件可以有多个上传任务。
    wholeMultipartList.call(self, {
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      tracker: params.tracker
    }, function (err, data) {
      if (!self._isRunningTask(TaskId)) return;
      if (err) return ep.emit('error', err);
      // 整理远端 UploadId 列表
      var RemoteUploadIdList = util.filter(data.UploadList, function (item) {
        return item.Key === Key && (!StorageClass || item.StorageClass.toUpperCase() === StorageClass.toUpperCase());
      }).reverse().map(function (item) {
        return item.UploadId || item.UploadID;
      });
      if (RemoteUploadIdList.length) {
        ep.emit('seek_local_avail_upload_id', RemoteUploadIdList);
      } else {
        // 远端没有 UploadId，清理缓存的 UploadId
        var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key),
          LocalUploadIdList;
        if (uuid && (LocalUploadIdList = session.getUploadIdList.call(self, uuid))) {
          util.each(LocalUploadIdList, function (UploadId) {
            session.removeUploadId.call(self, UploadId);
          });
        }
        ep.emit('no_available_upload_id');
      }
    });
  });

  // 开始找可用 UploadId
  ep.emit('get_remote_upload_id_list');
}

// 获取符合条件的全部上传任务 (条件包括 Bucket, Region, Prefix)
function wholeMultipartList(params, callback) {
  var self = this;
  var UploadList = [];
  var sendParams = {
    Bucket: params.Bucket,
    Region: params.Region,
    Prefix: params.Key,
    calledBySdk: params.calledBySdk || 'sliceUploadFile',
    tracker: params.tracker
  };
  var next = function next() {
    self.multipartList(sendParams, function (err, data) {
      if (err) return callback(err);
      UploadList.push.apply(UploadList, data.Upload || []);
      if (data.IsTruncated === 'true') {
        // 列表不完整
        sendParams.KeyMarker = data.NextKeyMarker;
        sendParams.UploadIdMarker = data.NextUploadIdMarker;
        next();
      } else {
        callback(null, {
          UploadList: UploadList
        });
      }
    });
  };
  next();
}

// 获取指定上传任务的分块列表
function wholeMultipartListPart(params, callback) {
  var self = this;
  var PartList = [];
  var sendParams = {
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    UploadId: params.UploadId,
    calledBySdk: 'sliceUploadFile',
    tracker: params.tracker
  };
  var next = function next() {
    self.multipartListPart(sendParams, function (err, data) {
      if (err) return callback(err);
      PartList.push.apply(PartList, data.Part || []);
      if (data.IsTruncated === 'true') {
        // 列表不完整
        sendParams.PartNumberMarker = data.NextPartNumberMarker;
        next();
      } else {
        callback(null, {
          PartList: PartList
        });
      }
    });
  };
  next();
}

// 上传文件分块，包括
/*
 UploadId (上传任务编号)
 AsyncLimit (并发量)，
 SliceList (上传的分块数组)，
 FilePath (本地文件的位置)，
 SliceSize (文件分块大小)
 FileSize (文件大小)
 onProgress (上传成功之后的回调函数)
 */
function uploadSliceList(params, cb) {
  var self = this;
  var TaskId = params.TaskId;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var UploadData = params.UploadData;
  var FileSize = params.FileSize;
  var SliceSize = params.SliceSize;
  var ChunkParallel = Math.min(params.AsyncLimit || self.options.ChunkParallelLimit || 1, 256);
  var Body = params.Body;
  var SliceCount = Math.ceil(FileSize / SliceSize);
  var FinishSize = 0;
  var ServerSideEncryption = params.ServerSideEncryption;
  var Headers = params.Headers;
  var needUploadSlices = util.filter(UploadData.PartList, function (SliceItem) {
    if (SliceItem['Uploaded']) {
      FinishSize += SliceItem['PartNumber'] >= SliceCount ? FileSize % SliceSize || SliceSize : SliceSize;
    }
    return !SliceItem['Uploaded'];
  });
  var _onProgress2 = params.onProgress;
  Async.eachLimit(needUploadSlices, ChunkParallel, function (SliceItem, asyncCallback) {
    if (!self._isRunningTask(TaskId)) return;
    var PartNumber = SliceItem['PartNumber'];
    var currentSize = Math.min(FileSize, SliceItem['PartNumber'] * SliceSize) - (SliceItem['PartNumber'] - 1) * SliceSize;
    var preAddSize = 0;
    uploadSliceItem.call(self, {
      TaskId: TaskId,
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      SliceSize: SliceSize,
      FileSize: FileSize,
      PartNumber: PartNumber,
      ServerSideEncryption: ServerSideEncryption,
      Body: Body,
      UploadData: UploadData,
      Headers: Headers,
      onProgress: function onProgress(data) {
        FinishSize += data.loaded - preAddSize;
        preAddSize = data.loaded;
        _onProgress2({
          loaded: FinishSize,
          total: FileSize
        });
      },
      tracker: params.tracker
    }, function (err, data) {
      if (!self._isRunningTask(TaskId)) return;
      if (!err && !data.ETag) err = 'get ETag error, please add "ETag" to CORS ExposeHeader setting.( 获取ETag失败，请在CORS ExposeHeader设置中添加ETag，请参考文档：https://cloud.tencent.com/document/product/436/13318 )';
      if (err) {
        FinishSize -= preAddSize;
      } else {
        FinishSize += currentSize - preAddSize;
        SliceItem.ETag = data.ETag;
      }
      _onProgress2({
        loaded: FinishSize,
        total: FileSize
      });
      asyncCallback(err || null, data);
    });
  }, function (err) {
    if (!self._isRunningTask(TaskId)) return;
    if (err) return cb(err);
    cb(null, {
      UploadId: UploadData.UploadId,
      SliceList: UploadData.PartList
    });
  });
}

// 上传指定分片
function uploadSliceItem(params, callback) {
  var self = this;
  var TaskId = params.TaskId;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var FileSize = params.FileSize;
  var FileBody = params.Body;
  var PartNumber = params.PartNumber * 1;
  var SliceSize = params.SliceSize;
  var ServerSideEncryption = params.ServerSideEncryption;
  var UploadData = params.UploadData;
  var Headers = params.Headers || {};
  var ChunkRetryTimes = self.options.ChunkRetryTimes + 1;
  var start = SliceSize * (PartNumber - 1);
  var ContentLength = SliceSize;
  var end = start + SliceSize;
  if (end > FileSize) {
    end = FileSize;
    ContentLength = end - start;
  }
  var headersWhiteList = ['x-cos-traffic-limit', 'x-cos-mime-limit'];
  var headers = {};
  util.each(Headers, function (v, k) {
    if (headersWhiteList.indexOf(k) > -1) {
      headers[k] = v;
    }
  });
  var PartItem = UploadData.PartList[PartNumber - 1];
  Async.retry(ChunkRetryTimes, function (tryCallback) {
    if (!self._isRunningTask(TaskId)) return;
    util.fileSlice(FileBody, start, end, true, function (Body) {
      self.multipartUpload({
        TaskId: TaskId,
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        ContentLength: ContentLength,
        PartNumber: PartNumber,
        UploadId: UploadData.UploadId,
        ServerSideEncryption: ServerSideEncryption,
        Body: Body,
        Headers: headers,
        onProgress: params.onProgress,
        calledBySdk: 'sliceUploadFile',
        tracker: params.tracker
      }, function (err, data) {
        if (!self._isRunningTask(TaskId)) return;
        if (err) return tryCallback(err);
        PartItem.Uploaded = true;
        return tryCallback(null, data);
      });
    });
  }, function (err, data) {
    if (!self._isRunningTask(TaskId)) return;
    return callback(err, data);
  });
}

// 完成分块上传
function uploadSliceComplete(params, callback) {
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var UploadId = params.UploadId;
  var SliceList = params.SliceList;
  var self = this;
  var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
  var Headers = params.Headers;
  var Parts = SliceList.map(function (item) {
    return {
      PartNumber: item.PartNumber,
      ETag: item.ETag
    };
  });
  // 完成上传的请求也做重试
  Async.retry(ChunkRetryTimes, function (tryCallback) {
    self.multipartComplete({
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      UploadId: UploadId,
      Parts: Parts,
      Headers: Headers,
      calledBySdk: 'sliceUploadFile',
      tracker: params.tracker
    }, tryCallback);
  }, function (err, data) {
    callback(err, data);
  });
}

// 抛弃分块上传任务
/*
 AsyncLimit (抛弃上传任务的并发量)，
 UploadId (上传任务的编号，当 Level 为 task 时候需要)
 Level (抛弃分块上传任务的级别，task : 抛弃指定的上传任务，file ： 抛弃指定的文件对应的上传任务，其他值 ：抛弃指定Bucket 的全部上传任务)
 */
function abortUploadTask(params, callback) {
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var UploadId = params.UploadId;
  var Level = params.Level || 'task';
  var AsyncLimit = params.AsyncLimit;
  var self = this;
  var ep = new EventProxy();
  ep.on('error', function (errData) {
    return callback(errData);
  });

  // 已经获取到需要抛弃的任务列表
  ep.on('get_abort_array', function (AbortArray) {
    abortUploadTaskArray.call(self, {
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      Headers: params.Headers,
      AsyncLimit: AsyncLimit,
      AbortArray: AbortArray
    }, callback);
  });
  if (Level === 'bucket') {
    // Bucket 级别的任务抛弃，抛弃该 Bucket 下的全部上传任务
    wholeMultipartList.call(self, {
      Bucket: Bucket,
      Region: Region,
      calledBySdk: 'abortUploadTask'
    }, function (err, data) {
      if (err) return callback(err);
      ep.emit('get_abort_array', data.UploadList || []);
    });
  } else if (Level === 'file') {
    // 文件级别的任务抛弃，抛弃该文件的全部上传任务
    if (!Key) return callback(util.error(new Error('abort_upload_task_no_key')));
    wholeMultipartList.call(self, {
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      calledBySdk: 'abortUploadTask'
    }, function (err, data) {
      if (err) return callback(err);
      ep.emit('get_abort_array', data.UploadList || []);
    });
  } else if (Level === 'task') {
    // 单个任务级别的任务抛弃，抛弃指定 UploadId 的上传任务
    if (!UploadId) return callback(util.error(new Error('abort_upload_task_no_id')));
    if (!Key) return callback(util.error(new Error('abort_upload_task_no_key')));
    ep.emit('get_abort_array', [{
      Key: Key,
      UploadId: UploadId
    }]);
  } else {
    return callback(util.error(new Error('abort_unknown_level')));
  }
}

// 批量抛弃分块上传任务
function abortUploadTaskArray(params, callback) {
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var AbortArray = params.AbortArray;
  var AsyncLimit = params.AsyncLimit || 1;
  var self = this;
  var index = 0;
  var resultList = new Array(AbortArray.length);
  Async.eachLimit(AbortArray, AsyncLimit, function (AbortItem, nextItem) {
    var eachIndex = index;
    if (Key && Key !== AbortItem.Key) {
      resultList[eachIndex] = {
        error: {
          KeyNotMatch: true
        }
      };
      nextItem(null);
      return;
    }
    var UploadId = AbortItem.UploadId || AbortItem.UploadID;
    self.multipartAbort({
      Bucket: Bucket,
      Region: Region,
      Key: AbortItem.Key,
      Headers: params.Headers,
      UploadId: UploadId
    }, function (err) {
      var task = {
        Bucket: Bucket,
        Region: Region,
        Key: AbortItem.Key,
        UploadId: UploadId
      };
      resultList[eachIndex] = {
        error: err,
        task: task
      };
      nextItem(null);
    });
    index++;
  }, function (err) {
    if (err) return callback(err);
    var successList = [];
    var errorList = [];
    for (var i = 0, len = resultList.length; i < len; i++) {
      var item = resultList[i];
      if (item['task']) {
        if (item['error']) {
          errorList.push(item['task']);
        } else {
          successList.push(item['task']);
        }
      }
    }
    return callback(null, {
      successList: successList,
      errorList: errorList
    });
  });
}

// 高级上传
function uploadFile(params, callback) {
  var self = this;

  // 判断多大的文件使用分片上传
  var SliceSize = params.SliceSize === undefined ? self.options.SliceSize : params.SliceSize;
  var taskList = [];
  var Body = params.Body;
  var FileSize = Body.size || Body.length || 0;
  var fileInfo = {
    TaskId: ''
  };

  // 上传链路
  if (self.options.EnableReporter) {
    var accelerate = self.options.UseAccelerate || typeof self.options.Domain === 'string' && self.options.Domain.includes('accelerate.');
    var realApi = FileSize > SliceSize ? 'sliceUploadFile' : 'putObject';
    params.tracker = new Tracker({
      Beacon: self.options.Beacon,
      bucket: params.Bucket,
      region: params.Region,
      apiName: 'uploadFile',
      realApi: realApi,
      fileKey: params.Key,
      fileSize: FileSize,
      accelerate: accelerate,
      deepTracker: self.options.DeepTracker,
      customId: self.options.CustomId,
      delay: self.options.TrackerDelay,
      clsReporter: self.options.ClsReporter
    });
  }

  // 整理 option，用于返回给回调
  util.each(params, function (v, k) {
    if (_typeof(v) !== 'object' && typeof v !== 'function') {
      fileInfo[k] = v;
    }
  });

  // 处理文件 TaskReady
  var _onTaskReady = params.onTaskReady;
  var onTaskReady = function onTaskReady(tid) {
    fileInfo.TaskId = tid;
    _onTaskReady && _onTaskReady(tid);
  };
  params.onTaskReady = onTaskReady;

  // 添加上传任务,超过阈值使用分块上传，小于等于则简单上传
  var api = FileSize > SliceSize ? 'sliceUploadFile' : 'putObject';

  // 处理文件完成
  var _onFileFinish = params.onFileFinish;
  var onFileFinish = function onFileFinish(err, data) {
    // 格式化上报参数并上报
    params.tracker && params.tracker.report(err, data);
    _onFileFinish && _onFileFinish(err, data, fileInfo);
    callback && callback(err, data);
  };
  taskList.push({
    api: api,
    params: params,
    callback: onFileFinish
  });
  self._addTasks(taskList);
}

// 批量上传文件
function uploadFiles(params, callback) {
  var self = this;

  // 判断多大的文件使用分片上传
  var SliceSize = params.SliceSize === undefined ? self.options.SliceSize : params.SliceSize;

  // 汇总返回进度
  var TotalSize = 0;
  var TotalFinish = 0;
  var onTotalProgress = util.throttleOnProgress.call(self, TotalFinish, params.onProgress);

  // 汇总返回回调
  var unFinishCount = params.files.length;
  var _onTotalFileFinish = params.onFileFinish;
  var resultList = Array(unFinishCount);
  var onTotalFileFinish = function onTotalFileFinish(err, data, options) {
    onTotalProgress(null, true);
    _onTotalFileFinish && _onTotalFileFinish(err, data, options);
    resultList[options.Index] = {
      options: options,
      error: err,
      data: data
    };
    if (--unFinishCount <= 0 && callback) {
      callback(null, {
        files: resultList
      });
    }
  };

  // 开始处理每个文件
  var taskList = [];
  util.each(params.files, function (fileParams, index) {
    (function () {
      var Body = fileParams.Body;
      var FileSize = Body.size || Body.length || 0;
      var fileInfo = {
        Index: index,
        TaskId: ''
      };

      // 如果 批量上传的 Key 是 / 开头，强制去掉第一个 /
      if (!self.options.UseRawKey && fileParams.Key && fileParams.Key.substr(0, 1) === '/') {
        fileParams.Key = fileParams.Key.substr(1);
      }

      // 更新文件总大小
      TotalSize += FileSize;

      // 单个文件上传链路
      if (self.options.EnableReporter) {
        var accelerate = self.options.UseAccelerate || typeof self.options.Domain === 'string' && self.options.Domain.includes('accelerate.');
        var realApi = FileSize > SliceSize ? 'sliceUploadFile' : 'putObject';
        fileParams.tracker = new Tracker({
          Beacon: self.options.Beacon,
          bucket: fileParams.Bucket,
          region: fileParams.Region,
          apiName: 'uploadFiles',
          realApi: realApi,
          fileKey: fileParams.Key,
          fileSize: FileSize,
          accelerate: accelerate,
          deepTracker: self.options.DeepTracker,
          customId: self.options.CustomId,
          delay: self.options.TrackerDelay,
          clsReporter: self.options.ClsReporter
        });
      }

      // 整理 option，用于返回给回调
      util.each(fileParams, function (v, k) {
        if (_typeof(v) !== 'object' && typeof v !== 'function') {
          fileInfo[k] = v;
        }
      });

      // 处理单个文件 TaskReady
      var _onTaskReady = fileParams.onTaskReady;
      var onTaskReady = function onTaskReady(tid) {
        fileInfo.TaskId = tid;
        _onTaskReady && _onTaskReady(tid);
      };
      fileParams.onTaskReady = onTaskReady;

      // 处理单个文件进度
      var PreAddSize = 0;
      var _onProgress = fileParams.onProgress;
      var onProgress = function onProgress(info) {
        TotalFinish = TotalFinish - PreAddSize + info.loaded;
        PreAddSize = info.loaded;
        _onProgress && _onProgress(info);
        onTotalProgress({
          loaded: TotalFinish,
          total: TotalSize
        });
      };
      fileParams.onProgress = onProgress;

      // 添加上传任务
      var api = FileSize > SliceSize ? 'sliceUploadFile' : 'putObject';

      // 处理单个文件完成
      var _onFileFinish = fileParams.onFileFinish;
      var onFileFinish = function onFileFinish(err, data) {
        // 格式化上报参数并上报
        fileParams.tracker && fileParams.tracker.report(err, data);
        _onFileFinish && _onFileFinish(err, data);
        onTotalFileFinish && onTotalFileFinish(err, data, fileInfo);
      };
      taskList.push({
        api: api,
        params: fileParams,
        callback: onFileFinish
      });
    })();
  });
  self._addTasks(taskList);
}

// 分片复制文件
function sliceCopyFile(params, callback) {
  var ep = new EventProxy();
  var self = this;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var CopySource = params.CopySource;
  var m = util.getSourceParams.call(this, CopySource);
  if (!m) {
    callback(util.error(new Error('CopySource format error')));
    return;
  }
  var SourceBucket = m.Bucket;
  var SourceRegion = m.Region;
  var SourceKey = decodeURIComponent(m.Key);
  var CopySliceSize = params.CopySliceSize === undefined ? self.options.CopySliceSize : params.CopySliceSize;
  CopySliceSize = Math.max(0, CopySliceSize);
  var ChunkSize = params.CopyChunkSize || this.options.CopyChunkSize;
  var ChunkParallel = this.options.CopyChunkParallelLimit;
  var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
  var ChunkCount = 0;
  var FinishSize = 0;
  var FileSize;
  var onProgress;
  var SourceResHeaders = {};
  var SourceHeaders = {};
  var TargetHeader = {};

  // 分片复制完成，开始 multipartComplete 操作
  ep.on('copy_slice_complete', function (UploadData) {
    var metaHeaders = {};
    util.each(params.Headers, function (val, k) {
      if (k.toLowerCase().indexOf('x-cos-meta-') === 0) metaHeaders[k] = val;
    });
    var Parts = util.map(UploadData.PartList, function (item) {
      return {
        PartNumber: item.PartNumber,
        ETag: item.ETag
      };
    });
    // 完成上传的请求也做重试
    Async.retry(ChunkRetryTimes, function (tryCallback) {
      self.multipartComplete({
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        UploadId: UploadData.UploadId,
        Parts: Parts,
        tracker: params.tracker,
        calledBySdk: 'sliceCopyFile'
      }, tryCallback);
    }, function (err, data) {
      session.removeUsing(UploadData.UploadId); // 标记 UploadId 没被使用了，因为复制没提供重试，所以只要出错，就是 UploadId 停用了。
      if (err) {
        onProgress(null, true);
        return callback(err);
      }
      session.removeUploadId(UploadData.UploadId);
      onProgress({
        loaded: FileSize,
        total: FileSize
      }, true);
      callback(null, data);
    });
  });
  ep.on('get_copy_data_finish', function (UploadData) {
    // 处理 UploadId 缓存
    var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
    uuid && session.saveUploadId(uuid, UploadData.UploadId, self.options.UploadIdCacheLimit); // 缓存 UploadId
    session.setUsing(UploadData.UploadId); // 标记 UploadId 为正在使用

    var needCopySlices = util.filter(UploadData.PartList, function (SliceItem) {
      if (SliceItem['Uploaded']) {
        FinishSize += SliceItem['PartNumber'] >= ChunkCount ? FileSize % ChunkSize || ChunkSize : ChunkSize;
      }
      return !SliceItem['Uploaded'];
    });
    Async.eachLimit(needCopySlices, ChunkParallel, function (SliceItem, asyncCallback) {
      var PartNumber = SliceItem.PartNumber;
      var CopySourceRange = SliceItem.CopySourceRange;
      var currentSize = SliceItem.end - SliceItem.start;
      Async.retry(ChunkRetryTimes, function (tryCallback) {
        copySliceItem.call(self, {
          Bucket: Bucket,
          Region: Region,
          Key: Key,
          CopySource: CopySource,
          UploadId: UploadData.UploadId,
          PartNumber: PartNumber,
          CopySourceRange: CopySourceRange,
          tracker: params.tracker,
          calledBySdk: 'sliceCopyFile'
        }, tryCallback);
      }, function (err, data) {
        if (err) return asyncCallback(err);
        FinishSize += currentSize;
        onProgress({
          loaded: FinishSize,
          total: FileSize
        });
        SliceItem.ETag = data.ETag;
        asyncCallback(err || null, data);
      });
    }, function (err) {
      if (err) {
        session.removeUsing(UploadData.UploadId); // 标记 UploadId 没被使用了，因为复制没提供重试，所以只要出错，就是 UploadId 停用了。
        onProgress(null, true);
        return callback(err);
      }
      ep.emit('copy_slice_complete', UploadData);
    });
  });
  ep.on('get_chunk_size_finish', function () {
    var createNewUploadId = function createNewUploadId() {
      self.multipartInit({
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        Headers: TargetHeader,
        tracker: params.tracker,
        calledBySdk: 'sliceCopyFile'
      }, function (err, data) {
        if (err) return callback(err);
        params.UploadId = data.UploadId;
        ep.emit('get_copy_data_finish', {
          UploadId: params.UploadId,
          PartList: params.PartList
        });
      });
    };

    // 在本地找可用的 UploadId
    var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
    var LocalUploadIdList = session.getUploadIdList(uuid);
    if (!uuid || !LocalUploadIdList) return createNewUploadId();
    var next = function next(index) {
      // 如果本地找不到可用 UploadId，再一个个遍历校验远端
      if (index >= LocalUploadIdList.length) return createNewUploadId();
      var UploadId = LocalUploadIdList[index];
      // 如果正在被使用，跳过
      if (session.using[UploadId]) return next(index + 1);
      // 判断 UploadId 是否存在线上
      wholeMultipartListPart.call(self, {
        Bucket: Bucket,
        Region: Region,
        Key: Key,
        UploadId: UploadId,
        tracker: params.tracker,
        calledBySdk: 'sliceCopyFile'
      }, function (err, PartListData) {
        if (err) {
          // 如果 UploadId 获取会出错，跳过并删除
          session.removeUploadId(UploadId);
          next(index + 1);
        } else {
          // 如果异步回来 UploadId 已经被用了，也跳过
          if (session.using[UploadId]) return next(index + 1);
          // 找到可用 UploadId
          var finishETagMap = {};
          var offset = 0;
          util.each(PartListData.PartList, function (PartItem) {
            var size = parseInt(PartItem.Size);
            var end = offset + size - 1;
            finishETagMap[PartItem.PartNumber + '|' + offset + '|' + end] = PartItem.ETag;
            offset += size;
          });
          util.each(params.PartList, function (PartItem) {
            var ETag = finishETagMap[PartItem.PartNumber + '|' + PartItem.start + '|' + PartItem.end];
            if (ETag) {
              PartItem.ETag = ETag;
              PartItem.Uploaded = true;
            }
          });
          ep.emit('get_copy_data_finish', {
            UploadId: UploadId,
            PartList: params.PartList
          });
        }
      });
    };
    next(0);
  });
  ep.on('get_file_size_finish', function () {
    // 控制分片大小
    (function () {
      var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
      var AutoChunkSize = 1024 * 1024;
      for (var i = 0; i < SIZE.length; i++) {
        AutoChunkSize = SIZE[i] * 1024 * 1024;
        if (FileSize / AutoChunkSize <= self.options.MaxPartNumber) break;
      }
      params.ChunkSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
      ChunkCount = Math.ceil(FileSize / ChunkSize);
      var list = [];
      for (var partNumber = 1; partNumber <= ChunkCount; partNumber++) {
        var start = (partNumber - 1) * ChunkSize;
        var end = partNumber * ChunkSize < FileSize ? partNumber * ChunkSize - 1 : FileSize - 1;
        var item = {
          PartNumber: partNumber,
          start: start,
          end: end,
          CopySourceRange: 'bytes=' + start + '-' + end
        };
        list.push(item);
      }
      params.PartList = list;
    })();
    if (params.Headers['x-cos-metadata-directive'] === 'Replaced') {
      TargetHeader = params.Headers;
    } else {
      TargetHeader = SourceHeaders;
    }
    TargetHeader['x-cos-storage-class'] = params.Headers['x-cos-storage-class'] || SourceHeaders['x-cos-storage-class'];
    TargetHeader = util.clearKey(TargetHeader);
    /**
     * 对于归档存储的对象，如果未恢复副本，则不允许 Copy
     */
    if (SourceHeaders['x-cos-storage-class'] === 'ARCHIVE' || SourceHeaders['x-cos-storage-class'] === 'DEEP_ARCHIVE') {
      var restoreHeader = SourceHeaders['x-cos-restore'];
      if (!restoreHeader || restoreHeader === 'ongoing-request="true"') {
        callback(util.error(new Error('Unrestored archive object is not allowed to be copied')));
        return;
      }
    }
    /**
     * 去除一些无用的头部，规避 multipartInit 出错
     * 这些头部通常是在 putObjectCopy 时才使用
     */
    delete TargetHeader['x-cos-copy-source'];
    delete TargetHeader['x-cos-metadata-directive'];
    delete TargetHeader['x-cos-copy-source-If-Modified-Since'];
    delete TargetHeader['x-cos-copy-source-If-Unmodified-Since'];
    delete TargetHeader['x-cos-copy-source-If-Match'];
    delete TargetHeader['x-cos-copy-source-If-None-Match'];
    ep.emit('get_chunk_size_finish');
  });

  // 获取远端复制源文件的大小
  self.headObject({
    Bucket: SourceBucket,
    Region: SourceRegion,
    Key: SourceKey,
    tracker: params.tracker,
    calledBySdk: 'sliceCopyFile'
  }, function (err, data) {
    if (err) {
      if (err.statusCode && err.statusCode === 404) {
        callback(util.error(err, {
          ErrorStatus: SourceKey + ' Not Exist'
        }));
      } else {
        callback(err);
      }
      return;
    }
    FileSize = params.FileSize = data.headers['content-length'];
    if (FileSize === undefined || !FileSize) {
      callback(util.error(new Error('get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.（ 获取Content-Length失败，请在CORS ExposeHeader设置中添加Content-Length，请参考文档：https://cloud.tencent.com/document/product/436/13318 ）')));
      return;
    }
    params.tracker && params.tracker.setParams({
      httpSize: FileSize
    });
    onProgress = util.throttleOnProgress.call(self, FileSize, params.onProgress);

    // 开始上传
    if (FileSize <= CopySliceSize) {
      if (!params.Headers['x-cos-metadata-directive']) {
        params.Headers['x-cos-metadata-directive'] = 'Copy';
      }
      self.putObjectCopy(Object.assign(params, {
        calledBySdk: 'sliceCopyFile'
      }), function (err, data) {
        if (err) {
          onProgress(null, true);
          return callback(err);
        }
        onProgress({
          loaded: FileSize,
          total: FileSize
        }, true);
        callback(err, data);
      });
    } else {
      var resHeaders = data.headers;
      SourceResHeaders = resHeaders;
      SourceHeaders = {
        'Cache-Control': resHeaders['cache-control'],
        'Content-Disposition': resHeaders['content-disposition'],
        'Content-Encoding': resHeaders['content-encoding'],
        'Content-Type': resHeaders['content-type'],
        Expires: resHeaders['expires'],
        'x-cos-storage-class': resHeaders['x-cos-storage-class']
      };
      util.each(resHeaders, function (v, k) {
        var metaPrefix = 'x-cos-meta-';
        if (k.indexOf(metaPrefix) === 0 && k.length > metaPrefix.length) {
          SourceHeaders[k] = v;
        }
      });
      ep.emit('get_file_size_finish');
    }
  });
}

// 复制指定分片
function copySliceItem(params, callback) {
  var TaskId = params.TaskId;
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var CopySource = params.CopySource;
  var UploadId = params.UploadId;
  var PartNumber = params.PartNumber * 1;
  var CopySourceRange = params.CopySourceRange;
  var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
  var self = this;
  Async.retry(ChunkRetryTimes, function (tryCallback) {
    self.uploadPartCopy({
      TaskId: TaskId,
      Bucket: Bucket,
      Region: Region,
      Key: Key,
      CopySource: CopySource,
      UploadId: UploadId,
      PartNumber: PartNumber,
      CopySourceRange: CopySourceRange,
      tracker: params.tracker,
      calledBySdk: params.calledBySdk
    }, function (err, data) {
      tryCallback(err || null, data);
    });
  }, function (err, data) {
    return callback(err, data);
  });
}
var API_MAP = {
  sliceUploadFile: sliceUploadFile,
  abortUploadTask: abortUploadTask,
  uploadFile: uploadFile,
  uploadFiles: uploadFiles,
  sliceCopyFile: sliceCopyFile
};
module.exports.init = function (COS, task) {
  task.transferToTaskMethod(API_MAP, 'sliceUploadFile');
  util.each(API_MAP, function (fn, apiName) {
    COS.prototype[apiName] = util.apiWrapper(apiName, fn);
  });
};

/***/ }),

/***/ "./src/async.js":
/*!**********************!*\
  !*** ./src/async.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

var eachLimit = function eachLimit(arr, limit, iterator, callback) {
  callback = callback || function () {};
  if (!arr.length || limit <= 0) {
    return callback();
  }
  var completed = 0;
  var started = 0;
  var running = 0;
  (function replenish() {
    if (completed >= arr.length) {
      return callback();
    }
    while (running < limit && started < arr.length) {
      started += 1;
      running += 1;
      iterator(arr[started - 1], function (err) {
        if (err) {
          callback(err);
          callback = function callback() {};
        } else {
          completed += 1;
          running -= 1;
          if (completed >= arr.length) {
            callback();
          } else {
            replenish();
          }
        }
      });
    }
  })();
};
var retry = function retry(times, iterator, callback) {
  var next = function next(index) {
    iterator(function (err, data) {
      if (err && index < times) {
        next(index + 1);
      } else {
        callback(err, data);
      }
    });
  };
  if (times < 1) {
    callback();
  } else {
    next(1);
  }
};
var async = {
  eachLimit: eachLimit,
  retry: retry
};
module.exports = async;

/***/ }),

/***/ "./src/base.js":
/*!*********************!*\
  !*** ./src/base.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
var REQUEST = __webpack_require__(/*! ../lib/request */ "./lib/request.js");
var util = __webpack_require__(/*! ./util */ "./src/util.js");

// Bucket 相关

/**
 * 获取用户的 bucket 列表
 * @param  {Object}  params         回调函数，必须，下面为参数列表
 * 无特殊参数
 * @param  {Function}  callback     回调函数，必须
 */
function getService(params, callback) {
  if (typeof params === 'function') {
    callback = params;
    params = {};
  }
  var protocol = this.options.Protocol || (util.isBrowser && (typeof location === "undefined" ? "undefined" : _typeof(location)) === 'object' && location.protocol === 'http:' ? 'http:' : 'https:');
  var domain = this.options.ServiceDomain;
  var appId = params.AppId || this.options.appId;
  var region = params.Region;
  if (domain) {
    domain = domain.replace(/\{\{AppId\}\}/gi, appId || '').replace(/\{\{Region\}\}/gi, region || '').replace(/\{\{.*?\}\}/gi, '');
    if (!/^[a-zA-Z]+:\/\//.test(domain)) {
      domain = protocol + '//' + domain;
    }
    if (domain.slice(-1) === '/') {
      domain = domain.slice(0, -1);
    }
  } else if (region) {
    domain = protocol + '//cos.' + region + '.myqcloud.com';
  } else {
    domain = protocol + '//service.cos.myqcloud.com';
  }
  var SignHost = '';
  var standardHost = region ? 'cos.' + region + '.myqcloud.com' : 'service.cos.myqcloud.com';
  var urlHost = domain.replace(/^https?:\/\/([^/]+)(\/.*)?$/, '$1');
  if (standardHost === urlHost) SignHost = standardHost;
  submitRequest.call(this, {
    Action: 'name/cos:GetService',
    url: domain,
    method: 'GET',
    headers: params.Headers,
    SignHost: SignHost,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var buckets = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Buckets && data.ListAllMyBucketsResult.Buckets.Bucket || [];
    buckets = util.isArray(buckets) ? buckets : [buckets];
    var owner = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Owner || {};
    callback(null, {
      Buckets: buckets,
      Owner: owner,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 创建 Bucket，并初始化访问权限
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.ACL                 用户自定义文件权限，可以设置：private，public-read；默认值：private，非必须
 *     @param  {String}  params.GrantRead           赋予被授权者读的权限，格式x-cos-grant-read: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantWrite          赋予被授权者写的权限，格式x-cos-grant-write: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantFullControl    赋予被授权者读写权限，格式x-cos-grant-full-control: uin=" ",uin=" "，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {String}  data.Location             操作地址
 */
function putBucket(params, callback) {
  var self = this;
  var xml = '';
  if (params['BucketAZConfig']) {
    var CreateBucketConfiguration = {
      BucketAZConfig: params.BucketAZConfig
    };
    xml = util.json2xml({
      CreateBucketConfiguration: CreateBucketConfiguration
    });
  }
  submitRequest.call(this, {
    Action: 'name/cos:PutBucket',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    body: xml,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var url = getUrl({
      protocol: self.options.Protocol,
      domain: self.options.Domain,
      bucket: params.Bucket,
      region: params.Region,
      isLocation: true
    });
    callback(null, {
      Location: url,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 查看是否存在该Bucket，是否有权限访问
 * @param  {Object}  params                     参数对象，必须
 *     @param  {String}  params.Bucket          Bucket名称，必须
 *     @param  {String}  params.Region          地域名称，必须
 * @param  {Function}  callback                 回调函数，必须
 * @return  {Object}  err                       请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                      返回的数据
 *     @return  {Boolean}  data.BucketExist     Bucket是否存在
 *     @return  {Boolean}  data.BucketAuth      是否有 Bucket 的访问权限
 */
function headBucket(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:HeadBucket',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    method: 'HEAD',
    tracker: params.tracker
  }, callback);
}

/**
 * 获取 Bucket 下的 object 列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Prefix              前缀匹配，用来规定返回的文件前缀地址，非必须
 *     @param  {String}  params.Delimiter           定界符为一个符号，如果有Prefix，则将Prefix到delimiter之间的相同路径归为一类，非必须
 *     @param  {String}  params.Marker              默认以UTF-8二进制顺序列出条目，所有列出条目从marker开始，非必须
 *     @param  {String}  params.MaxKeys             单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.EncodingType        规定返回值的编码方式，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.ListBucketResult     返回的 object 列表信息
 */
function getBucket(params, callback) {
  var reqParams = {};
  reqParams['prefix'] = params['Prefix'] || '';
  reqParams['delimiter'] = params['Delimiter'];
  reqParams['marker'] = params['Marker'];
  reqParams['max-keys'] = params['MaxKeys'];
  reqParams['encoding-type'] = params['EncodingType'];
  submitRequest.call(this, {
    Action: 'name/cos:GetBucket',
    ResourceKey: reqParams['prefix'],
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    qs: reqParams,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var ListBucketResult = data.ListBucketResult || {};
    var Contents = ListBucketResult.Contents || [];
    var CommonPrefixes = ListBucketResult.CommonPrefixes || [];
    Contents = util.isArray(Contents) ? Contents : [Contents];
    CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];
    var result = util.clone(ListBucketResult);
    util.extend(result, {
      Contents: Contents,
      CommonPrefixes: CommonPrefixes,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 删除 Bucket
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 *     @return  {String}  data.Location     操作地址
 */
function deleteBucket(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucket',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    method: 'DELETE',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.ACL                 用户自定义文件权限，可以设置：private，public-read；默认值：private，非必须
 *     @param  {String}  params.GrantRead           赋予被授权者读的权限，格式x-cos-grant-read: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantWrite          赋予被授权者写的权限，格式x-cos-grant-write: uin=" ",uin=" "，非必须
 *     @param  {String}  params.GrantFullControl    赋予被授权者读写权限，格式x-cos-grant-full-control: uin=" ",uin=" "，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 */
function putBucketAcl(params, callback) {
  var headers = params.Headers;
  var xml = '';
  if (params['AccessControlPolicy']) {
    var AccessControlPolicy = util.clone(params['AccessControlPolicy'] || {});
    var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
    Grants = util.isArray(Grants) ? Grants : [Grants];
    delete AccessControlPolicy.Grant;
    delete AccessControlPolicy.Grants;
    AccessControlPolicy.AccessControlList = {
      Grant: Grants
    };
    xml = util.json2xml({
      AccessControlPolicy: AccessControlPolicy
    });
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.b64(util.md5(xml));
  }

  // Grant Header 去重
  util.each(headers, function (val, key) {
    if (key.indexOf('x-cos-grant-') === 0) {
      headers[key] = uniqGrant(headers[key]);
    }
  });
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketACL',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: headers,
    action: 'acl',
    body: xml,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.AccessControlPolicy  访问权限信息
 */
function getBucketAcl(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketACL',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'acl',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var AccessControlPolicy = data.AccessControlPolicy || {};
    var Owner = AccessControlPolicy.Owner || {};
    var Grant = AccessControlPolicy.AccessControlList.Grant || [];
    Grant = util.isArray(Grant) ? Grant : [Grant];
    var result = decodeAcl(AccessControlPolicy);
    if (data.headers && data.headers['x-cos-acl']) {
      result.ACL = data.headers['x-cos-acl'];
    }
    result = util.extend(result, {
      Owner: Owner,
      Grants: Grant,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 设置 Bucket 的 跨域设置
 * @param  {Object}  params                             参数对象，必须
 *     @param  {String}  params.Bucket                  Bucket名称，必须
 *     @param  {String}  params.Region                  地域名称，必须
 *     @param  {Object}  params.CORSConfiguration       相关的跨域设置，必须
 * @param  {Array}  params.CORSConfiguration.CORSRules  对应的跨域规则
 * @param  {Function}  callback                         回调函数，必须
 * @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                              返回的数据
 */
function putBucketCors(params, callback) {
  var CORSConfiguration = params['CORSConfiguration'] || {};
  var CORSRules = CORSConfiguration['CORSRules'] || params['CORSRules'] || [];
  CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
  util.each(CORSRules, function (rule) {
    util.each(['AllowedOrigin', 'AllowedHeader', 'AllowedMethod', 'ExposeHeader'], function (key) {
      var sKey = key + 's';
      var val = rule[sKey] || rule[key] || [];
      delete rule[sKey];
      rule[key] = util.isArray(val) ? val : [val];
    });
  });
  var Conf = {
    CORSRule: CORSRules
  };
  if (params.ResponseVary) Conf.ResponseVary = params.ResponseVary;
  var xml = util.json2xml({
    CORSConfiguration: Conf
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketCORS',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'cors',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的 跨域设置
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.CORSRules            Bucket的跨域设置
 */
function getBucketCors(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketCORS',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'cors',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error && err.error.Code === 'NoSuchCORSConfiguration') {
        var result = {
          CORSRules: [],
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var CORSConfiguration = data.CORSConfiguration || {};
    var CORSRules = CORSConfiguration.CORSRules || CORSConfiguration.CORSRule || [];
    CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
    var ResponseVary = CORSConfiguration.ResponseVary;
    util.each(CORSRules, function (rule) {
      util.each(['AllowedOrigin', 'AllowedHeader', 'AllowedMethod', 'ExposeHeader'], function (key) {
        var sKey = key + 's';
        var val = rule[sKey] || rule[key] || [];
        delete rule[key];
        rule[sKey] = util.isArray(val) ? val : [val];
      });
    });
    callback(null, {
      CORSRules: CORSRules,
      ResponseVary: ResponseVary,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 的 跨域设置
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 */
function deleteBucketCors(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketCORS',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'cors',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode || err.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的 地域信息
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据，包含地域信息 LocationConstraint
 */
function getBucketLocation(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketLocation',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'location',
    tracker: params.tracker
  }, callback);
}
function putBucketPolicy(params, callback) {
  var Policy = params['Policy'];
  try {
    if (typeof Policy === 'string') Policy = JSON.parse(Policy);
  } catch (e) {}
  if (!Policy || typeof Policy === 'string') return callback(util.error(new Error('Policy format error')));
  var PolicyStr = JSON.stringify(Policy);
  if (!Policy.version) Policy.version = '2.0';
  var headers = params.Headers;
  headers['Content-Type'] = 'application/json';
  headers['Content-MD5'] = util.b64(util.md5(PolicyStr));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketPolicy',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    action: 'policy',
    body: PolicyStr,
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的读取权限策略
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketPolicy(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketPolicy',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'policy',
    rawBody: true,
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode && err.statusCode === 403) {
        return callback(util.error(err, {
          ErrorStatus: 'Access Denied'
        }));
      }
      if (err.statusCode && err.statusCode === 405) {
        return callback(util.error(err, {
          ErrorStatus: 'Method Not Allowed'
        }));
      }
      if (err.statusCode && err.statusCode === 404) {
        return callback(util.error(err, {
          ErrorStatus: 'Policy Not Found'
        }));
      }
      return callback(err);
    }
    var Policy = {};
    try {
      Policy = JSON.parse(data.body);
    } catch (e) {}
    callback(null, {
      Policy: Policy,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 的 跨域设置
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 * @param  {Function}  callback             回调函数，必须
 * @return  {Object}  err                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                  返回的数据
 */
function deleteBucketPolicy(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketPolicy',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'policy',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode || err.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 的标签
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {Array}   params.TagSet  标签设置，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function putBucketTagging(params, callback) {
  var Tagging = params['Tagging'] || {};
  var Tags = Tagging.TagSet || Tagging.Tags || params['Tags'] || [];
  Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
  var xml = util.json2xml({
    Tagging: {
      TagSet: {
        Tag: Tags
      }
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketTagging',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'tagging',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketTagging(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketTagging',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'tagging',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error && (err.error === 'Not Found' || err.error.Code === 'NoSuchTagSet')) {
        var result = {
          Tags: [],
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var Tags = [];
    try {
      Tags = data.Tagging.TagSet.Tag || [];
    } catch (e) {}
    Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
    callback(null, {
      Tags: Tags,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 的 标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function deleteBucketTagging(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketTagging',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'tagging',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function putBucketLifecycle(params, callback) {
  var LifecycleConfiguration = params['LifecycleConfiguration'] || {};
  var Rules = LifecycleConfiguration.Rules || params.Rules || [];
  Rules = util.clone(Rules);
  var xml = util.json2xml({
    LifecycleConfiguration: {
      Rule: Rules
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketLifecycle',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'lifecycle',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function getBucketLifecycle(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketLifecycle',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'lifecycle',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error && err.error.Code === 'NoSuchLifecycleConfiguration') {
        var result = {
          Rules: [],
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var Rules = [];
    try {
      Rules = data.LifecycleConfiguration.Rule || [];
    } catch (e) {}
    Rules = util.clone(util.isArray(Rules) ? Rules : [Rules]);
    callback(null, {
      Rules: Rules,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function deleteBucketLifecycle(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketLifecycle',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'lifecycle',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function putBucketVersioning(params, callback) {
  if (!params['VersioningConfiguration']) {
    callback(util.error(new Error('missing param VersioningConfiguration')));
    return;
  }
  var VersioningConfiguration = params['VersioningConfiguration'] || {};
  var xml = util.json2xml({
    VersioningConfiguration: VersioningConfiguration
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketVersioning',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'versioning',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function getBucketVersioning(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketVersioning',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'versioning',
    tracker: params.tracker
  }, function (err, data) {
    if (!err) {
      !data.VersioningConfiguration && (data.VersioningConfiguration = {});
    }
    callback(err, data);
  });
}
function putBucketReplication(params, callback) {
  var ReplicationConfiguration = util.clone(params.ReplicationConfiguration);
  var xml = util.json2xml({
    ReplicationConfiguration: ReplicationConfiguration
  });
  xml = xml.replace(/<(\/?)Rules>/gi, '<$1Rule>');
  xml = xml.replace(/<(\/?)Tags>/gi, '<$1Tag>');
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketReplication',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'replication',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function getBucketReplication(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketReplication',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'replication',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error && (err.error === 'Not Found' || err.error.Code === 'ReplicationConfigurationnotFoundError')) {
        var result = {
          ReplicationConfiguration: {
            Rules: []
          },
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    !data.ReplicationConfiguration && (data.ReplicationConfiguration = {});
    if (data.ReplicationConfiguration.Rule) {
      data.ReplicationConfiguration.Rules = util.makeArray(data.ReplicationConfiguration.Rule);
      delete data.ReplicationConfiguration.Rule;
    }
    callback(err, data);
  });
}
function deleteBucketReplication(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketReplication',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'replication',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 静态网站配置信息
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 *     @param  {Object}  params.WebsiteConfiguration                        地域名称，必须
 *         @param  {Object}   WebsiteConfiguration.IndexDocument            索引文档，必须
 *         @param  {Object}   WebsiteConfiguration.ErrorDocument            错误文档，非必须
 *         @param  {Object}   WebsiteConfiguration.RedirectAllRequestsTo    重定向所有请求，非必须
 *         @param  {Array}   params.RoutingRules                            重定向规则，非必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function putBucketWebsite(params, callback) {
  if (!params['WebsiteConfiguration']) {
    callback(util.error(new Error('missing param WebsiteConfiguration')));
    return;
  }
  var WebsiteConfiguration = util.clone(params['WebsiteConfiguration'] || {});
  var RoutingRules = WebsiteConfiguration['RoutingRules'] || WebsiteConfiguration['RoutingRule'] || [];
  RoutingRules = util.isArray(RoutingRules) ? RoutingRules : [RoutingRules];
  delete WebsiteConfiguration.RoutingRule;
  delete WebsiteConfiguration.RoutingRules;
  if (RoutingRules.length) WebsiteConfiguration.RoutingRules = {
    RoutingRule: RoutingRules
  };
  var xml = util.json2xml({
    WebsiteConfiguration: WebsiteConfiguration
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketWebsite',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'website',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的静态网站配置信息
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketWebsite(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketWebsite',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    action: 'website',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error.Code === 'NoSuchWebsiteConfiguration') {
        var result = {
          WebsiteConfiguration: {},
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var WebsiteConfiguration = data.WebsiteConfiguration || {};
    if (WebsiteConfiguration['RoutingRules']) {
      var RoutingRules = util.clone(WebsiteConfiguration['RoutingRules'].RoutingRule || []);
      RoutingRules = util.makeArray(RoutingRules);
      WebsiteConfiguration.RoutingRules = RoutingRules;
    }
    callback(null, {
      WebsiteConfiguration: WebsiteConfiguration,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 的静态网站配置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function deleteBucketWebsite(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketWebsite',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'website',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 的防盗链白名单或者黑名单
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 *     @param  {Object}  params.RefererConfiguration                        地域名称，必须
 *         @param  {String}   RefererConfiguration.Status                   是否开启防盗链，枚举值：Enabled、Disabled
 *         @param  {String}   RefererConfiguration.RefererType              防盗链类型，枚举值：Black-List、White-List，必须
 *         @param  {Array}   RefererConfiguration.DomianList.Domain         生效域名，必须
 *         @param  {String}   RefererConfiguration.EmptyReferConfiguration  ，非必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function putBucketReferer(params, callback) {
  if (!params['RefererConfiguration']) {
    callback(util.error(new Error('missing param RefererConfiguration')));
    return;
  }
  var RefererConfiguration = util.clone(params['RefererConfiguration'] || {});
  var DomainList = RefererConfiguration['DomainList'] || {};
  var Domains = DomainList['Domains'] || DomainList['Domain'] || [];
  Domains = util.isArray(Domains) ? Domains : [Domains];
  if (Domains.length) RefererConfiguration.DomainList = {
    Domain: Domains
  };
  var xml = util.json2xml({
    RefererConfiguration: RefererConfiguration
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketReferer',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'referer',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的防盗链白名单或者黑名单
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketReferer(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketReferer',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    action: 'referer',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error.Code === 'NoSuchRefererConfiguration') {
        var result = {
          WebsiteConfiguration: {},
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var RefererConfiguration = data.RefererConfiguration || {};
    if (RefererConfiguration['DomainList']) {
      var Domains = util.makeArray(RefererConfiguration['DomainList'].Domain || []);
      RefererConfiguration.DomainList = {
        Domains: Domains
      };
    }
    callback(null, {
      RefererConfiguration: RefererConfiguration,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 自定义域名
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function putBucketDomain(params, callback) {
  var DomainConfiguration = params['DomainConfiguration'] || {};
  var DomainRule = DomainConfiguration.DomainRule || params.DomainRule || [];
  DomainRule = util.clone(DomainRule);
  var xml = util.json2xml({
    DomainConfiguration: {
      DomainRule: DomainRule
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketDomain',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'domain',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的自定义域名
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketDomain(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketDomain',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'domain',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var DomainRule = [];
    try {
      DomainRule = data.DomainConfiguration.DomainRule || [];
    } catch (e) {}
    DomainRule = util.clone(util.isArray(DomainRule) ? DomainRule : [DomainRule]);
    callback(null, {
      DomainRule: DomainRule,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 自定义域名
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function deleteBucketDomain(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketDomain',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'domain',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 的回源
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function putBucketOrigin(params, callback) {
  var OriginConfiguration = params['OriginConfiguration'] || {};
  var OriginRule = OriginConfiguration.OriginRule || params.OriginRule || [];
  OriginRule = util.clone(OriginRule);
  var xml = util.json2xml({
    OriginConfiguration: {
      OriginRule: OriginRule
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketOrigin',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'origin',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的回源
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketOrigin(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketOrigin',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'origin',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var OriginRule = [];
    try {
      OriginRule = data.OriginConfiguration.OriginRule || [];
    } catch (e) {}
    OriginRule = util.clone(util.isArray(OriginRule) ? OriginRule : [OriginRule]);
    callback(null, {
      OriginRule: OriginRule,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Bucket 的回源
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function deleteBucketOrigin(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketOrigin',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'origin',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 设置 Bucket 的日志记录
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 *     @param  {(Object|String)}  params.BucketLoggingStatus                         说明日志记录配置的状态，如果无子节点信息则意为关闭日志记录，必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function putBucketLogging(params, callback) {
  var xml = util.json2xml({
    BucketLoggingStatus: params['BucketLoggingStatus'] || ''
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketLogging',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'logging',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的日志记录
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketLogging(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketLogging',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'logging',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      BucketLoggingStatus: data.BucketLoggingStatus,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 创建/编辑 Bucket 的清单任务
 * @param  {Object}  params                                                 参数对象，必须
 *     @param  {String}  params.Bucket                                      Bucket名称，必须
 *     @param  {String}  params.Region                                      地域名称，必须
 *     @param  {String}  params.Id                                          清单任务的名称，必须
 *     @param  {Object}  params.InventoryConfiguration                      包含清单的配置参数，必须
 * @param  {Function}  callback                                             回调函数，必须
 * @return  {Object}  err                                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                                  返回数据
 */
function submitBucketInventory(method, params, callback) {
  var InventoryConfiguration = util.clone(params['InventoryConfiguration']);
  if (InventoryConfiguration.OptionalFields) {
    var Field = InventoryConfiguration.OptionalFields || [];
    InventoryConfiguration.OptionalFields = {
      Field: Field
    };
  }
  if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
    var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
    if (Object.keys(Encryption).indexOf('SSECOS') > -1) {
      Encryption['SSE-COS'] = Encryption['SSECOS'];
      delete Encryption['SSECOS'];
    }
  }
  var xml = util.json2xml({
    InventoryConfiguration: InventoryConfiguration
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  var action = method === 'PUT' ? 'name/cos:PutBucketInventory' : 'name/cos:PostBucketInventory';
  submitRequest.call(this, {
    Action: action,
    method: method,
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'inventory',
    qs: {
      id: params['Id']
    },
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 创建一个清单任务
 */
function putBucketInventory(params, callback) {
  return submitBucketInventory.call(this, 'PUT', params, callback);
}

/**
 * 创建一个一次性清单任务 会立即执行
 */
function postBucketInventory(params, callback) {
  return submitBucketInventory.call(this, 'POST', params, callback);
}

/**
 * 获取 Bucket 的清单任务信息
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Id      清单任务的名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function getBucketInventory(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketInventory',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'inventory',
    qs: {
      id: params['Id']
    },
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var InventoryConfiguration = data['InventoryConfiguration'];
    if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
      var Field = InventoryConfiguration.OptionalFields.Field;
      if (!util.isArray(Field)) {
        Field = [Field];
      }
      InventoryConfiguration.OptionalFields = Field;
    }
    if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
      var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
      if (Object.keys(Encryption).indexOf('SSE-COS') > -1) {
        Encryption['SSECOS'] = Encryption['SSE-COS'];
        delete Encryption['SSE-COS'];
      }
    }
    callback(null, {
      InventoryConfiguration: InventoryConfiguration,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Bucket 的清单任务信息
 * @param  {Object}  params                             参数对象，必须
 *     @param  {String}  params.Bucket                  Bucket名称，必须
 *     @param  {String}  params.Region                  地域名称，必须
 *     @param  {String}  params.ContinuationToken       当 COS 响应体中 IsTruncated 为 true，且 NextContinuationToken 节点中存在参数值时，您可以将这个参数作为 continuation-token 参数值，以获取下一页的清单任务信息，非必须
 * @param  {Function}  callback                         回调函数，必须
 * @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                              返回数据
 */
function listBucketInventory(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:ListBucketInventory',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'inventory',
    qs: {
      'continuation-token': params['ContinuationToken']
    },
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var ListInventoryConfigurationResult = data['ListInventoryConfigurationResult'];
    var InventoryConfigurations = ListInventoryConfigurationResult.InventoryConfiguration || [];
    InventoryConfigurations = util.isArray(InventoryConfigurations) ? InventoryConfigurations : [InventoryConfigurations];
    delete ListInventoryConfigurationResult['InventoryConfiguration'];
    util.each(InventoryConfigurations, function (InventoryConfiguration) {
      if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
        var Field = InventoryConfiguration.OptionalFields.Field;
        if (!util.isArray(Field)) {
          Field = [Field];
        }
        InventoryConfiguration.OptionalFields = Field;
      }
      if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
        var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
        if (Object.keys(Encryption).indexOf('SSE-COS') > -1) {
          Encryption['SSECOS'] = Encryption['SSE-COS'];
          delete Encryption['SSE-COS'];
        }
      }
    });
    ListInventoryConfigurationResult.InventoryConfigurations = InventoryConfigurations;
    util.extend(ListInventoryConfigurationResult, {
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, ListInventoryConfigurationResult);
  });
}

/**
 * 删除 Bucket 的清单任务
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Id      清单任务的名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回数据
 */
function deleteBucketInventory(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketInventory',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'inventory',
    qs: {
      id: params['Id']
    },
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/* 全球加速 */
function putBucketAccelerate(params, callback) {
  if (!params['AccelerateConfiguration']) {
    callback(util.error(new Error('missing param AccelerateConfiguration')));
    return;
  }
  var configuration = {
    AccelerateConfiguration: params.AccelerateConfiguration || {}
  };
  var xml = util.json2xml(configuration);
  var headers = {};
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketAccelerate',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'accelerate',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function getBucketAccelerate(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketAccelerate',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    action: 'accelerate',
    tracker: params.tracker
  }, function (err, data) {
    if (!err) {
      !data.AccelerateConfiguration && (data.AccelerateConfiguration = {});
    }
    callback(err, data);
  });
}
function putBucketEncryption(params, callback) {
  var conf = params.ServerSideEncryptionConfiguration || {};
  var Rules = conf.Rule || conf.Rules || [];
  var xml = util.json2xml({
    ServerSideEncryptionConfiguration: {
      Rule: Rules
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutBucketEncryption',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'encryption',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}
function getBucketEncryption(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketEncryption',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'encryption',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.code === 'NoSuchEncryptionConfiguration') {
        var result = {
          EncryptionConfiguration: {
            Rules: []
          },
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var Rules = util.makeArray(data.EncryptionConfiguration && data.EncryptionConfiguration.Rule || []);
    data.EncryptionConfiguration = {
      Rules: Rules
    };
    callback(err, data);
  });
}
function deleteBucketEncryption(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteBucketReplication',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'encryption',
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

// Object 相关

/**
 * 取回对应Object的元数据，Head的权限与Get的权限一致
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Key                 文件名称，必须
 *     @param  {String}  params.IfModifiedSince     当Object在指定时间后被修改，则返回对应Object元信息，否则返回304，非必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          为指定 object 的元数据，如果设置了 IfModifiedSince ，且文件未修改，则返回一个对象，NotModified 属性为 true
 *     @return  {Boolean}  data.NotModified         是否在 IfModifiedSince 时间点之后未修改该 object，则为 true
 */
function headObject(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:HeadObject',
    method: 'HEAD',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    VersionId: params.VersionId,
    headers: params.Headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      var statusCode = err.statusCode;
      if (params.Headers['If-Modified-Since'] && statusCode && statusCode === 304) {
        return callback(null, {
          NotModified: true,
          statusCode: statusCode
        });
      }
      return callback(err);
    }
    data.ETag = util.attr(data.headers, 'etag', '');
    callback(null, data);
  });
}
function listObjectVersions(params, callback) {
  var reqParams = {};
  reqParams['prefix'] = params['Prefix'] || '';
  reqParams['delimiter'] = params['Delimiter'];
  reqParams['key-marker'] = params['KeyMarker'];
  reqParams['version-id-marker'] = params['VersionIdMarker'];
  reqParams['max-keys'] = params['MaxKeys'];
  reqParams['encoding-type'] = params['EncodingType'];
  submitRequest.call(this, {
    Action: 'name/cos:GetBucketObjectVersions',
    ResourceKey: reqParams['prefix'],
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    qs: reqParams,
    action: 'versions',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var ListVersionsResult = data.ListVersionsResult || {};
    var DeleteMarkers = ListVersionsResult.DeleteMarker || [];
    DeleteMarkers = util.isArray(DeleteMarkers) ? DeleteMarkers : [DeleteMarkers];
    var Versions = ListVersionsResult.Version || [];
    Versions = util.isArray(Versions) ? Versions : [Versions];
    var result = util.clone(ListVersionsResult);
    delete result.DeleteMarker;
    delete result.Version;
    util.extend(result, {
      DeleteMarkers: DeleteMarkers,
      Versions: Versions,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 下载 object
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         文件名称，必须
 *     @param  {WriteStream}  params.Output                 文件写入流，非必须
 *     @param  {String}  params.IfModifiedSince             当Object在指定时间后被修改，则返回对应Object元信息，否则返回304，非必须
 *     @param  {String}  params.IfUnmodifiedSince           如果文件修改时间早于或等于指定时间，才返回文件内容。否则返回 412 (precondition failed)，非必须
 *     @param  {String}  params.IfMatch                     当 ETag 与指定的内容一致，才返回文件。否则返回 412 (precondition failed)，非必须
 *     @param  {String}  params.IfNoneMatch                 当 ETag 与指定的内容不一致，才返回文件。否则返回304 (not modified)，非必须
 *     @param  {String}  params.ResponseContentType         设置返回头部中的 Content-Type 参数，非必须
 *     @param  {String}  params.ResponseContentLanguage     设置返回头部中的 Content-Language 参数，非必须
 *     @param  {String}  params.ResponseExpires             设置返回头部中的 Content-Expires 参数，非必须
 *     @param  {String}  params.ResponseCacheControl        设置返回头部中的 Cache-Control 参数，非必须
 *     @param  {String}  params.ResponseContentDisposition  设置返回头部中的 Content-Disposition 参数，非必须
 *     @param  {String}  params.ResponseContentEncoding     设置返回头部中的 Content-Encoding 参数，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @param  {Object}  err                                    请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @param  {Object}  data                                   为对应的 object 数据，包括 body 和 headers
 */
function getObject(params, callback) {
  var reqParams = params.Query || {};
  var reqParamsStr = params.QueryString || '';
  var onProgress = util.throttleOnProgress.call(this, 0, params.onProgress);
  var tracker = params.tracker;
  tracker && tracker.setParams({
    signStartTime: new Date().getTime()
  });
  reqParams['response-content-type'] = params['ResponseContentType'];
  reqParams['response-content-language'] = params['ResponseContentLanguage'];
  reqParams['response-expires'] = params['ResponseExpires'];
  reqParams['response-cache-control'] = params['ResponseCacheControl'];
  reqParams['response-content-disposition'] = params['ResponseContentDisposition'];
  reqParams['response-content-encoding'] = params['ResponseContentEncoding'];

  // 如果用户自己传入了 output
  submitRequest.call(this, {
    Action: 'name/cos:GetObject',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    VersionId: params.VersionId,
    DataType: params.DataType,
    headers: params.Headers,
    qs: reqParams,
    qsStr: reqParamsStr,
    rawBody: true,
    onDownloadProgress: onProgress,
    tracker: tracker
  }, function (err, data) {
    onProgress(null, true);
    if (err) {
      var statusCode = err.statusCode;
      if (params.Headers['If-Modified-Since'] && statusCode && statusCode === 304) {
        return callback(null, {
          NotModified: true
        });
      }
      return callback(err);
    }
    callback(null, {
      Body: data.body,
      ETag: util.attr(data.headers, 'etag', ''),
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 上传 object
 * @param  {Object} params                                          参数对象，必须
 *     @param  {String}  params.Bucket                              Bucket名称，必须
 *     @param  {String}  params.Region                              地域名称，必须
 *     @param  {String}  params.Key                                 文件名称，必须
 *     @param  {File || Blob || String}  params.Body                上传文件对象或字符串，必须
 *     @param  {String}  params.CacheControl                        RFC 2616 中定义的缓存策略，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentDisposition                  RFC 2616 中定义的文件名称，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentEncoding                     RFC 2616 中定义的编码格式，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentLength                       RFC 2616 中定义的 HTTP 请求内容长度（字节），必须
 *     @param  {String}  params.ContentType                         RFC 2616 中定义的内容类型（MIME），将作为 Object 元数据保存，非必须
 *     @param  {String}  params.Expect                              当使用 Expect: 100-continue 时，在收到服务端确认后，才会发送请求内容，非必须
 *     @param  {String}  params.Expires                             RFC 2616 中定义的过期时间，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ACL                                 允许用户自定义文件权限，有效值：private | public-read，非必须
 *     @param  {String}  params.GrantRead                           赋予被授权者读取对象的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantReadAcp                        赋予被授权者读取对象的访问控制列表（ACL）的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantWriteAcp                       赋予被授权者写入对象的访问控制列表（ACL）的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantFullControl                    赋予被授权者操作对象的所有权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.StorageClass                        设置对象的存储级别，枚举值：STANDARD、STANDARD_IA、ARCHIVE，默认值：STANDARD，非必须
 *     @param  {String}  params.x-cos-meta-*                        允许用户自定义的头部信息，将作为对象的元数据保存。大小限制2KB，非必须
 *     @param  {String}  params.ContentSha1                         RFC 3174 中定义的 160-bit 内容 SHA-1 算法校验，非必须
 *     @param  {String}  params.ServerSideEncryption                支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {Function}  params.onProgress                        上传进度回调函数
 * @param  {Function}  callback                                     回调函数，必须
 * @return  {Object}  err                                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                          为对应的 object 数据
 *     @return  {String}  data.ETag                                 为对应上传文件的 ETag 值
 */
function putObject(params, callback) {
  var self = this;
  var FileSize = params.ContentLength;
  var onProgress = util.throttleOnProgress.call(self, FileSize, params.onProgress);

  // 特殊处理 Cache-Control、Content-Type，避免代理更改这两个字段导致写入到 Object 属性里
  var headers = params.Headers;
  if (!headers['Cache-Control'] && !headers['cache-control']) headers['Cache-Control'] = '';
  if (!headers['Content-Type'] && !headers['content-type']) headers['Content-Type'] = params.Body && params.Body.type || '';
  var needCalcMd5 = params.UploadAddMetaMd5 || self.options.UploadAddMetaMd5 || self.options.UploadCheckContentMd5;
  var tracker = params.tracker;
  needCalcMd5 && tracker && tracker.setParams({
    md5StartTime: new Date().getTime()
  });
  util.getBodyMd5(needCalcMd5, params.Body, function (md5) {
    if (md5) {
      tracker && tracker.setParams({
        md5EndTime: new Date().getTime()
      });
      if (self.options.UploadCheckContentMd5) headers['Content-MD5'] = util.b64(md5);
      if (params.UploadAddMetaMd5 || self.options.UploadAddMetaMd5) headers['x-cos-meta-md5'] = md5;
    }
    if (params.ContentLength !== undefined) headers['Content-Length'] = params.ContentLength;
    onProgress(null, true); // 任务状态开始 uploading
    submitRequest.call(self, {
      Action: 'name/cos:PutObject',
      TaskId: params.TaskId,
      method: 'PUT',
      Bucket: params.Bucket,
      Region: params.Region,
      Key: params.Key,
      headers: params.Headers,
      qs: params.Query,
      body: params.Body,
      onProgress: onProgress,
      tracker: tracker
    }, function (err, data) {
      if (err) {
        onProgress(null, true);
        return callback(err);
      }
      onProgress({
        loaded: FileSize,
        total: FileSize
      }, true);
      var url = getUrl({
        ForcePathStyle: self.options.ForcePathStyle,
        protocol: self.options.Protocol,
        domain: self.options.Domain,
        bucket: params.Bucket,
        region: !self.options.UseAccelerate ? params.Region : 'accelerate',
        object: params.Key
      });
      url = url.substr(url.indexOf('://') + 3);
      data.Location = url;
      data.ETag = util.attr(data.headers, 'etag', '');
      callback(null, data);
    });
  }, params.onHashProgress);
}

/**
 * 删除 object
 * @param  {Object}  params                     参数对象，必须
 *     @param  {String}  params.Bucket          Bucket名称，必须
 *     @param  {String}  params.Region          地域名称，必须
 *     @param  {String}  params.Key             object名称，必须
 * @param  {Function}  callback                 回调函数，必须
 * @param  {Object}  err                        请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @param  {Object}  data                       删除操作成功之后返回的数据
 */
function deleteObject(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteObject',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    VersionId: params.VersionId,
    action: params.Recursive ? 'recursive' : '',
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      var statusCode = err.statusCode;
      if (statusCode && statusCode === 404) {
        return callback(null, {
          BucketNotFound: true,
          statusCode: statusCode
        });
      } else {
        return callback(err);
      }
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 object 的 权限列表
 * @param  {Object}  params                         参数对象，必须
 *     @param  {String}  params.Bucket              Bucket名称，必须
 *     @param  {String}  params.Region              地域名称，必须
 *     @param  {String}  params.Key                 object名称，必须
 * @param  {Function}  callback                     回调函数，必须
 * @return  {Object}  err                           请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                          返回的数据
 *     @return  {Object}  data.AccessControlPolicy  权限列表
 */
function getObjectAcl(params, callback) {
  var reqParams = {};
  if (params.VersionId) {
    reqParams.versionId = params.VersionId;
  }
  submitRequest.call(this, {
    Action: 'name/cos:GetObjectACL',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    qs: reqParams,
    action: 'acl',
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var AccessControlPolicy = data.AccessControlPolicy || {};
    var Owner = AccessControlPolicy.Owner || {};
    var Grant = AccessControlPolicy.AccessControlList && AccessControlPolicy.AccessControlList.Grant || [];
    Grant = util.isArray(Grant) ? Grant : [Grant];
    var result = decodeAcl(AccessControlPolicy);
    delete result.GrantWrite;
    if (data.headers && data.headers['x-cos-acl']) {
      result.ACL = data.headers['x-cos-acl'];
    }
    result = util.extend(result, {
      Owner: Owner,
      Grants: Grant,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 设置 object 的 权限列表
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Key     object名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function putObjectAcl(params, callback) {
  var headers = params.Headers;
  var xml = '';
  if (params['AccessControlPolicy']) {
    var AccessControlPolicy = util.clone(params['AccessControlPolicy'] || {});
    var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
    Grants = util.isArray(Grants) ? Grants : [Grants];
    delete AccessControlPolicy.Grant;
    delete AccessControlPolicy.Grants;
    AccessControlPolicy.AccessControlList = {
      Grant: Grants
    };
    xml = util.json2xml({
      AccessControlPolicy: AccessControlPolicy
    });
    headers['Content-Type'] = 'application/xml';
    headers['Content-MD5'] = util.b64(util.md5(xml));
  }

  // Grant Header 去重
  util.each(headers, function (val, key) {
    if (key.indexOf('x-cos-grant-') === 0) {
      headers[key] = uniqGrant(headers[key]);
    }
  });
  submitRequest.call(this, {
    Action: 'name/cos:PutObjectACL',
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    action: 'acl',
    headers: headers,
    body: xml,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * Options Object请求实现跨域访问的预请求。即发出一个 OPTIONS 请求给服务器以确认是否可以进行跨域操作。
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {String}  params.Key     object名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data              返回的数据
 */
function optionsObject(params, callback) {
  var headers = params.Headers;
  headers['Origin'] = params['Origin'];
  headers['Access-Control-Request-Method'] = params['AccessControlRequestMethod'];
  headers['Access-Control-Request-Headers'] = params['AccessControlRequestHeaders'];
  submitRequest.call(this, {
    Action: 'name/cos:OptionsObject',
    method: 'OPTIONS',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode && err.statusCode === 403) {
        return callback(null, {
          OptionsForbidden: true,
          statusCode: err.statusCode
        });
      }
      return callback(err);
    }
    var headers = data.headers || {};
    callback(null, {
      AccessControlAllowOrigin: headers['access-control-allow-origin'],
      AccessControlAllowMethods: headers['access-control-allow-methods'],
      AccessControlAllowHeaders: headers['access-control-allow-headers'],
      AccessControlExposeHeaders: headers['access-control-expose-headers'],
      AccessControlMaxAge: headers['access-control-max-age'],
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * @param  {Object}                                     参数列表
 *     @param  {String}  Bucket                         Bucket 名称
 *     @param  {String}  Region                         地域名称
 *     @param  {String}  Key                            文件名称
 *     @param  {String}  CopySource                     源文件URL绝对路径，可以通过versionid子资源指定历史版本
 *     @param  {String}  ACL                            允许用户自定义文件权限。有效值：private，public-read默认值：private。
 *     @param  {String}  GrantRead                      赋予被授权者读的权限，格式 x-cos-grant-read: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  GrantWrite                     赋予被授权者写的权限，格式 x-cos-grant-write: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  GrantFullControl               赋予被授权者读写权限，格式 x-cos-grant-full-control: uin=" ",uin=" "，当需要给子账户授权时，uin="RootAcountID/SubAccountID"，当需要给根账户授权时，uin="RootAcountID"。
 *     @param  {String}  MetadataDirective              是否拷贝元数据，枚举值：Copy, Replaced，默认值Copy。假如标记为Copy，忽略Header中的用户元数据信息直接复制；假如标记为Replaced，按Header信息修改元数据。当目标路径和原路径一致，即用户试图修改元数据时，必须为Replaced
 *     @param  {String}  CopySourceIfModifiedSince      当Object在指定时间后被修改，则执行操作，否则返回412。可与x-cos-copy-source-If-None-Match一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfUnmodifiedSince    当Object在指定时间后未被修改，则执行操作，否则返回412。可与x-cos-copy-source-If-Match一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfMatch              当Object的ETag和给定一致时，则执行操作，否则返回412。可与x-cos-copy-source-If-Unmodified-Since一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  CopySourceIfNoneMatch          当Object的ETag和给定不一致时，则执行操作，否则返回412。可与x-cos-copy-source-If-Modified-Since一起使用，与其他条件联合使用返回冲突。
 *     @param  {String}  StorageClass                   存储级别，枚举值：存储级别，枚举值：Standard, Standard_IA，Archive；默认值：Standard
 *     @param  {String}  CacheControl                   指定所有缓存机制在整个请求/响应链中必须服从的指令。
 *     @param  {String}  ContentDisposition             MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件
 *     @param  {String}  ContentEncoding                HTTP 中用来对「采用何种编码格式传输正文」进行协定的一对头部字段
 *     @param  {String}  ContentLength                  设置响应消息的实体内容的大小，单位为字节
 *     @param  {String}  ContentType                    RFC 2616 中定义的 HTTP 请求内容类型（MIME），例如text/plain
 *     @param  {String}  Expect                         请求的特定的服务器行为
 *     @param  {String}  Expires                        响应过期的日期和时间
 *     @param  {String}  params.ServerSideEncryption   支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {String}  ContentLanguage                指定内容语言
 *     @param  {String}  x-cos-meta-*                   允许用户自定义的头部信息，将作为 Object 元数据返回。大小限制2K。
 */
function putObjectCopy(params, callback) {
  // 特殊处理 Cache-Control
  var self = this;
  var headers = params.Headers;
  if (!headers['Cache-Control'] && !headers['cache-control']) headers['Cache-Control'] = '';
  var CopySource = params.CopySource || '';
  var m = util.getSourceParams.call(this, CopySource);
  if (!m) {
    callback(util.error(new Error('CopySource format error')));
    return;
  }
  var SourceBucket = m.Bucket;
  var SourceRegion = m.Region;
  var SourceKey = decodeURIComponent(m.Key);
  submitRequest.call(this, {
    Scope: [{
      action: 'name/cos:GetObject',
      bucket: SourceBucket,
      region: SourceRegion,
      prefix: SourceKey
    }, {
      action: 'name/cos:PutObject',
      bucket: params.Bucket,
      region: params.Region,
      prefix: params.Key
    }],
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    VersionId: params.VersionId,
    headers: params.Headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var result = util.clone(data.CopyObjectResult || {});
    var url = getUrl({
      ForcePathStyle: self.options.ForcePathStyle,
      protocol: self.options.Protocol,
      domain: self.options.Domain,
      bucket: params.Bucket,
      region: params.Region,
      object: params.Key,
      isLocation: true
    });
    util.extend(result, {
      Location: url,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}
function uploadPartCopy(params, callback) {
  var CopySource = params.CopySource || '';
  var m = util.getSourceParams.call(this, CopySource);
  if (!m) {
    callback(util.error(new Error('CopySource format error')));
    return;
  }
  var SourceBucket = m.Bucket;
  var SourceRegion = m.Region;
  var SourceKey = decodeURIComponent(m.Key);
  submitRequest.call(this, {
    Scope: [{
      action: 'name/cos:GetObject',
      bucket: SourceBucket,
      region: SourceRegion,
      prefix: SourceKey
    }, {
      action: 'name/cos:PutObject',
      bucket: params.Bucket,
      region: params.Region,
      prefix: params.Key
    }],
    method: 'PUT',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    VersionId: params.VersionId,
    qs: {
      partNumber: params['PartNumber'],
      uploadId: params['UploadId']
    },
    headers: params.Headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var result = util.clone(data.CopyPartResult || {});
    util.extend(result, {
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}
function deleteMultipleObject(params, callback) {
  var Objects = params.Objects || [];
  var Quiet = params.Quiet;
  Objects = util.isArray(Objects) ? Objects : [Objects];
  var xml = util.json2xml({
    Delete: {
      Object: Objects,
      Quiet: Quiet || false
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  var Scope = util.map(Objects, function (v) {
    return {
      action: 'name/cos:DeleteObject',
      bucket: params.Bucket,
      region: params.Region,
      prefix: v.Key
    };
  });
  submitRequest.call(this, {
    Scope: Scope,
    method: 'POST',
    Bucket: params.Bucket,
    Region: params.Region,
    body: xml,
    action: 'delete',
    headers: headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    var DeleteResult = data.DeleteResult || {};
    var Deleted = DeleteResult.Deleted || [];
    var Errors = DeleteResult.Error || [];
    Deleted = util.isArray(Deleted) ? Deleted : [Deleted];
    Errors = util.isArray(Errors) ? Errors : [Errors];
    var result = util.clone(DeleteResult);
    util.extend(result, {
      Error: Errors,
      Deleted: Deleted,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}
function restoreObject(params, callback) {
  var headers = params.Headers;
  if (!params['RestoreRequest']) {
    callback(util.error(new Error('missing param RestoreRequest')));
    return;
  }
  var RestoreRequest = params.RestoreRequest || {};
  var xml = util.json2xml({
    RestoreRequest: RestoreRequest
  });
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:RestoreObject',
    method: 'POST',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    VersionId: params.VersionId,
    body: xml,
    action: 'restore',
    headers: headers,
    tracker: params.tracker
  }, callback);
}

/**
 * 设置 Object 的标签
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Object名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 *     @param  {Array}   params.TagSet  标签设置，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/42998
 * @return  {Object}  data              返回数据
 */
function putObjectTagging(params, callback) {
  var Tagging = params['Tagging'] || {};
  var Tags = Tagging.TagSet || Tagging.Tags || params['Tags'] || [];
  Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
  var xml = util.json2xml({
    Tagging: {
      TagSet: {
        Tag: Tags
      }
    }
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:PutObjectTagging',
    method: 'PUT',
    Bucket: params.Bucket,
    Key: params.Key,
    Region: params.Region,
    body: xml,
    action: 'tagging',
    headers: headers,
    VersionId: params.VersionId,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 获取 Object 的标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Bucket名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/42998
 * @return  {Object}  data              返回数据
 */
function getObjectTagging(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:GetObjectTagging',
    method: 'GET',
    Key: params.Key,
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    action: 'tagging',
    VersionId: params.VersionId,
    tracker: params.tracker
  }, function (err, data) {
    if (err) {
      if (err.statusCode === 404 && err.error && (err.error === 'Not Found' || err.error.Code === 'NoSuchTagSet')) {
        var result = {
          Tags: [],
          statusCode: err.statusCode
        };
        err.headers && (result.headers = err.headers);
        callback(null, result);
      } else {
        callback(err);
      }
      return;
    }
    var Tags = [];
    try {
      Tags = data.Tagging.TagSet.Tag || [];
    } catch (e) {}
    Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
    callback(null, {
      Tags: Tags,
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 删除 Object 的 标签设置
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Bucket  Object名称，必须
 *     @param  {String}  params.Region  地域名称，必须
 * @param  {Function}  callback         回调函数，必须
 * @return  {Object}  err               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/42998
 * @return  {Object}  data              返回的数据
 */
function deleteObjectTagging(params, callback) {
  submitRequest.call(this, {
    Action: 'name/cos:DeleteObjectTagging',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    action: 'tagging',
    VersionId: params.VersionId,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 使用 SQL 语句从指定对象（CSV 格式或者 JSON 格式）中检索内容
 * @param  {Object}  params                   参数对象，必须
 *     @param  {String}  params.Bucket        Object名称，必须
 *     @param  {String}  params.Region        地域名称，必须
 *     @param  {Object}  params.SelectRequest 地域名称，必须
 * @param  {Function}  callback               回调函数，必须
 * @return  {Object}  err                     请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/42998
 * @return  {Object}  data                    返回的数据
 */
function selectObjectContent(params, callback) {
  var SelectType = params['SelectType'];
  if (!SelectType) return callback(util.error(new Error('missing param SelectType')));
  var SelectRequest = params['SelectRequest'] || {};
  var xml = util.json2xml({
    SelectRequest: SelectRequest
  });
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:GetObject',
    method: 'POST',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    action: 'select',
    qs: {
      'select-type': params['SelectType']
    },
    VersionId: params.VersionId,
    body: xml,
    DataType: 'arraybuffer',
    rawBody: true,
    tracker: params.tracker
  }, function (err, data) {
    if (err && err.statusCode === 204) {
      return callback(null, {
        statusCode: err.statusCode
      });
    } else if (err) {
      return callback(err);
    }
    var result = util.parseSelectPayload(data.body);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers,
      Body: result.body,
      Payload: result.payload
    });
  });
}

// 分块上传

/**
 * 初始化分块上传
 * @param  {Object}  params                                     参数对象，必须
 *     @param  {String}  params.Bucket                          Bucket名称，必须
 *     @param  {String}  params.Region                          地域名称，必须
 *     @param  {String}  params.Key                             object名称，必须
 *     @param  {String}  params.UploadId                        object名称，必须
 *     @param  {String}  params.CacheControl                    RFC 2616 中定义的缓存策略，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentDisposition              RFC 2616 中定义的文件名称，将作为 Object 元数据保存    ，非必须
 *     @param  {String}  params.ContentEncoding                 RFC 2616 中定义的编码格式，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentType                     RFC 2616 中定义的内容类型（MIME），将作为 Object 元数据保存，非必须
 *     @param  {String}  params.Expires                         RFC 2616 中定义的过期时间，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ACL                             允许用户自定义文件权限，非必须
 *     @param  {String}  params.GrantRead                       赋予被授权者读的权限 ，非必须
 *     @param  {String}  params.GrantWrite                      赋予被授权者写的权限 ，非必须
 *     @param  {String}  params.GrantFullControl                赋予被授权者读写权限 ，非必须
 *     @param  {String}  params.StorageClass                    设置Object的存储级别，枚举值：Standard，Standard_IA，Archive，非必须
 *     @param  {String}  params.ServerSideEncryption           支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 * @param  {Function}  callback                                 回调函数，必须
 * @return  {Object}  err                                       请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                      返回的数据
 */
function multipartInit(params, callback) {
  var self = this;
  // 特殊处理 Cache-Control
  var headers = params.Headers;
  var tracker = params.tracker;

  // 特殊处理 Cache-Control、Content-Type
  if (!headers['Cache-Control'] && !headers['cache-control']) headers['Cache-Control'] = '';
  if (!headers['Content-Type'] && !headers['content-type']) headers['Content-Type'] = params.Body && params.Body.type || '';
  var needCalcMd5 = params.Body && (params.UploadAddMetaMd5 || self.options.UploadAddMetaMd5);
  needCalcMd5 && tracker && tracker.setParams({
    md5StartTime: new Date().getTime()
  });
  util.getBodyMd5(needCalcMd5, params.Body, function (md5) {
    if (md5) params.Headers['x-cos-meta-md5'] = md5;
    needCalcMd5 && tracker && tracker.setParams({
      md5EndTime: new Date().getTime()
    });
    submitRequest.call(self, {
      Action: 'name/cos:InitiateMultipartUpload',
      method: 'POST',
      Bucket: params.Bucket,
      Region: params.Region,
      Key: params.Key,
      action: 'uploads',
      headers: params.Headers,
      qs: params.Query,
      tracker: tracker
    }, function (err, data) {
      if (err) {
        tracker && tracker.parent && tracker.parent.setParams({
          errorNode: 'multipartInit'
        });
        return callback(err);
      }
      data = util.clone(data || {});
      if (data && data.InitiateMultipartUploadResult) {
        return callback(null, util.extend(data.InitiateMultipartUploadResult, {
          statusCode: data.statusCode,
          headers: data.headers
        }));
      }
      callback(null, data);
    });
  }, params.onHashProgress);
}

/**
 * 分块上传
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         object名称，必须
 *     @param  {File || Blob || String}  params.Body        上传文件对象或字符串
 *     @param  {String} params.ContentLength                RFC 2616 中定义的 HTTP 请求内容长度（字节），非必须
 *     @param  {String} params.Expect                       当使用 Expect: 100-continue 时，在收到服务端确认后，才会发送请求内容，非必须
 *     @param  {String} params.ServerSideEncryption         支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 *     @param  {String} params.ContentSha1                  RFC 3174 中定义的 160-bit 内容 SHA-1 算法校验值，非必须
 * @param  {Function}  callback                             回调函数，必须
 *     @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}  data                              返回的数据
 *     @return  {Object}  data.ETag                         返回的文件分块 sha1 值
 */
function multipartUpload(params, callback) {
  var self = this;
  util.getFileSize('multipartUpload', params, function () {
    var tracker = params.tracker;
    var needCalcMd5 = self.options.UploadCheckContentMd5;
    needCalcMd5 && tracker && tracker.setParams({
      md5StartTime: new Date().getTime()
    });
    util.getBodyMd5(needCalcMd5, params.Body, function (md5) {
      if (md5) params.Headers['Content-MD5'] = util.b64(md5);
      needCalcMd5 && tracker && tracker.setParams({
        md5EndTime: new Date().getTime()
      });
      tracker && tracker.setParams({
        partNumber: params.PartNumber
      });
      submitRequest.call(self, {
        Action: 'name/cos:UploadPart',
        TaskId: params.TaskId,
        method: 'PUT',
        Bucket: params.Bucket,
        Region: params.Region,
        Key: params.Key,
        qs: {
          partNumber: params['PartNumber'],
          uploadId: params['UploadId']
        },
        headers: params.Headers,
        onProgress: params.onProgress,
        body: params.Body || null,
        tracker: tracker
      }, function (err, data) {
        if (err) {
          tracker && tracker.parent && tracker.parent.setParams({
            errorNode: 'multipartUpload'
          });
          return callback(err);
        }
        callback(null, {
          ETag: util.attr(data.headers, 'etag', ''),
          statusCode: data.statusCode,
          headers: data.headers
        });
      });
    });
  });
}

/**
 * 完成分块上传
 * @param  {Object}  params                             参数对象，必须
 *     @param  {String}  params.Bucket                  Bucket名称，必须
 *     @param  {String}  params.Region                  地域名称，必须
 *     @param  {String}  params.Key                     object名称，必须
 *     @param  {Array}   params.Parts                   分块信息列表，必须
 *     @param  {String}  params.Parts[i].PartNumber     块编号，必须
 *     @param  {String}  params.Parts[i].ETag           分块的 sha1 校验值
 * @param  {Function}  callback                         回调函数，必须
 * @return  {Object}  err                               请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                              返回的数据
 *     @return  {Object}  data.CompleteMultipartUpload  完成分块上传后的文件信息，包括Location, Bucket, Key 和 ETag
 */
function multipartComplete(params, callback) {
  var self = this;
  var UploadId = params.UploadId;
  var Parts = params['Parts'];
  var tracker = params.tracker;
  for (var i = 0, len = Parts.length; i < len; i++) {
    if (Parts[i]['ETag'] && Parts[i]['ETag'].indexOf('"') === 0) {
      continue;
    }
    Parts[i]['ETag'] = '"' + Parts[i]['ETag'] + '"';
  }
  var xml = util.json2xml({
    CompleteMultipartUpload: {
      Part: Parts
    }
  });
  // CSP/ceph CompleteMultipartUpload 接口 body 写死了限制 1MB，这里最多 10000 片时，xml 字符串去掉空格853KB
  xml = xml.replace(/\n\s*/g, '');
  var headers = params.Headers;
  headers['Content-Type'] = 'application/xml';
  headers['Content-MD5'] = util.b64(util.md5(xml));
  submitRequest.call(this, {
    Action: 'name/cos:CompleteMultipartUpload',
    method: 'POST',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    qs: {
      uploadId: UploadId
    },
    body: xml,
    headers: headers,
    tracker: tracker
  }, function (err, data) {
    if (err) {
      tracker && tracker.parent && tracker.parent.setParams({
        errorNode: 'multipartComplete'
      });
      return callback(err);
    }
    var url = getUrl({
      ForcePathStyle: self.options.ForcePathStyle,
      protocol: self.options.Protocol,
      domain: self.options.Domain,
      bucket: params.Bucket,
      region: params.Region,
      object: params.Key,
      isLocation: true
    });
    var res = data.CompleteMultipartUploadResult || {};
    if (res.ProcessResults) {
      if (res && res.ProcessResults) {
        res.UploadResult = {
          OriginalInfo: {
            Key: res.Key,
            Location: url,
            ETag: res.ETag,
            ImageInfo: res.ImageInfo
          },
          ProcessResults: res.ProcessResults
        };
        delete res.ImageInfo;
        delete res.ProcessResults;
      }
    }
    var result = util.extend(res, {
      Location: url,
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 分块上传任务列表查询
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Delimiter                   定界符为一个符号，如果有Prefix，则将Prefix到delimiter之间的相同路径归为一类，定义为Common Prefix，然后列出所有Common Prefix。如果没有Prefix，则从路径起点开始，非必须
 *     @param  {String}  params.EncodingType                规定返回值的编码方式，非必须
 *     @param  {String}  params.Prefix                      前缀匹配，用来规定返回的文件前缀地址，非必须
 *     @param  {String}  params.MaxUploads                  单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.KeyMarker                   与upload-id-marker一起使用 </Br>当upload-id-marker未被指定时，ObjectName字母顺序大于key-marker的条目将被列出 </Br>当upload-id-marker被指定时，ObjectName字母顺序大于key-marker的条目被列出，ObjectName字母顺序等于key-marker同时UploadId大于upload-id-marker的条目将被列出，非必须
 *     @param  {String}  params.UploadIdMarker              与key-marker一起使用 </Br>当key-marker未被指定时，upload-id-marker将被忽略 </Br>当key-marker被指定时，ObjectName字母顺序大于key-marker的条目被列出，ObjectName字母顺序等于key-marker同时UploadId大于upload-id-marker的条目将被列出，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @return  {Object}  err                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                  返回的数据
 *     @return  {Object}  data.ListMultipartUploadsResult   分块上传任务信息
 */
function multipartList(params, callback) {
  var reqParams = {};
  reqParams['delimiter'] = params['Delimiter'];
  reqParams['encoding-type'] = params['EncodingType'];
  reqParams['prefix'] = params['Prefix'] || '';
  reqParams['max-uploads'] = params['MaxUploads'];
  reqParams['key-marker'] = params['KeyMarker'];
  reqParams['upload-id-marker'] = params['UploadIdMarker'];
  reqParams = util.clearKey(reqParams);
  var tracker = params.tracker;
  tracker && tracker.setParams({
    signStartTime: new Date().getTime()
  });
  submitRequest.call(this, {
    Action: 'name/cos:ListMultipartUploads',
    ResourceKey: reqParams['prefix'],
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    headers: params.Headers,
    qs: reqParams,
    action: 'uploads',
    tracker: tracker
  }, function (err, data) {
    if (err) {
      tracker && tracker.parent && tracker.parent.setParams({
        errorNode: 'multipartList'
      });
      return callback(err);
    }
    if (data && data.ListMultipartUploadsResult) {
      var Upload = data.ListMultipartUploadsResult.Upload || [];
      Upload = util.isArray(Upload) ? Upload : [Upload];
      data.ListMultipartUploadsResult.Upload = Upload;
    }
    var result = util.clone(data.ListMultipartUploadsResult || {});
    util.extend(result, {
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 上传的分块列表查询
 * @param  {Object}  params                                 参数对象，必须
 *     @param  {String}  params.Bucket                      Bucket名称，必须
 *     @param  {String}  params.Region                      地域名称，必须
 *     @param  {String}  params.Key                         object名称，必须
 *     @param  {String}  params.UploadId                    标示本次分块上传的ID，必须
 *     @param  {String}  params.EncodingType                规定返回值的编码方式，非必须
 *     @param  {String}  params.MaxParts                    单次返回最大的条目数量，默认1000，非必须
 *     @param  {String}  params.PartNumberMarker            默认以UTF-8二进制顺序列出条目，所有列出条目从marker开始，非必须
 * @param  {Function}  callback                             回调函数，必须
 * @return  {Object}  err                                   请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 * @return  {Object}  data                                  返回的数据
 *     @return  {Object}  data.ListMultipartUploadsResult   分块信息
 */
function multipartListPart(params, callback) {
  var reqParams = {};
  var tracker = params.tracker;
  reqParams['uploadId'] = params['UploadId'];
  reqParams['encoding-type'] = params['EncodingType'];
  reqParams['max-parts'] = params['MaxParts'];
  reqParams['part-number-marker'] = params['PartNumberMarker'];
  submitRequest.call(this, {
    Action: 'name/cos:ListParts',
    method: 'GET',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    qs: reqParams,
    tracker: tracker
  }, function (err, data) {
    if (err) {
      tracker && tracker.parent && tracker.parent.setParams({
        errorNode: 'multipartListPart'
      });
      return callback(err);
    }
    var ListPartsResult = data.ListPartsResult || {};
    var Part = ListPartsResult.Part || [];
    Part = util.isArray(Part) ? Part : [Part];
    ListPartsResult.Part = Part;
    var result = util.clone(ListPartsResult);
    util.extend(result, {
      statusCode: data.statusCode,
      headers: data.headers
    });
    callback(null, result);
  });
}

/**
 * 抛弃分块上传
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 *     @param  {String}  params.Key         object名称，必须
 *     @param  {String}  params.UploadId    标示本次分块上传的ID，必须
 * @param  {Function}  callback             回调函数，必须
 *     @return  {Object}    err             请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data            返回的数据
 */
function multipartAbort(params, callback) {
  var reqParams = {};
  reqParams['uploadId'] = params['UploadId'];
  submitRequest.call(this, {
    Action: 'name/cos:AbortMultipartUpload',
    method: 'DELETE',
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    headers: params.Headers,
    qs: reqParams,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, {
      statusCode: data.statusCode,
      headers: data.headers
    });
  });
}

/**
 * 抛弃分块上传
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 *     @param  {String}  params.Key         object名称，必须
 *     @param  {String}  params.UploadId    标示本次分块上传的ID，必须
 * @param  {Function}  callback             回调函数，必须
 *     @return  {Object}    err             请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data            返回的数据
 */
function request(params, callback) {
  submitRequest.call(this, {
    method: params.Method,
    Bucket: params.Bucket,
    Region: params.Region,
    Key: params.Key,
    action: params.Action,
    headers: params.Headers,
    qs: params.Query,
    body: params.Body,
    Url: params.Url,
    rawBody: params.RawBody,
    DataType: params.DataType,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    if (data && data.body) {
      data.Body = data.body;
      delete data.body;
    }
    callback(err, data);
  });
}

/**
 * 追加上传
 * @param  {Object}  params                                         参数对象，必须
 *     @param  {String}  params.Bucket                              Bucket名称，必须
 *     @param  {String}  params.Region                              地域名称，必须
 *     @param  {String}  params.Key                                 object名称，必须
 *     @param  {File || Blob || String}  params.Body                上传文件对象或字符串
 *     @param  {Number}  params.Position                            追加操作的起始点，单位为字节，必须
 *     @param  {String}  params.CacheControl                        RFC 2616 中定义的缓存策略，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentDisposition                  RFC 2616 中定义的文件名称，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentEncoding                     RFC 2616 中定义的编码格式，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ContentLength                       RFC 2616 中定义的 HTTP 请求内容长度（字节），必须
 *     @param  {String}  params.ContentType                         RFC 2616 中定义的内容类型（MIME），将作为 Object 元数据保存，非必须
 *     @param  {String}  params.Expect                              当使用 Expect: 100-continue 时，在收到服务端确认后，才会发送请求内容，非必须
 *     @param  {String}  params.Expires                             RFC 2616 中定义的过期时间，将作为 Object 元数据保存，非必须
 *     @param  {String}  params.ACL                                 允许用户自定义文件权限，有效值：private | public-read，非必须
 *     @param  {String}  params.GrantRead                           赋予被授权者读取对象的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantReadAcp                        赋予被授权者读取对象的访问控制列表（ACL）的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantWriteAcp                       赋予被授权者写入对象的访问控制列表（ACL）的权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.GrantFullControl                    赋予被授权者操作对象的所有权限，格式：id="[OwnerUin]"，可使用半角逗号（,）分隔多组被授权者，非必须
 *     @param  {String}  params.StorageClass                        设置对象的存储级别，枚举值：STANDARD、STANDARD_IA、ARCHIVE，默认值：STANDARD，非必须
 *     @param  {String}  params.x-cos-meta-*                        允许用户自定义的头部信息，将作为对象的元数据保存。大小限制2KB，非必须
 *     @param  {String}  params.ContentSha1                         RFC 3174 中定义的 160-bit 内容 SHA-1 算法校验，非必须
 *     @param  {String}  params.ServerSideEncryption                支持按照指定的加密算法进行服务端数据加密，格式 x-cos-server-side-encryption: "AES256"，非必须
 * @param  {Function}  callback                                     回调函数，必须
 *     @return  {Object}    err                                     请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data                                    返回的数据
 */
function appendObject(params, callback) {
  // 特殊处理 Cache-Control、Content-Type，避免代理更改这两个字段导致写入到 Object 属性里
  var headers = params.Headers;
  if (!headers['Cache-Control'] && !headers['cache-control']) headers['Cache-Control'] = '';
  if (!headers['Content-Type'] && !headers['content-type']) headers['Content-Type'] = params.Body && params.Body.type || '';
  submitRequest.call(this, {
    Action: 'name/cos:AppendObject',
    method: 'POST',
    Bucket: params.Bucket,
    Region: params.Region,
    action: 'append',
    Key: params.Key,
    body: params.Body,
    qs: {
      position: params.Position
    },
    headers: params.Headers,
    tracker: params.tracker
  }, function (err, data) {
    if (err) return callback(err);
    callback(null, data);
  });
}

/**
 * 获取签名
 * @param  {Object}  params             参数对象，必须
 *     @param  {String}  params.Method  请求方法，必须
 *     @param  {String}  params.Key     object名称，必须
 *     @param  {String}  params.Expires 名超时时间，单位秒，可选
 * @return  {String}  data              返回签名字符串
 */
function getAuth(params) {
  var self = this;
  return util.getAuth({
    SecretId: params.SecretId || this.options.SecretId || '',
    SecretKey: params.SecretKey || this.options.SecretKey || '',
    Bucket: params.Bucket,
    Region: params.Region,
    Method: params.Method,
    Key: params.Key,
    Query: params.Query,
    Headers: params.Headers,
    Expires: params.Expires,
    UseRawKey: self.options.UseRawKey,
    SystemClockOffset: self.options.SystemClockOffset
  });
}

/**
 * 获取文件下载链接
 * @param  {Object}  params                 参数对象，必须
 *     @param  {String}  params.Bucket      Bucket名称，必须
 *     @param  {String}  params.Region      地域名称，必须
 *     @param  {String}  params.Key         object名称，必须
 *     @param  {String}  params.Method      请求的方法，可选
 *     @param  {String}  params.Expires     签名超时时间，单位秒，可选
 * @param  {Function}  callback             回调函数，必须
 *     @return  {Object}    err             请求失败的错误，如果请求成功，则为空。https://cloud.tencent.com/document/product/436/7730
 *     @return  {Object}    data            返回的数据
 */
function getObjectUrl(params, callback) {
  var self = this;
  var useAccelerate = params.UseAccelerate === undefined ? self.options.UseAccelerate : params.UseAccelerate;
  var url = getUrl({
    ForcePathStyle: self.options.ForcePathStyle,
    protocol: params.Protocol || self.options.Protocol,
    domain: params.Domain || self.options.Domain,
    bucket: params.Bucket,
    region: useAccelerate ? 'accelerate' : params.Region,
    object: params.Key
  });
  var queryParamsStr = '';
  if (params.Query) {
    queryParamsStr += util.obj2str(params.Query);
  }
  if (params.QueryString) {
    queryParamsStr += (queryParamsStr ? '&' : '') + params.QueryString;
  }
  var syncUrl = url;
  if (params.Sign !== undefined && !params.Sign) {
    queryParamsStr && (syncUrl += '?' + queryParamsStr);
    callback(null, {
      Url: syncUrl
    });
    return syncUrl;
  }

  // 签名加上 Host，避免跨桶访问
  var SignHost = getSignHost.call(this, {
    Bucket: params.Bucket,
    Region: params.Region,
    UseAccelerate: params.UseAccelerate,
    Url: url
  });
  var AuthData = getAuthorizationAsync.call(this, {
    Action: (params.Method || '').toUpperCase() === 'PUT' ? 'name/cos:PutObject' : 'name/cos:GetObject',
    Bucket: params.Bucket || '',
    Region: params.Region || '',
    Method: params.Method || 'get',
    Key: params.Key,
    Expires: params.Expires,
    Headers: params.Headers,
    Query: params.Query,
    SignHost: SignHost,
    ForceSignHost: params.ForceSignHost === false ? false : self.options.ForceSignHost // getObjectUrl支持传参ForceSignHost
  }, function (err, AuthData) {
    if (!callback) return;
    if (err) {
      callback(err);
      return;
    }

    // 兼容万象url qUrlParamList需要再encode一次
    var replaceUrlParamList = function replaceUrlParamList(url) {
      var urlParams = url.match(/q-url-param-list.*?(?=&)/g)[0];
      var encodedParams = 'q-url-param-list=' + encodeURIComponent(urlParams.replace(/q-url-param-list=/, '')).toLowerCase();
      var reg = new RegExp(urlParams, 'g');
      var replacedUrl = url.replace(reg, encodedParams);
      return replacedUrl;
    };
    var signUrl = url;
    signUrl += '?' + (AuthData.Authorization.indexOf('q-signature') > -1 ? replaceUrlParamList(AuthData.Authorization) : 'sign=' + encodeURIComponent(AuthData.Authorization));
    AuthData.SecurityToken && (signUrl += '&x-cos-security-token=' + AuthData.SecurityToken);
    AuthData.ClientIP && (signUrl += '&clientIP=' + AuthData.ClientIP);
    AuthData.ClientUA && (signUrl += '&clientUA=' + AuthData.ClientUA);
    AuthData.Token && (signUrl += '&token=' + AuthData.Token);
    queryParamsStr && (signUrl += '&' + queryParamsStr);
    setTimeout(function () {
      callback(null, {
        Url: signUrl
      });
    });
  });
  if (AuthData) {
    syncUrl += '?' + AuthData.Authorization + (AuthData.SecurityToken ? '&x-cos-security-token=' + AuthData.SecurityToken : '');
    queryParamsStr && (syncUrl += '&' + queryParamsStr);
  } else {
    queryParamsStr && (syncUrl += '?' + queryParamsStr);
  }
  return syncUrl;
}

/**
 * 私有方法
 */
function decodeAcl(AccessControlPolicy) {
  var result = {
    GrantFullControl: [],
    GrantWrite: [],
    GrantRead: [],
    GrantReadAcp: [],
    GrantWriteAcp: [],
    ACL: ''
  };
  var GrantMap = {
    FULL_CONTROL: 'GrantFullControl',
    WRITE: 'GrantWrite',
    READ: 'GrantRead',
    READ_ACP: 'GrantReadAcp',
    WRITE_ACP: 'GrantWriteAcp'
  };
  var AccessControlList = AccessControlPolicy && AccessControlPolicy.AccessControlList || {};
  var Grant = AccessControlList.Grant;
  if (Grant) {
    Grant = util.isArray(Grant) ? Grant : [Grant];
  }
  var PublicAcl = {
    READ: 0,
    WRITE: 0,
    FULL_CONTROL: 0
  };
  Grant && Grant.length && util.each(Grant, function (item) {
    if (item.Grantee.ID === 'qcs::cam::anyone:anyone' || item.Grantee.URI === 'http://cam.qcloud.com/groups/global/AllUsers') {
      PublicAcl[item.Permission] = 1;
    } else if (item.Grantee.ID !== AccessControlPolicy.Owner.ID) {
      result[GrantMap[item.Permission]].push('id="' + item.Grantee.ID + '"');
    }
  });
  if (PublicAcl.FULL_CONTROL || PublicAcl.WRITE && PublicAcl.READ) {
    result.ACL = 'public-read-write';
  } else if (PublicAcl.READ) {
    result.ACL = 'public-read';
  } else {
    result.ACL = 'private';
  }
  util.each(GrantMap, function (item) {
    result[item] = uniqGrant(result[item].join(','));
  });
  return result;
}

// Grant 去重
function uniqGrant(str) {
  var arr = str.split(',');
  var exist = {};
  var i, item;
  for (i = 0; i < arr.length;) {
    item = arr[i].trim();
    if (exist[item]) {
      arr.splice(i, 1);
    } else {
      exist[item] = true;
      arr[i] = item;
      i++;
    }
  }
  return arr.join(',');
}

// 生成操作 url
function getUrl(params) {
  var region = params.region || '';
  var longBucket = params.bucket || '';
  var shortBucket = longBucket.substr(0, longBucket.lastIndexOf('-'));
  var appId = longBucket.substr(longBucket.lastIndexOf('-') + 1);
  var domain = params.domain;
  var object = params.object;
  if (typeof domain === 'function') {
    domain = domain({
      Bucket: longBucket,
      Region: region
    });
  }
  // 兼容不带冒号的http、https
  if (['http', 'https'].includes(params.protocol)) {
    params.protocol = params.protocol + ':';
  }
  var protocol = params.protocol || (util.isBrowser && (typeof location === "undefined" ? "undefined" : _typeof(location)) === 'object' && location.protocol === 'http:' ? 'http:' : 'https:');
  if (!domain) {
    if (['cn-south', 'cn-south-2', 'cn-north', 'cn-east', 'cn-southwest', 'sg'].indexOf(region) > -1) {
      domain = '{Region}.myqcloud.com';
    } else {
      domain = 'cos.{Region}.myqcloud.com';
    }
    if (!params.ForcePathStyle) {
      domain = '{Bucket}.' + domain;
    }
  }
  domain = domain.replace(/\{\{AppId\}\}/gi, appId).replace(/\{\{Bucket\}\}/gi, shortBucket).replace(/\{\{Region\}\}/gi, region).replace(/\{\{.*?\}\}/gi, '');
  domain = domain.replace(/\{AppId\}/gi, appId).replace(/\{BucketName\}/gi, shortBucket).replace(/\{Bucket\}/gi, longBucket).replace(/\{Region\}/gi, region).replace(/\{.*?\}/gi, '');
  if (!/^[a-zA-Z]+:\/\//.test(domain)) {
    domain = protocol + '//' + domain;
  }

  // 去掉域名最后的斜杆
  if (domain.slice(-1) === '/') {
    domain = domain.slice(0, -1);
  }
  var url = domain;
  if (params.ForcePathStyle) {
    url += '/' + longBucket;
  }
  url += '/';
  if (object) {
    url += util.camSafeUrlEncode(object).replace(/%2F/g, '/');
  }
  if (params.isLocation) {
    url = url.replace(/^https?:\/\//, '');
  }
  return url;
}
var getSignHost = function getSignHost(opt) {
  if (!opt.Bucket || !opt.Region) return '';
  var useAccelerate = opt.UseAccelerate === undefined ? this.options.UseAccelerate : opt.UseAccelerate;
  var url = opt.Url || getUrl({
    ForcePathStyle: this.options.ForcePathStyle,
    protocol: this.options.Protocol,
    domain: this.options.Domain,
    bucket: opt.Bucket,
    region: useAccelerate ? 'accelerate' : opt.Region
  });
  var urlHost = url.replace(/^https?:\/\/([^/]+)(\/.*)?$/, '$1');
  return urlHost;
};

// 异步获取签名
function getAuthorizationAsync(params, callback) {
  var headers = util.clone(params.Headers);
  var headerHost = '';
  util.each(headers, function (v, k) {
    (v === '' || ['content-type', 'cache-control', 'expires'].indexOf(k.toLowerCase()) > -1) && delete headers[k];
    if (k.toLowerCase() === 'host') headerHost = v;
  });
  // ForceSignHost明确传入false才不加入host签名
  var forceSignHost = params.ForceSignHost === false ? false : true;

  // Host 加入签名计算
  if (!headerHost && params.SignHost && forceSignHost) headers.Host = params.SignHost;

  // 获取凭证的回调，避免用户 callback 多次
  var cbDone = false;
  var cb = function cb(err, AuthData) {
    if (cbDone) return;
    cbDone = true;
    if (AuthData && AuthData.XCosSecurityToken && !AuthData.SecurityToken) {
      AuthData = util.clone(AuthData);
      AuthData.SecurityToken = AuthData.XCosSecurityToken;
      delete AuthData.XCosSecurityToken;
    }
    callback && callback(err, AuthData);
  };
  var self = this;
  var Bucket = params.Bucket || '';
  var Region = params.Region || '';

  // PathName
  var KeyName = params.Key || '';
  if (self.options.ForcePathStyle && Bucket) {
    KeyName = Bucket + '/' + KeyName;
  }
  var Pathname = '/' + KeyName;

  // Action、ResourceKey
  var StsData = {};
  var Scope = params.Scope;
  if (!Scope) {
    var Action = params.Action || '';
    var ResourceKey = params.ResourceKey || params.Key || '';
    Scope = params.Scope || [{
      action: Action,
      bucket: Bucket,
      region: Region,
      prefix: ResourceKey
    }];
  }
  var ScopeKey = util.md5(JSON.stringify(Scope));

  // STS
  self._StsCache = self._StsCache || [];
  (function () {
    var i, AuthData;
    for (i = self._StsCache.length - 1; i >= 0; i--) {
      AuthData = self._StsCache[i];
      var compareTime = Math.round(util.getSkewTime(self.options.SystemClockOffset) / 1000) + 30;
      if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
        self._StsCache.splice(i, 1);
        continue;
      }
      if (!AuthData.ScopeLimit || AuthData.ScopeLimit && AuthData.ScopeKey === ScopeKey) {
        StsData = AuthData;
        break;
      }
    }
  })();
  var calcAuthByTmpKey = function calcAuthByTmpKey() {
    var KeyTime = '';
    if (StsData.StartTime && params.Expires) KeyTime = StsData.StartTime + ';' + (StsData.StartTime + params.Expires * 1);else if (StsData.StartTime && StsData.ExpiredTime) KeyTime = StsData.StartTime + ';' + StsData.ExpiredTime;
    var Authorization = util.getAuth({
      SecretId: StsData.TmpSecretId,
      SecretKey: StsData.TmpSecretKey,
      Method: params.Method,
      Pathname: Pathname,
      Query: params.Query,
      Headers: headers,
      Expires: params.Expires,
      UseRawKey: self.options.UseRawKey,
      SystemClockOffset: self.options.SystemClockOffset,
      KeyTime: KeyTime,
      ForceSignHost: forceSignHost
    });
    var AuthData = {
      Authorization: Authorization,
      SecurityToken: StsData.SecurityToken || StsData.XCosSecurityToken || '',
      Token: StsData.Token || '',
      ClientIP: StsData.ClientIP || '',
      ClientUA: StsData.ClientUA || '',
      SignFrom: 'client'
    };
    cb(null, AuthData);
  };
  var checkAuthError = function checkAuthError(AuthData) {
    if (AuthData.Authorization) {
      // 检查签名格式
      var formatAllow = false;
      var auth = AuthData.Authorization;
      if (auth) {
        if (auth.indexOf(' ') > -1) {
          formatAllow = false;
        } else if (auth.indexOf('q-sign-algorithm=') > -1 && auth.indexOf('q-ak=') > -1 && auth.indexOf('q-sign-time=') > -1 && auth.indexOf('q-key-time=') > -1 && auth.indexOf('q-url-param-list=') > -1) {
          formatAllow = true;
        } else {
          try {
            auth = atob(auth);
            if (auth.indexOf('a=') > -1 && auth.indexOf('k=') > -1 && auth.indexOf('t=') > -1 && auth.indexOf('r=') > -1 && auth.indexOf('b=') > -1) {
              formatAllow = true;
            }
          } catch (e) {}
        }
      }
      if (!formatAllow) return util.error(new Error('getAuthorization callback params format error'));
    } else {
      if (!AuthData.TmpSecretId) return util.error(new Error('getAuthorization callback params missing "TmpSecretId"'));
      if (!AuthData.TmpSecretKey) return util.error(new Error('getAuthorization callback params missing "TmpSecretKey"'));
      if (!AuthData.SecurityToken && !AuthData.XCosSecurityToken) return util.error(new Error('getAuthorization callback params missing "SecurityToken"'));
      if (!AuthData.ExpiredTime) return util.error(new Error('getAuthorization callback params missing "ExpiredTime"'));
      if (AuthData.ExpiredTime && AuthData.ExpiredTime.toString().length !== 10) return util.error(new Error('getAuthorization callback params "ExpiredTime" should be 10 digits'));
      if (AuthData.StartTime && AuthData.StartTime.toString().length !== 10) return util.error(new Error('getAuthorization callback params "StartTime" should be 10 StartTime'));
    }
    return false;
  };

  // 先判断是否有临时密钥
  if (StsData.ExpiredTime && StsData.ExpiredTime - util.getSkewTime(self.options.SystemClockOffset) / 1000 > 60) {
    // 如果缓存的临时密钥有效，并还有超过60秒有效期就直接使用
    calcAuthByTmpKey();
  } else if (self.options.getAuthorization) {
    // 外部计算签名或获取临时密钥
    self.options.getAuthorization.call(self, {
      Bucket: Bucket,
      Region: Region,
      Method: params.Method,
      Key: KeyName,
      Pathname: Pathname,
      Query: params.Query,
      Headers: headers,
      Scope: Scope,
      SystemClockOffset: self.options.SystemClockOffset,
      ForceSignHost: forceSignHost
    }, function (AuthData) {
      if (typeof AuthData === 'string') AuthData = {
        Authorization: AuthData
      };
      var AuthError = checkAuthError(AuthData);
      if (AuthError) return cb(AuthError);
      if (AuthData.Authorization) {
        cb(null, AuthData);
      } else {
        StsData = AuthData || {};
        StsData.Scope = Scope;
        StsData.ScopeKey = ScopeKey;
        self._StsCache.push(StsData);
        calcAuthByTmpKey();
      }
    });
  } else if (self.options.getSTS) {
    // 外部获取临时密钥
    self.options.getSTS.call(self, {
      Bucket: Bucket,
      Region: Region
    }, function (data) {
      StsData = data || {};
      StsData.Scope = Scope;
      StsData.ScopeKey = ScopeKey;
      if (!StsData.TmpSecretId) StsData.TmpSecretId = StsData.SecretId;
      if (!StsData.TmpSecretKey) StsData.TmpSecretKey = StsData.SecretKey;
      var AuthError = checkAuthError(StsData);
      if (AuthError) return cb(AuthError);
      self._StsCache.push(StsData);
      calcAuthByTmpKey();
    });
  } else {
    // 内部计算获取签名
    return function () {
      var Authorization = util.getAuth({
        SecretId: params.SecretId || self.options.SecretId,
        SecretKey: params.SecretKey || self.options.SecretKey,
        Method: params.Method,
        Pathname: Pathname,
        Query: params.Query,
        Headers: headers,
        Expires: params.Expires,
        UseRawKey: self.options.UseRawKey,
        SystemClockOffset: self.options.SystemClockOffset,
        ForceSignHost: forceSignHost
      });
      var AuthData = {
        Authorization: Authorization,
        SecurityToken: self.options.SecurityToken || self.options.XCosSecurityToken,
        SignFrom: 'client'
      };
      cb(null, AuthData);
      return AuthData;
    }();
  }
  return '';
}

// 判断当前请求出错时能否重试
function allowRetry(err) {
  var self = this;
  var canRetry = false;
  var isTimeError = false;
  var networkError = false;
  var serverDate = err.headers && (err.headers.date || err.headers.Date) || err.error && err.error.ServerTime;
  try {
    var errorCode = err.error.Code;
    var errorMessage = err.error.Message;
    if (errorCode === 'RequestTimeTooSkewed' || errorCode === 'AccessDenied' && errorMessage === 'Request has expired') {
      isTimeError = true;
    }
  } catch (e) {}
  if (err) {
    // 调整时间偏差
    if (isTimeError && serverDate) {
      var serverTime = Date.parse(serverDate);
      if (this.options.CorrectClockSkew && Math.abs(util.getSkewTime(this.options.SystemClockOffset) - serverTime) >= 30000) {
        console.error('error: Local time is too skewed.');
        this.options.SystemClockOffset = serverTime - Date.now();
        canRetry = true;
      }
    } else if (Math.floor(err.statusCode / 100) === 5) {
      canRetry = true;
    } else if (err.message === 'CORS blocked or network error') {
      // 跨域/网络错误都包含在内
      networkError = true;
      canRetry = self.options.AutoSwitchHost;
    }
  }
  return {
    canRetry: canRetry,
    networkError: networkError
  };
}

/**
 * requestUrl：请求的url，用于判断是否cos主域名，true才切
 * clientCalcSign：是否客户端计算签名，服务端返回的签名不能切，true才切
 * networkError：是否未知网络错误，true才切
 * */
function canSwitchHost(_ref) {
  var requestUrl = _ref.requestUrl,
    clientCalcSign = _ref.clientCalcSign,
    networkError = _ref.networkError;
  if (!this.options.AutoSwitchHost) return false;
  if (!requestUrl) return false;
  if (!clientCalcSign) return false;
  if (!networkError) return false;
  var commonReg = /^https?:\/\/[^\/]*\.cos\.[^\/]*\.myqcloud\.com(\/.*)?$/;
  var accelerateReg = /^https?:\/\/[^\/]*\.cos\.accelerate\.myqcloud\.com(\/.*)?$/;
  // 当前域名是cos主域名才切换
  var isCommonCosHost = commonReg.test(requestUrl) && !accelerateReg.test(requestUrl);
  return isCommonCosHost;
}

// 获取签名并发起请求
function submitRequest(params, callback) {
  var self = this;

  // 处理 headers
  !params.headers && (params.headers = {});

  // 处理 query
  !params.qs && (params.qs = {});
  params.VersionId && (params.qs.versionId = params.VersionId);
  params.qs = util.clearKey(params.qs);

  // 清理 undefined 和 null 字段
  params.headers && (params.headers = util.clearKey(params.headers));
  params.qs && (params.qs = util.clearKey(params.qs));
  var Query = util.clone(params.qs);
  params.action && (Query[params.action] = '');

  /**
   * 手动传params.SignHost的场景：cos.getService、cos.getObjectUrl
   * 手动传Url的场景：cos.request
   */
  var paramsUrl = params.url || params.Url;
  var SignHost = params.SignHost || getSignHost.call(this, {
    Bucket: params.Bucket,
    Region: params.Region,
    Url: paramsUrl
  });
  var tracker = params.tracker;
  var next = function next(tryTimes) {
    var oldClockOffset = self.options.SystemClockOffset;
    tracker && tracker.setParams({
      signStartTime: new Date().getTime(),
      httpRetryTimes: tryTimes - 1
    });
    if (params.SwitchHost) {
      // 更换要签的host
      SignHost = SignHost.replace(/myqcloud.com/, 'tencentcos.cn');
    }
    getAuthorizationAsync.call(self, {
      Bucket: params.Bucket || '',
      Region: params.Region || '',
      Method: params.method,
      Key: params.Key,
      Query: Query,
      Headers: params.headers,
      SignHost: SignHost,
      Action: params.Action,
      ResourceKey: params.ResourceKey,
      Scope: params.Scope,
      ForceSignHost: self.options.ForceSignHost,
      SwitchHost: params.SwitchHost
    }, function (err, AuthData) {
      if (err) {
        callback(err);
        return;
      }
      tracker && tracker.setParams({
        signEndTime: new Date().getTime(),
        httpStartTime: new Date().getTime()
      });
      params.AuthData = AuthData;
      _submitRequest.call(self, params, function (err, data) {
        tracker && tracker.setParams({
          httpEndTime: new Date().getTime()
        });
        var canRetry = false;
        var networkError = false;
        if (err) {
          var info = allowRetry.call(self, err);
          canRetry = info.canRetry || oldClockOffset !== self.options.SystemClockOffset;
          networkError = info.networkError;
        }
        if (err && tryTimes < 2 && canRetry) {
          if (params.headers) {
            delete params.headers.Authorization;
            delete params.headers['token'];
            delete params.headers['clientIP'];
            delete params.headers['clientUA'];
            params.headers['x-cos-security-token'] && delete params.headers['x-cos-security-token'];
            params.headers['x-ci-security-token'] && delete params.headers['x-ci-security-token'];
          }
          // 进入重试逻辑时 需判断是否需要切换cos备用域名
          var switchHost = canSwitchHost.call(self, {
            requestUrl: (err === null || err === void 0 ? void 0 : err.url) || '',
            clientCalcSign: AuthData.SignFrom === 'client',
            networkError: networkError
          });
          params.SwitchHost = switchHost;
          next(tryTimes + 1);
        } else {
          callback(err, data);
        }
      });
    });
  };
  next(1);
}

// 发起请求
function _submitRequest(params, callback) {
  var self = this;
  var TaskId = params.TaskId;
  if (TaskId && !self._isRunningTask(TaskId)) return;
  var bucket = params.Bucket;
  var region = params.Region;
  var object = params.Key;
  var method = params.method || 'GET';
  var url = params.Url || params.url;
  var body = params.body;
  var rawBody = params.rawBody;

  // url
  if (self.options.UseAccelerate) {
    region = 'accelerate';
  }
  url = url || getUrl({
    ForcePathStyle: self.options.ForcePathStyle,
    protocol: self.options.Protocol,
    domain: self.options.Domain,
    bucket: bucket,
    region: region,
    object: object
  });
  if (params.SwitchHost) {
    // 更换请求的url
    url = url.replace(/myqcloud.com/, 'tencentcos.cn');
  }
  var repoterUrl = object ? url : '';
  if (params.action) {
    // 已知问题，某些版本的qq会对url自动拼接（比如/upload被拼接成/upload=(null)）导致签名错误，这里做下兼容。
    url = url + '?' + (util.isIOS_QQ ? "".concat(params.action, "=") : params.action);
  }
  if (params.qsStr) {
    if (url.indexOf('?') > -1) {
      url = url + '&' + params.qsStr;
    } else {
      url = url + '?' + params.qsStr;
    }
  }
  var opt = {
    method: method,
    url: url,
    headers: params.headers,
    qs: params.qs,
    body: body
  };

  // 兼容ci接口
  var token = 'x-cos-security-token';
  if (util.isCIHost(url)) {
    token = 'x-ci-security-token';
  }

  // 获取签名
  opt.headers.Authorization = params.AuthData.Authorization;
  params.AuthData.Token && (opt.headers['token'] = params.AuthData.Token);
  params.AuthData.ClientIP && (opt.headers['clientIP'] = params.AuthData.ClientIP);
  params.AuthData.ClientUA && (opt.headers['clientUA'] = params.AuthData.ClientUA);
  params.AuthData.SecurityToken && (opt.headers[token] = params.AuthData.SecurityToken);

  // 清理 undefined 和 null 字段
  opt.headers && (opt.headers = util.clearKey(opt.headers));
  opt = util.clearKey(opt);

  // progress
  if (params.onProgress && typeof params.onProgress === 'function') {
    var contentLength = body && (body.size || body.length) || 0;
    opt.onProgress = function (e) {
      if (TaskId && !self._isRunningTask(TaskId)) return;
      var loaded = e ? e.loaded : 0;
      params.onProgress({
        loaded: loaded,
        total: contentLength
      });
    };
  }
  if (params.onDownloadProgress) {
    opt.onDownloadProgress = params.onDownloadProgress;
  }
  if (params.DataType) {
    opt.dataType = params.DataType;
  }
  if (this.options.Timeout) {
    opt.timeout = this.options.Timeout;
  }
  self.options.ForcePathStyle && (opt.pathStyle = self.options.ForcePathStyle);
  self.emit('before-send', opt);
  var useAccelerate = opt.url.includes('accelerate.');
  var queryString = opt.qs ? Object.keys(opt.qs).map(function (key) {
    return "".concat(key, "=").concat(opt.qs[key]);
  }).join('&') : '';
  var fullUrl = queryString ? opt.url + '?' + queryString : opt.url;
  if (params.tracker) {
    var _opt$body;
    params.tracker.setParams({
      url: fullUrl,
      httpMethod: opt.method,
      accelerate: useAccelerate,
      httpSize: ((_opt$body = opt.body) === null || _opt$body === void 0 ? void 0 : _opt$body.size) || 0
    });
    // 分块上传时给父级tracker设置url信息
    if (params.tracker.parent && !params.tracker.parent.params.url) {
      params.tracker.parent.setParams({
        url: repoterUrl,
        accelerate: useAccelerate
      });
    }
  }
  var sender = (self.options.Request || REQUEST)(opt, function (r) {
    if (r && r.error === 'abort') return;
    var receive = {
      options: opt,
      error: r && r.error,
      statusCode: r && r.statusCode || 0,
      statusMessage: r && r.statusMessage || '',
      headers: r && r.headers || {},
      body: r && r.body
    };
    // 抛出事件，允许修改返回值的 error、statusCode、statusMessage、body
    self.emit('after-receive', receive);
    var err = receive.error;
    var body = receive.body;
    // 返回内容添加 状态码 和 headers
    var response = {
      statusCode: receive.statusCode,
      statusMessage: receive.statusMessage,
      headers: receive.headers
    };
    var hasReturned;
    var cb = function cb(err, data) {
      TaskId && self.off('inner-kill-task', killTask);
      if (hasReturned) return;
      hasReturned = true;
      var attrs = {};
      response && response.statusCode && (attrs.statusCode = response.statusCode);
      response && response.headers && (attrs.headers = response.headers);
      if (err) {
        opt.url && (attrs.url = opt.url);
        opt.method && (attrs.method = opt.method);
        err = util.extend(err || {}, attrs);
        callback(err, null);
      } else {
        data = util.extend(data || {}, attrs);
        callback(null, data);
      }
      sender = null;
    };

    // 请求错误，发生网络错误
    if (err) return cb(util.error(err));

    // 请求返回码不为 200
    var statusCode = response.statusCode;
    var statusSuccess = Math.floor(statusCode / 100) === 2; // 200 202 204 206

    // 不对 body 进行转换，body 直接挂载返回
    if (rawBody && statusSuccess) return cb(null, {
      body: body
    });

    // 解析 xml body
    var json;
    try {
      json = body && body.indexOf('<') > -1 && body.indexOf('>') > -1 && util.xml2json(body) || {};
    } catch (e) {
      json = {};
    }

    // 处理返回值
    var xmlError = json && json.Error;
    if (statusSuccess) {
      // 正确返回，状态码 2xx 时，body 不会有 Error
      cb(null, json);
    } else if (xmlError) {
      // 正常返回了 xml body，且有 Error 节点
      cb(util.error(new Error(xmlError.Message), {
        code: xmlError.Code,
        error: xmlError
      }));
    } else if (statusCode) {
      // 有错误的状态码
      cb(util.error(new Error(response.statusMessage), {
        code: '' + statusCode
      }));
    } else if (statusCode) {
      // 无状态码，或者获取不到状态码
      cb(util.error(new Error('statusCode error')));
    }
  });

  // kill task
  var killTask = function killTask(data) {
    if (data.TaskId === TaskId) {
      sender && sender.abort && sender.abort();
      self.off('inner-kill-task', killTask);
    }
  };
  TaskId && self.on('inner-kill-task', killTask);
}
var API_MAP = {
  // Bucket 相关方法
  getService: getService,
  // Bucket
  putBucket: putBucket,
  headBucket: headBucket,
  // Bucket
  getBucket: getBucket,
  deleteBucket: deleteBucket,
  putBucketAcl: putBucketAcl,
  // BucketACL
  getBucketAcl: getBucketAcl,
  putBucketCors: putBucketCors,
  // BucketCors
  getBucketCors: getBucketCors,
  deleteBucketCors: deleteBucketCors,
  getBucketLocation: getBucketLocation,
  // BucketLocation
  getBucketPolicy: getBucketPolicy,
  // BucketPolicy
  putBucketPolicy: putBucketPolicy,
  deleteBucketPolicy: deleteBucketPolicy,
  putBucketTagging: putBucketTagging,
  // BucketTagging
  getBucketTagging: getBucketTagging,
  deleteBucketTagging: deleteBucketTagging,
  putBucketLifecycle: putBucketLifecycle,
  // BucketLifecycle
  getBucketLifecycle: getBucketLifecycle,
  deleteBucketLifecycle: deleteBucketLifecycle,
  putBucketVersioning: putBucketVersioning,
  // BucketVersioning
  getBucketVersioning: getBucketVersioning,
  putBucketReplication: putBucketReplication,
  // BucketReplication
  getBucketReplication: getBucketReplication,
  deleteBucketReplication: deleteBucketReplication,
  putBucketWebsite: putBucketWebsite,
  // BucketWebsite
  getBucketWebsite: getBucketWebsite,
  deleteBucketWebsite: deleteBucketWebsite,
  putBucketReferer: putBucketReferer,
  // BucketReferer
  getBucketReferer: getBucketReferer,
  putBucketDomain: putBucketDomain,
  // BucketDomain
  getBucketDomain: getBucketDomain,
  deleteBucketDomain: deleteBucketDomain,
  putBucketOrigin: putBucketOrigin,
  // BucketOrigin
  getBucketOrigin: getBucketOrigin,
  deleteBucketOrigin: deleteBucketOrigin,
  putBucketLogging: putBucketLogging,
  // BucketLogging
  getBucketLogging: getBucketLogging,
  putBucketInventory: putBucketInventory,
  // BucketInventory
  postBucketInventory: postBucketInventory,
  getBucketInventory: getBucketInventory,
  listBucketInventory: listBucketInventory,
  deleteBucketInventory: deleteBucketInventory,
  putBucketAccelerate: putBucketAccelerate,
  getBucketAccelerate: getBucketAccelerate,
  putBucketEncryption: putBucketEncryption,
  getBucketEncryption: getBucketEncryption,
  deleteBucketEncryption: deleteBucketEncryption,
  // Object 相关方法
  getObject: getObject,
  headObject: headObject,
  listObjectVersions: listObjectVersions,
  putObject: putObject,
  deleteObject: deleteObject,
  getObjectAcl: getObjectAcl,
  putObjectAcl: putObjectAcl,
  optionsObject: optionsObject,
  putObjectCopy: putObjectCopy,
  deleteMultipleObject: deleteMultipleObject,
  restoreObject: restoreObject,
  putObjectTagging: putObjectTagging,
  getObjectTagging: getObjectTagging,
  deleteObjectTagging: deleteObjectTagging,
  selectObjectContent: selectObjectContent,
  appendObject: appendObject,
  // 分块上传相关方法
  uploadPartCopy: uploadPartCopy,
  multipartInit: multipartInit,
  multipartUpload: multipartUpload,
  multipartComplete: multipartComplete,
  multipartList: multipartList,
  multipartListPart: multipartListPart,
  multipartAbort: multipartAbort,
  // 工具方法
  request: request,
  getObjectUrl: getObjectUrl,
  getAuth: getAuth
};
function warnOldApi(apiName, fn, proto) {
  util.each(['Cors', 'Acl'], function (suffix) {
    if (apiName.slice(-suffix.length) === suffix) {
      var oldName = apiName.slice(0, -suffix.length) + suffix.toUpperCase();
      var apiFn = util.apiWrapper(apiName, fn);
      var warned = false;
      proto[oldName] = function () {
        !warned && console.warn('warning: cos.' + oldName + ' has been deprecated. Please Use cos.' + apiName + ' instead.');
        warned = true;
        apiFn.apply(this, arguments);
      };
    }
  });
}
module.exports.init = function (COS, task) {
  task.transferToTaskMethod(API_MAP, 'putObject');
  util.each(API_MAP, function (fn, apiName) {
    COS.prototype[apiName] = util.apiWrapper(apiName, fn);
    warnOldApi(apiName, fn, COS.prototype);
  });
};

/***/ }),

/***/ "./src/cos.js":
/*!********************!*\
  !*** ./src/cos.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./src/util.js");
var event = __webpack_require__(/*! ./event */ "./src/event.js");
var task = __webpack_require__(/*! ./task */ "./src/task.js");
var base = __webpack_require__(/*! ./base */ "./src/base.js");
var advance = __webpack_require__(/*! ./advance */ "./src/advance.js");
var pkg = __webpack_require__(/*! ../package.json */ "./package.json");
var ClsClient = __webpack_require__(/*! tencentcloud-cls-uploader-sdk */ "./node_modules/tencentcloud-cls-uploader-sdk/dist/cls.browser.js");
var clsClient = new ClsClient({
  topicId: 'cf92b62c-6bdb-48a4-889c-2e99dbaeeef9',
  region: 'ap-guangzhou',
  maxRetainDuration: 5,
  // 默认 30s
  maxRetainSize: 20,
  // 默认20条
  onError: function onError(err) {
    console.log('onError:', err);
  }
});
var defaultOptions = {
  AppId: '',
  // AppId 已废弃，请拼接到 Bucket 后传入，例如：test-1250000000
  SecretId: '',
  SecretKey: '',
  SecurityToken: '',
  // 使用临时密钥需要注意自行刷新 Token
  ChunkRetryTimes: 2,
  FileParallelLimit: 3,
  ChunkParallelLimit: 3,
  ChunkSize: 1024 * 1024,
  SliceSize: 1024 * 1024,
  CopyChunkParallelLimit: 20,
  CopyChunkSize: 1024 * 1024 * 10,
  CopySliceSize: 1024 * 1024 * 10,
  MaxPartNumber: 10000,
  ProgressInterval: 1000,
  Domain: '',
  ServiceDomain: '',
  Protocol: '',
  CompatibilityMode: false,
  ForcePathStyle: false,
  UseRawKey: false,
  Timeout: 0,
  // 单位毫秒，0 代表不设置超时时间
  CorrectClockSkew: true,
  SystemClockOffset: 0,
  // 单位毫秒，ms
  UploadCheckContentMd5: false,
  UploadQueueSize: 10000,
  UploadAddMetaMd5: false,
  UploadIdCacheLimit: 50,
  UseAccelerate: false,
  ForceSignHost: true,
  // 默认将host加入签名计算，关闭后可能导致越权风险，建议保持为true
  AutoSwitchHost: true,
  CopySourceParser: null,
  // 自定义拷贝源解析器
  /** 上报相关 **/
  DeepTracker: false,
  // 上报时是否对每个分块上传做单独上报
  TrackerDelay: 5000,
  // 周期性上报，单位毫秒。0代表实时上报
  CustomId: '',
  // 自定义上报id
  Beacon: null,
  // 灯塔上报组件，如有需要请自行传入，传入即代表开启上报
  ClsReporter: clsClient // cls 上报组件，如有需要请自行传入，传入即代表开启上报
};

// 对外暴露的类
var COS = function COS(options) {
  this.options = util.extend(util.clone(defaultOptions), options || {});
  this.options.FileParallelLimit = Math.max(1, this.options.FileParallelLimit);
  this.options.ChunkParallelLimit = Math.max(1, this.options.ChunkParallelLimit);
  this.options.ChunkRetryTimes = Math.max(0, this.options.ChunkRetryTimes);
  this.options.ChunkSize = Math.max(1024 * 1024, this.options.ChunkSize);
  this.options.CopyChunkParallelLimit = Math.max(1, this.options.CopyChunkParallelLimit);
  this.options.CopyChunkSize = Math.max(1024 * 1024, this.options.CopyChunkSize);
  this.options.CopySliceSize = Math.max(0, this.options.CopySliceSize);
  this.options.MaxPartNumber = Math.max(1024, Math.min(10000, this.options.MaxPartNumber));
  this.options.Timeout = Math.max(0, this.options.Timeout);
  this.options.EnableReporter = this.options.Beacon || this.options.ClsReporter;
  if (this.options.AppId) {
    console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").');
  }
  if (this.options.SecretId && this.options.SecretId.indexOf(' ') > -1) {
    console.error('error: SecretId格式错误，请检查');
    console.error('error: SecretId format is incorrect. Please check');
  }
  if (this.options.SecretKey && this.options.SecretKey.indexOf(' ') > -1) {
    console.error('error: SecretKey格式错误，请检查');
    console.error('error: SecretKey format is incorrect. Please check');
  }
  if (util.isNode()) {
    console.log('Tip: Next.js、Nuxt.js 等服务端渲染技术可正常使用JavaScript SDK，请忽略下方 nodejs 环境警告');
    console.warn('warning: cos-js-sdk-v5 不支持 nodejs 环境使用，请改用 cos-nodejs-sdk-v5，参考文档： https://cloud.tencent.com/document/product/436/8629');
    console.warn('warning: cos-js-sdk-v5 does not support nodejs environment. Please use cos-nodejs-sdk-v5 instead. See: https://cloud.tencent.com/document/product/436/8629');
  }
  if (this.options.ForcePathStyle) {
    console.warn('cos-js-sdk-v5不再支持使用path-style，仅支持使用virtual-hosted-style，参考文档：https://cloud.tencent.com/document/product/436/96243');
    throw new Error('ForcePathStyle is not supported');
  }
  event.init(this);
  task.init(this);
};
base.init(COS, task);
advance.init(COS, task);
COS.util = {
  md5: util.md5,
  xml2json: util.xml2json,
  json2xml: util.json2xml,
  encodeBase64: util.encodeBase64
};
COS.getAuthorization = util.getAuth;
COS.version = pkg.version;
module.exports = COS;

/***/ }),

/***/ "./src/event.js":
/*!**********************!*\
  !*** ./src/event.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

var initEvent = function initEvent(cos) {
  var listeners = {};
  var getList = function getList(action) {
    !listeners[action] && (listeners[action] = []);
    return listeners[action];
  };
  cos.on = function (action, callback) {
    if (action === 'task-list-update') {
      console.warn('warning: Event "' + action + '" has been deprecated. Please use "list-update" instead.');
    }
    getList(action).push(callback);
  };
  cos.off = function (action, callback) {
    var list = getList(action);
    for (var i = list.length - 1; i >= 0; i--) {
      callback === list[i] && list.splice(i, 1);
    }
  };
  cos.emit = function (action, data) {
    var list = getList(action).map(function (cb) {
      return cb;
    });
    for (var i = 0; i < list.length; i++) {
      list[i](data);
    }
  };
};
var EventProxy = function EventProxy() {
  initEvent(this);
};
module.exports.init = initEvent;
module.exports.EventProxy = EventProxy;

/***/ }),

/***/ "./src/session.js":
/*!************************!*\
  !*** ./src/session.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! ./util */ "./src/util.js");

// 按照文件特征值，缓存 UploadId
var cacheKey = 'cos_sdk_upload_cache';
var expires = 30 * 24 * 3600;
var cache;
var timer;
var getCache = function getCache() {
  try {
    var val = JSON.parse(localStorage.getItem(cacheKey));
  } catch (e) {}
  if (!val) val = [];
  cache = val;
};
var setCache = function setCache() {
  try {
    if (cache.length) localStorage.setItem(cacheKey, JSON.stringify(cache));else localStorage.removeItem(cacheKey);
  } catch (e) {}
};
var init = function init() {
  if (cache) return;
  getCache.call(this);
  // 清理太老旧的数据
  var changed = false;
  var now = Math.round(Date.now() / 1000);
  for (var i = cache.length - 1; i >= 0; i--) {
    var mtime = cache[i][2];
    if (!mtime || mtime + expires < now) {
      cache.splice(i, 1);
      changed = true;
    }
  }
  changed && setCache();
};

// 把缓存存到本地
var save = function save() {
  if (timer) return;
  timer = setTimeout(function () {
    setCache();
    timer = null;
  }, 400);
};
var mod = {
  using: {},
  // 标记 UploadId 正在使用
  setUsing: function setUsing(uuid) {
    mod.using[uuid] = true;
  },
  // 标记 UploadId 已经没在使用
  removeUsing: function removeUsing(uuid) {
    delete mod.using[uuid];
  },
  // 用上传参数生成哈希值
  getFileId: function getFileId(file, ChunkSize, Bucket, Key) {
    if (file.name && file.size && file.lastModifiedDate && ChunkSize) {
      return util.md5([file.name, file.size, file.lastModifiedDate, ChunkSize, Bucket, Key].join('::'));
    } else {
      return null;
    }
  },
  // 用上传参数生成哈希值
  getCopyFileId: function getCopyFileId(copySource, sourceHeaders, ChunkSize, Bucket, Key) {
    var size = sourceHeaders['content-length'];
    var etag = sourceHeaders.etag || '';
    var lastModified = sourceHeaders['last-modified'];
    if (copySource && ChunkSize) {
      return util.md5([copySource, size, etag, lastModified, ChunkSize, Bucket, Key].join('::'));
    } else {
      return null;
    }
  },
  // 获取文件对应的 UploadId 列表
  getUploadIdList: function getUploadIdList(uuid) {
    if (!uuid) return null;
    init.call(this);
    var list = [];
    for (var i = 0; i < cache.length; i++) {
      if (cache[i][0] === uuid) list.push(cache[i][1]);
    }
    return list.length ? list : null;
  },
  // 缓存 UploadId
  saveUploadId: function saveUploadId(uuid, UploadId, limit) {
    init.call(this);
    if (!uuid) return;
    // 清理没用的 UploadId，js 文件没有 FilePath ，只清理相同记录
    for (var i = cache.length - 1; i >= 0; i--) {
      var item = cache[i];
      if (item[0] === uuid && item[1] === UploadId) {
        cache.splice(i, 1);
      }
    }
    cache.unshift([uuid, UploadId, Math.round(Date.now() / 1000)]);
    if (cache.length > limit) cache.splice(limit);
    save();
  },
  // UploadId 已用完，移除掉
  removeUploadId: function removeUploadId(UploadId) {
    init.call(this);
    delete mod.using[UploadId];
    for (var i = cache.length - 1; i >= 0; i--) {
      if (cache[i][1] === UploadId) cache.splice(i, 1);
    }
    save();
  }
};
module.exports = mod;

/***/ }),

/***/ "./src/task.js":
/*!*********************!*\
  !*** ./src/task.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var session = __webpack_require__(/*! ./session */ "./src/session.js");
var util = __webpack_require__(/*! ./util */ "./src/util.js");
var originApiMap = {};
var transferToTaskMethod = function transferToTaskMethod(apiMap, apiName) {
  originApiMap[apiName] = apiMap[apiName];
  apiMap[apiName] = function (params, callback) {
    if (params.SkipTask) {
      originApiMap[apiName].call(this, params, callback);
    } else {
      this._addTask(apiName, params, callback);
    }
  };
};
var initTask = function initTask(cos) {
  var queue = [];
  var tasks = {};
  var uploadingFileCount = 0;
  var nextUploadIndex = 0;

  // 接口返回简略的任务信息
  var formatTask = function formatTask(task) {
    var t = {
      id: task.id,
      Bucket: task.Bucket,
      Region: task.Region,
      Key: task.Key,
      FilePath: task.FilePath,
      state: task.state,
      loaded: task.loaded,
      size: task.size,
      speed: task.speed,
      percent: task.percent,
      hashPercent: task.hashPercent,
      error: task.error
    };
    if (task.FilePath) t.FilePath = task.FilePath;
    if (task._custom) t._custom = task._custom; // 控制台使用
    return t;
  };
  var emitListUpdate = function () {
    var timer;
    var emit = function emit() {
      timer = 0;
      cos.emit('task-list-update', {
        list: util.map(queue, formatTask)
      });
      cos.emit('list-update', {
        list: util.map(queue, formatTask)
      });
    };
    return function () {
      if (!timer) timer = setTimeout(emit);
    };
  }();
  var clearQueue = function clearQueue() {
    if (queue.length <= cos.options.UploadQueueSize) return;
    for

      // 如果还太多，才继续清理
    (var i = 0; i < nextUploadIndex &&
    // 小于当前操作的 index 才清理
    i < queue.length &&
    // 大于队列才清理
    queue.length > cos.options.UploadQueueSize;) {
      var isActive = queue[i].state === 'waiting' || queue[i].state === 'checking' || queue[i].state === 'uploading';
      if (!queue[i] || !isActive) {
        tasks[queue[i].id] && delete tasks[queue[i].id];
        queue.splice(i, 1);
        nextUploadIndex--;
      } else {
        i++;
      }
    }
    emitListUpdate();
  };
  var startNextTask = function startNextTask() {
    // 检查是否允许增加执行进程
    if (uploadingFileCount >= cos.options.FileParallelLimit) return;
    // 跳过不可执行的任务
    while (queue[nextUploadIndex] && queue[nextUploadIndex].state !== 'waiting') nextUploadIndex++;
    // 检查是否已遍历结束
    if (nextUploadIndex >= queue.length) return;
    // 上传该遍历到的任务
    var task = queue[nextUploadIndex];
    nextUploadIndex++;
    uploadingFileCount++;
    task.state = 'checking';
    task.params.onTaskStart && task.params.onTaskStart(formatTask(task));
    !task.params.UploadData && (task.params.UploadData = {});
    var apiParams = util.formatParams(task.api, task.params);
    originApiMap[task.api].call(cos, apiParams, function (err, data) {
      if (!cos._isRunningTask(task.id)) return;
      if (task.state === 'checking' || task.state === 'uploading') {
        task.state = err ? 'error' : 'success';
        err && (task.error = err);
        uploadingFileCount--;
        emitListUpdate();
        startNextTask();
        task.callback && task.callback(err, data);
        if (task.state === 'success') {
          if (task.params) {
            delete task.params.UploadData;
            delete task.params.Body;
            delete task.params;
          }
          delete task.callback;
        }
      }
      clearQueue();
    });
    emitListUpdate();
    // 异步执行下一个任务
    setTimeout(startNextTask);
  };
  var killTask = function killTask(id, switchToState) {
    var task = tasks[id];
    if (!task) return;
    var waiting = task && task.state === 'waiting';
    var running = task && (task.state === 'checking' || task.state === 'uploading');
    if (switchToState === 'canceled' && task.state !== 'canceled' || switchToState === 'paused' && waiting || switchToState === 'paused' && running) {
      if (switchToState === 'paused' && task.params.Body && typeof task.params.Body.pipe === 'function') {
        console.error('stream not support pause');
        return;
      }
      task.state = switchToState;
      cos.emit('inner-kill-task', {
        TaskId: id,
        toState: switchToState
      });
      try {
        var UploadId = task && task.params && task.params.UploadData.UploadId;
      } catch (e) {}
      if (switchToState === 'canceled' && UploadId) session.removeUsing(UploadId);
      emitListUpdate();
      if (running) {
        uploadingFileCount--;
        startNextTask();
      }
      if (switchToState === 'canceled') {
        if (task.params) {
          delete task.params.UploadData;
          delete task.params.Body;
          delete task.params;
        }
        delete task.callback;
      }
    }
    clearQueue();
  };
  cos._addTasks = function (taskList) {
    util.each(taskList, function (task) {
      cos._addTask(task.api, task.params, task.callback, true);
    });
    emitListUpdate();
  };
  var isTaskReadyWarning = true;
  cos._addTask = function (api, params, callback, ignoreAddEvent) {
    // 复制参数对象
    params = util.formatParams(api, params);

    // 生成 id
    var id = util.uuid();
    params.TaskId = id;
    params.onTaskReady && params.onTaskReady(id);
    if (params.TaskReady) {
      params.TaskReady(id);
      isTaskReadyWarning && console.warn('warning: Param "TaskReady" has been deprecated. Please use "onTaskReady" instead.');
      isTaskReadyWarning = false;
    }
    var task = {
      // env
      params: params,
      callback: callback,
      api: api,
      index: queue.length,
      // task
      id: id,
      Bucket: params.Bucket,
      Region: params.Region,
      Key: params.Key,
      FilePath: params.FilePath || '',
      state: 'waiting',
      loaded: 0,
      size: 0,
      speed: 0,
      percent: 0,
      hashPercent: 0,
      error: null,
      _custom: params._custom
    };
    var onHashProgress = params.onHashProgress;
    params.onHashProgress = function (info) {
      if (!cos._isRunningTask(task.id)) return;
      task.hashPercent = info.percent;
      onHashProgress && onHashProgress(info);
      emitListUpdate();
    };
    var onProgress = params.onProgress;
    params.onProgress = function (info) {
      if (!cos._isRunningTask(task.id)) return;
      task.state === 'checking' && (task.state = 'uploading');
      task.loaded = info.loaded;
      task.speed = info.speed;
      task.percent = info.percent;
      onProgress && onProgress(info);
      emitListUpdate();
    };

    // 异步获取 filesize
    util.getFileSize(api, params, function (err, size) {
      // 开始处理上传
      if (err) return callback(util.error(err)); // 如果获取大小出错，不加入队列
      // 获取完文件大小再把任务加入队列
      tasks[id] = task;
      queue.push(task);
      task.size = size;
      !ignoreAddEvent && emitListUpdate();
      startNextTask();
      clearQueue();
    });
    return id;
  };
  cos._isRunningTask = function (id) {
    var task = tasks[id];
    return !!(task && (task.state === 'checking' || task.state === 'uploading'));
  };
  cos.getTaskList = function () {
    return util.map(queue, formatTask);
  };
  cos.cancelTask = function (id) {
    killTask(id, 'canceled');
  };
  cos.pauseTask = function (id) {
    killTask(id, 'paused');
  };
  cos.restartTask = function (id) {
    var task = tasks[id];
    if (task && (task.state === 'paused' || task.state === 'error')) {
      task.state = 'waiting';
      emitListUpdate();
      nextUploadIndex = Math.min(nextUploadIndex, task.index);
      startNextTask();
    }
  };
  cos.isUploadRunning = function () {
    return uploadingFileCount || nextUploadIndex < queue.length;
  };
};
module.exports.transferToTaskMethod = transferToTaskMethod;
module.exports.init = initTask;

/***/ }),

/***/ "./src/tracker.js":
/*!************************!*\
  !*** ./src/tracker.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
var pkg = __webpack_require__(/*! ../package.json */ "./package.json");
var beacon = null;
var getBeacon = function getBeacon(Beacon, delay) {
  if (!beacon) {
    // 生成 beacon
    if (typeof Beacon !== 'function') {
      throw new Error('Beacon not found');
    }
    beacon = new Beacon({
      appkey: '0WEB05PY6MHRGK0U',
      versionCode: pkg.version,
      channelID: 'js_sdk',
      //渠道,选填
      openid: 'openid',
      // 用户id, 选填
      unionid: 'unid',
      //用户unionid , 类似idfv,选填
      strictMode: false,
      //严苛模式开关, 打开严苛模式会主动抛出异常, 上线请务必关闭!!!
      delay: delay,
      // 普通事件延迟上报时间(单位毫秒), 默认1000(1秒),选填
      sessionDuration: 60 * 1000 // session变更的时间间隔, 一个用户持续30分钟(默认值)没有任何上报则算另一次 session,每变更一次session上报一次启动事件(rqd_applaunched),使用毫秒(ms),最小值30秒,选填
    });
  }

  return beacon;
};

// 毫秒转秒
var ms2s = function ms2s(ms) {
  if (!ms || ms < 0) return 0;
  return (ms / 1000).toFixed(3);
};
var utils = {
  // 生成uid 每个链路对应唯一一条uid
  getUid: function getUid() {
    var S4 = function S4() {
      return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    };
    return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
  },
  // 获取网络类型 4g ｜ wifi
  getNetType: function getNetType() {
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object') {
      var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      return (connection === null || connection === void 0 ? void 0 : connection.type) || (connection === null || connection === void 0 ? void 0 : connection.effectiveType) || 'unknown';
    }
    return 'unknown';
  },
  // http | https
  getProtocol: function getProtocol() {
    if ((typeof location === "undefined" ? "undefined" : _typeof(location)) === 'object') {
      return location.protocol.replace(/:/, '');
    }
    return 'unknown protocol';
  },
  // 获取pc端操作系统类型
  getOsType: function getOsType() {
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) !== 'object') {
      return 'unknown os';
    }
    var agent = navigator.userAgent.toLowerCase();
    var isMac = /macintosh|mac os x/i.test(navigator.userAgent);
    if (agent.indexOf('win32') >= 0 || agent.indexOf('wow32') >= 0) {
      return 'win32';
    }
    if (agent.indexOf('win64') >= 0 || agent.indexOf('wow64') >= 0) {
      return 'win64';
    }
    if (isMac) {
      return 'mac';
    }
    return 'unknown os';
  },
  isMobile: function isMobile() {
    var exp = /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i;
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.userAgent.match(exp)) {
      return true; // 移动端
    }

    return false; // PC端
  },
  isAndroid: function isAndroid() {
    var exp = /(Android|Adr|Linux)/i;
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.userAgent.match(exp)) {
      return true;
    }
    return false;
  },
  isIOS: function isIOS() {
    var exp = /(iPhone|iPod|iPad|iOS)/i;
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && navigator.userAgent.match(exp)) {
      return true;
    }
    return false;
  },
  isOtherMobile: function isOtherMobile() {
    return isMobile && !isAndroid && !isIOS;
  },
  getUA: function getUA() {
    if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) !== 'object') {
      return 'unknown device';
    }
    var explorer = navigator.userAgent;
    return explorer;
  }
};
var isMobile = utils.isMobile();
var mobileOsType = utils.isAndroid() ? 'android' : utils.isIOS ? 'ios' : 'other_mobile';
var pcOsType = utils.getOsType();
var devicePlatform = isMobile ? mobileOsType : pcOsType;
var ua = utils.getUA();
var protocol = utils.getProtocol();

// 分块上传原子方法
var sliceUploadMethods = ['multipartInit', 'multipartUpload', 'multipartComplete', 'multipartList', 'multipartListPart', 'multipartAbort'];
var uploadApi = ['putObject', 'postObject', 'appendObject', 'sliceUploadFile', 'uploadFile', 'uploadFiles'].concat(sliceUploadMethods);
var downloadApi = ['getObject'];
function getEventCode(apiName) {
  if (uploadApi.includes(apiName)) {
    return 'cos_upload';
  }
  if (downloadApi.includes(apiName)) {
    return 'cos_download';
  }
  return 'base_service';
}
var transApiName = function transApiName(api) {
  if (['putObject', 'sliceUploadFile', 'uploadFile', 'uploadFiles'].includes(api)) {
    return 'UploadTask';
  } else if (api === 'getObject') {
    return 'DownloadTask';
  } else if (['putObjectCopy', 'sliceCopyFile'].includes(api)) {
    return 'CopyTask';
  }
  return api;
};

// 上报参数驼峰改下划线
function camel2underline(key) {
  return key.replace(/([A-Z])/g, '_$1').toLowerCase();
}
function formatParams(params) {
  var formattedParams = {};
  var successKeys = ['sdkVersionName', 'sdkVersionCode', 'osName', 'networkType', 'requestName', 'requestResult', 'bucket', 'region', 'appid', 'accelerate', 'url', 'host', 'requestPath', 'userAgent', 'networkProtocol', 'httpMethod', 'httpSize', 'httpSpeed', 'httpTookTime', 'httpMd5', 'httpSign', 'httpFullTime', 'httpDomain', 'partNumber', 'httpRetryTimes', 'customId', 'traceId', 'realApi'];
  var failureKeys = [].concat(successKeys, ['errorNode', 'errorCode', 'errorName', 'errorMessage', 'errorRequestId', 'errorHttpCode', 'errorServiceName', 'errorType', 'fullError']);
  // 需要上报的参数字段
  var reporterKeys = params.requestResult === 'Success' ? successKeys : failureKeys;
  for (var key in params) {
    if (!reporterKeys.includes(key)) continue;
    var formattedKey = camel2underline(key);
    formattedParams[formattedKey] = params[key];
  }
  formattedParams['request_name'] = params.realApi ? transApiName(params.realApi) : params.requestName;
  return formattedParams;
}

// 链路追踪器
var Tracker = /*#__PURE__*/function () {
  "use strict";

  function Tracker(opt) {
    _classCallCheck(this, Tracker);
    var parent = opt.parent,
      traceId = opt.traceId,
      bucket = opt.bucket,
      region = opt.region,
      apiName = opt.apiName,
      realApi = opt.realApi,
      httpMethod = opt.httpMethod,
      fileKey = opt.fileKey,
      fileSize = opt.fileSize,
      accelerate = opt.accelerate,
      customId = opt.customId,
      delay = opt.delay,
      deepTracker = opt.deepTracker,
      Beacon = opt.Beacon,
      clsReporter = opt.clsReporter;
    var appid = bucket && bucket.substr(bucket.lastIndexOf('-') + 1) || '';
    this.parent = parent;
    this.deepTracker = deepTracker;
    this.delay = delay;
    if (clsReporter && !this.clsReporter) {
      this.clsReporter = clsReporter;
    }
    // 上报用到的字段
    this.params = {
      // 通用字段
      sdkVersionName: 'cos-js-sdk-v5',
      sdkVersionCode: pkg.version,
      osName: devicePlatform,
      networkType: '',
      requestName: apiName || '',
      requestResult: '',
      // sdk api调用结果Success、Failure
      realApi: realApi,
      bucket: bucket,
      region: region,
      accelerate: accelerate,
      httpMethod: httpMethod,
      url: '',
      // 请求url
      host: '',
      httpDomain: '',
      requestPath: fileKey || '',
      userAgent: ua,
      networkProtocol: protocol,
      errorType: '',
      errorCode: '',
      errorName: '',
      errorMessage: '',
      errorRequestId: '',
      errorHttpCode: 0,
      errorServiceName: '',
      errorNode: '',
      httpTookTime: 0,
      // http整体耗时
      httpSize: fileSize || 0,
      // 主要是文件大小，大小 B
      httpMd5: 0,
      // MD5耗时
      httpSign: 0,
      // 计算签名耗时
      httpFullTime: 0,
      // 任务整体耗时(包括md5、签名等)
      httpSpeed: 0,
      // 主要关注上传速度，KB/s

      md5StartTime: 0,
      // md5计算开始时间
      md5EndTime: 0,
      // md5计算结束时间
      signStartTime: 0,
      // 计算签名开始时间
      signEndTime: 0,
      // 计算签名结束时间
      httpStartTime: 0,
      // 发起网络请求开始时间
      httpEndTime: 0,
      // 网路请求结束时间
      startTime: new Date().getTime(),
      // sdk api调用起始时间，不是纯网络耗时
      endTime: 0,
      //  sdk api调用结束时间，不是纯网络耗时

      // js补充字段
      traceId: traceId || utils.getUid(),
      // 每条上报唯一标识
      appid: appid,
      partNumber: 0,
      // 分块上传编号
      httpRetryTimes: 0,
      // sdk内部发起的请求重试
      customId: customId || '',
      // 业务id
      partTime: 0
    };
    if (Beacon) {
      this.beacon = getBeacon(Beacon, delay);
    }
  }

  // 格式化sdk回调
  _createClass(Tracker, [{
    key: "formatResult",
    value: function formatResult(err, data) {
      var _err$error, _err$error2, _err$error3, _err$error4, _err$error5, _err$error6;
      var now = new Date().getTime();
      var networkType = utils.getNetType();
      var errorCode = err ? (err === null || err === void 0 ? void 0 : err.code) || (err === null || err === void 0 ? void 0 : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.code) || (err === null || err === void 0 ? void 0 : (_err$error2 = err.error) === null || _err$error2 === void 0 ? void 0 : _err$error2.Code) : '';
      var errorMessage = err ? (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : (_err$error3 = err.error) === null || _err$error3 === void 0 ? void 0 : _err$error3.message) || (err === null || err === void 0 ? void 0 : (_err$error4 = err.error) === null || _err$error4 === void 0 ? void 0 : _err$error4.Message) : '';
      var errorName = errorMessage;
      var errorServiceName = err ? (err === null || err === void 0 ? void 0 : err.resource) || (err === null || err === void 0 ? void 0 : (_err$error5 = err.error) === null || _err$error5 === void 0 ? void 0 : _err$error5.resource) || (err === null || err === void 0 ? void 0 : (_err$error6 = err.error) === null || _err$error6 === void 0 ? void 0 : _err$error6.Resource) : '';
      var errorHttpCode = err ? err === null || err === void 0 ? void 0 : err.statusCode : data.statusCode;
      var requestId = err ? (err === null || err === void 0 ? void 0 : err.headers) && (err === null || err === void 0 ? void 0 : err.headers['x-cos-request-id']) : (data === null || data === void 0 ? void 0 : data.headers) && (data === null || data === void 0 ? void 0 : data.headers['x-cos-request-id']);
      var errorType = err ? requestId ? 'Server' : 'Client' : '';
      if (this.params.requestName === 'getObject') {
        this.params.httpSize = data ? data.headers && data.headers['content-length'] : 0;
      }

      // 上报 sliceUploadFile || uploadFile || uploadFiles 命中分块上传时
      var isSliceUploadFile = this.params.realApi === 'sliceUploadFile';
      var isSliceCopyFile = this.params.realApi === 'sliceCopyFile';
      if (isSliceUploadFile || isSliceCopyFile) {
        var speed = this.params.httpSize / 1024 / this.params.partTime;
        Object.assign(this.params, {
          httpSpeed: speed < 0 ? 0 : speed.toFixed(3)
        });
      } else {
        var httpFullTime = now - this.params.startTime;
        var httpTookTime = this.params.httpEndTime - this.params.httpStartTime;
        var _speed = this.params.httpSize / 1024 / (httpTookTime / 1000);
        var httpMd5 = this.params.md5EndTime - this.params.md5StartTime;
        var httpSign = this.params.signEndTime - this.params.signStartTime;
        if (this.parent) {
          this.parent.addParamValue('httpTookTime', ms2s(httpTookTime));
          this.parent.addParamValue('httpFullTime', ms2s(httpFullTime));
          this.parent.addParamValue('httpMd5', ms2s(httpMd5));
          this.parent.addParamValue('httpSign', ms2s(httpSign));
          if (['multipartUpload', 'uploadPartCopy', 'putObjectCopy'].includes(this.params.requestName)) {
            // 只有小分块上传|复制才累计纯请求耗时，计算速度时用到
            this.parent.addParamValue('partTime', ms2s(httpTookTime));
          }
        }
        Object.assign(this.params, {
          httpFullTime: ms2s(httpFullTime),
          httpMd5: ms2s(httpMd5),
          httpSign: ms2s(httpSign),
          httpTookTime: ms2s(httpTookTime),
          httpSpeed: _speed < 0 ? 0 : _speed.toFixed(3)
        });
      }
      Object.assign(this.params, {
        networkType: networkType,
        requestResult: err ? 'Failure' : 'Success',
        errorType: errorType,
        errorCode: errorCode,
        errorHttpCode: errorHttpCode,
        errorName: errorName,
        errorMessage: errorMessage,
        errorServiceName: errorServiceName,
        errorRequestId: requestId
      });
      if (err && (!errorCode || !errorMessage)) {
        // 暂存全量err一段时间 观察是否所有err格式都可被解析
        this.params.fullError = err ? JSON.stringify(err) : '';
      }
      if (this.params.url) {
        try {
          var execRes = /^http(s)?:\/\/(.*?)\//.exec(this.params.url);
          this.params.host = execRes[2];
        } catch (e) {
          this.params.host = this.params.url;
        }
        this.params.httpDomain = this.params.host;
      }
    }

    // 上报
  }, {
    key: "report",
    value: function report(err, data) {
      if (!this.beacon && !this.clsReporter) return;
      this.formatResult(err, data);
      var formattedParams = formatParams(this.params);
      console.log(formattedParams);
      if (this.beacon) {
        this.sendEventsToBeacon(formattedParams);
      }
      if (this.clsReporter) {
        this.sendEventsToCLS(formattedParams);
      }
    }

    // 设置当前链路的参数
  }, {
    key: "setParams",
    value: function setParams(params) {
      Object.assign(this.params, params);
    }
  }, {
    key: "addParamValue",
    value: function addParamValue(key, value) {
      this.params[key] = (+this.params[key] + +value).toFixed(3);
    }

    // 上报灯塔
  }, {
    key: "sendEventsToBeacon",
    value: function sendEventsToBeacon(formattedParams) {
      // DeepTracker模式下才会上报分块上传内部细节
      var isSliceUploadFile = this.params.requestName === 'sliceUploadFile' || this.params.realApi === 'sliceUploadFile';
      if (isSliceUploadFile && !this.deepTracker) {
        return;
      }
      // const eventCode = getEventCode(this.params.requestName);
      var eventCode = 'qcloud_track_cos_sdk';
      if (this.delay === 0) {
        // 实时上报
        this.beacon && this.beacon.onDirectUserAction(eventCode, formattedParams);
      } else {
        // 周期性上报
        this.beacon && this.beacon.onUserAction(eventCode, formattedParams);
      }
    }

    // 上报 cls
  }, {
    key: "sendEventsToCLS",
    value: function sendEventsToCLS(formattedParams) {
      // 是否实时上报
      var immediate = !!(this.delay === 0);
      this.clsReporter.log(formattedParams, immediate);
    }

    // 生成子实例，与父所属一个链路，可用于分块上传内部流程上报单个分块操作
  }, {
    key: "generateSubTracker",
    value: function generateSubTracker(subParams) {
      Object.assign(subParams, {
        parent: this,
        deepTracker: this.deepTracker,
        traceId: this.params.traceId,
        bucket: this.params.bucket,
        region: this.params.region,
        accelerate: this.params.accelerate,
        fileKey: this.params.requestPath,
        customId: this.params.customId,
        delay: this.delay,
        clsReporter: this.clsReporter
      });
      return new Tracker(subParams);
    }
  }]);
  return Tracker;
}();
module.exports = Tracker;

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");
var md5 = __webpack_require__(/*! ../lib/md5 */ "./lib/md5.js");
var CryptoJS = __webpack_require__(/*! ../lib/crypto */ "./lib/crypto.js");
var xml2json = __webpack_require__(/*! ../lib/xml2json */ "./lib/xml2json.js");
var json2xml = __webpack_require__(/*! ../lib/json2xml */ "./lib/json2xml.js");
var base64 = __webpack_require__(/*! ../lib/base64 */ "./lib/base64.js");
var Tracker = __webpack_require__(/*! ./tracker */ "./src/tracker.js");
function camSafeUrlEncode(str) {
  return encodeURIComponent(str).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
}
function getObjectKeys(obj, forKey) {
  var list = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      list.push(forKey ? camSafeUrlEncode(key).toLowerCase() : key);
    }
  }
  return list.sort(function (a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return a === b ? 0 : a > b ? 1 : -1;
  });
}

/**
 * obj转为string
 * @param  {Object}  obj                需要转的对象，必须
 * @param  {Boolean} lowerCaseKey       key是否转为小写，默认false，非必须
 * @return {String}  data               返回字符串
 */
var obj2str = function obj2str(obj, lowerCaseKey) {
  var i, key, val;
  var list = [];
  var keyList = getObjectKeys(obj);
  for (i = 0; i < keyList.length; i++) {
    key = keyList[i];
    val = obj[key] === undefined || obj[key] === null ? '' : '' + obj[key];
    key = lowerCaseKey ? camSafeUrlEncode(key).toLowerCase() : camSafeUrlEncode(key);
    val = camSafeUrlEncode(val) || '';
    list.push(key + '=' + val);
  }
  return list.join('&');
};

// 可以签入签名的headers
var signHeaders = ['cache-control', 'content-disposition', 'content-encoding', 'content-length', 'content-md5', 'expect', 'expires', 'host', 'if-match', 'if-modified-since', 'if-none-match', 'if-unmodified-since', 'origin', 'range', 'transfer-encoding', 'pic-operations'];
var getSignHeaderObj = function getSignHeaderObj(headers) {
  var signHeaderObj = {};
  for (var i in headers) {
    var key = i.toLowerCase();
    if (key.indexOf('x-cos-') > -1 || signHeaders.indexOf(key) > -1) {
      signHeaderObj[i] = headers[i];
    }
  }
  return signHeaderObj;
};

//测试用的key后面可以去掉
var getAuth = function getAuth(opt) {
  opt = opt || {};
  var SecretId = opt.SecretId;
  var SecretKey = opt.SecretKey;
  var KeyTime = opt.KeyTime;
  var method = (opt.method || opt.Method || 'get').toLowerCase();
  var queryParams = clone(opt.Query || opt.params || {});
  var headers = getSignHeaderObj(clone(opt.Headers || opt.headers || {}));
  var Key = opt.Key || '';
  var pathname;
  if (opt.UseRawKey) {
    pathname = opt.Pathname || opt.pathname || '/' + Key;
  } else {
    pathname = opt.Pathname || opt.pathname || Key;
    pathname.indexOf('/') !== 0 && (pathname = '/' + pathname);
  }

  // ForceSignHost明确传入false才不加入host签名
  var forceSignHost = opt.ForceSignHost === false ? false : true;

  // 如果有传入存储桶且需要强制签名，那么签名默认加 Host 参与计算，避免跨桶访问
  if (!headers.Host && !headers.host && opt.Bucket && opt.Region && forceSignHost) headers.Host = opt.Bucket + '.cos.' + opt.Region + '.myqcloud.com';
  if (!SecretId) throw new Error('missing param SecretId');
  if (!SecretKey) throw new Error('missing param SecretKey');

  // 签名有效起止时间
  var now = Math.round(getSkewTime(opt.SystemClockOffset) / 1000) - 1;
  var exp = now;
  var Expires = opt.Expires || opt.expires;
  if (Expires === undefined) {
    exp += 900; // 签名过期时间为当前 + 900s
  } else {
    exp += Expires * 1 || 0;
  }

  // 要用到的 Authorization 参数列表
  var qSignAlgorithm = 'sha1';
  var qAk = SecretId;
  var qSignTime = KeyTime || now + ';' + exp;
  var qKeyTime = KeyTime || now + ';' + exp;
  var qHeaderList = getObjectKeys(headers, true).join(';').toLowerCase();
  var qUrlParamList = getObjectKeys(queryParams, true).join(';').toLowerCase();

  // 签名算法说明文档：https://www.qcloud.com/document/product/436/7778
  // 步骤一：计算 SignKey
  var signKey = CryptoJS.HmacSHA1(qKeyTime, SecretKey).toString();

  // 步骤二：构成 FormatString
  var formatString = [method, pathname, util.obj2str(queryParams, true), util.obj2str(headers, true), ''].join('\n');

  // 步骤三：计算 StringToSign
  var stringToSign = ['sha1', qSignTime, CryptoJS.SHA1(formatString).toString(), ''].join('\n');

  // 步骤四：计算 Signature
  var qSignature = CryptoJS.HmacSHA1(stringToSign, signKey).toString();

  // 步骤五：构造 Authorization
  var authorization = ['q-sign-algorithm=' + qSignAlgorithm, 'q-ak=' + qAk, 'q-sign-time=' + qSignTime, 'q-key-time=' + qKeyTime, 'q-header-list=' + qHeaderList, 'q-url-param-list=' + qUrlParamList, 'q-signature=' + qSignature].join('&');
  return authorization;
};
var readIntBE = function readIntBE(chunk, size, offset) {
  var bytes = size / 8;
  var buf = chunk.slice(offset, offset + bytes);
  new Uint8Array(buf).reverse();
  return new {
    8: Uint8Array,
    16: Uint16Array,
    32: Uint32Array
  }[size](buf)[0];
};
var buf2str = function buf2str(chunk, start, end, isUtf8) {
  var buf = chunk.slice(start, end);
  var str = '';
  new Uint8Array(buf).forEach(function (charCode) {
    str += String.fromCharCode(charCode);
  });
  if (isUtf8) str = decodeURIComponent(escape(str));
  return str;
};
var parseSelectPayload = function parseSelectPayload(chunk) {
  var header = {};
  var body = buf2str(chunk);
  var result = {
    records: []
  };
  while (chunk.byteLength) {
    var totalLength = readIntBE(chunk, 32, 0);
    var headerLength = readIntBE(chunk, 32, 4);
    var payloadRestLength = totalLength - headerLength - 16;
    var offset = 0;
    var content;
    chunk = chunk.slice(12);
    // 获取 Message 的 header 信息
    while (offset < headerLength) {
      var headerNameLength = readIntBE(chunk, 8, offset);
      var headerName = buf2str(chunk, offset + 1, offset + 1 + headerNameLength);
      var headerValueLength = readIntBE(chunk, 16, offset + headerNameLength + 2);
      var headerValue = buf2str(chunk, offset + headerNameLength + 4, offset + headerNameLength + 4 + headerValueLength);
      header[headerName] = headerValue;
      offset += headerNameLength + 4 + headerValueLength;
    }
    if (header[':event-type'] === 'Records') {
      content = buf2str(chunk, offset, offset + payloadRestLength, true);
      result.records.push(content);
    } else if (header[':event-type'] === 'Stats') {
      content = buf2str(chunk, offset, offset + payloadRestLength, true);
      result.stats = util.xml2json(content).Stats;
    } else if (header[':event-type'] === 'error') {
      var errCode = header[':error-code'];
      var errMessage = header[':error-message'];
      var err = new Error(errMessage);
      err.message = errMessage;
      err.name = err.code = errCode;
      result.error = err;
    } else if (['Progress', 'Continuation', 'End'].includes(header[':event-type'])) {
      // do nothing
    }
    chunk = chunk.slice(offset + payloadRestLength + 4);
  }
  return {
    payload: result.records.join(''),
    body: body
  };
};
var getSourceParams = function getSourceParams(source) {
  var parser = this.options.CopySourceParser;
  if (parser) return parser(source);
  var m = source.match(/^([^.]+-\d+)\.cos(v6|-cdc|-cdz|-internal)?\.([^.]+)\.((myqcloud\.com)|(tencentcos\.cn))\/(.+)$/);
  if (!m) return null;
  return {
    Bucket: m[1],
    Region: m[3],
    Key: m[7]
  };
};
var noop = function noop() {};

// 清除对象里值为的 undefined 或 null 的属性
var clearKey = function clearKey(obj) {
  var retObj = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== undefined && obj[key] !== null) {
      retObj[key] = obj[key];
    }
  }
  return retObj;
};
var readAsBinaryString = function readAsBinaryString(blob, callback) {
  var readFun;
  var fr = new FileReader();
  if (FileReader.prototype.readAsBinaryString) {
    readFun = FileReader.prototype.readAsBinaryString;
    fr.onload = function () {
      callback(this.result);
    };
  } else if (FileReader.prototype.readAsArrayBuffer) {
    // 在 ie11 添加 readAsBinaryString 兼容
    readFun = function readFun(fileData) {
      var binary = '';
      var pt = this;
      var reader = new FileReader();
      reader.onload = function (e) {
        var bytes = new Uint8Array(reader.result);
        var length = bytes.byteLength;
        for (var i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        callback(binary);
      };
      reader.readAsArrayBuffer(fileData);
    };
  } else {
    console.error('FileReader not support readAsBinaryString');
  }
  readFun.call(fr, blob);
};
var fileSliceNeedCopy = function () {
  var compareVersion = function compareVersion(a, b) {
    a = a.split('.');
    b = b.split('.');
    for (var i = 0; i < b.length; i++) {
      if (a[i] !== b[i]) {
        return parseInt(a[i]) > parseInt(b[i]) ? 1 : -1;
      }
    }
    return 0;
  };
  var check = function check(ua) {
    if (!ua) return false;
    var ChromeVersion = (ua.match(/Chrome\/([.\d]+)/) || [])[1];
    var QBCoreVersion = (ua.match(/QBCore\/([.\d]+)/) || [])[1];
    var QQBrowserVersion = (ua.match(/QQBrowser\/([.\d]+)/) || [])[1];
    var need = ChromeVersion && compareVersion(ChromeVersion, '53.0.2785.116') < 0 && QBCoreVersion && compareVersion(QBCoreVersion, '3.53.991.400') < 0 && QQBrowserVersion && compareVersion(QQBrowserVersion, '9.0.2524.400') <= 0 || false;
    return need;
  };
  return check(typeof navigator !== 'undefined' && navigator.userAgent);
}();

// 获取文件分片
var fileSlice = function fileSlice(file, start, end, isUseToUpload, callback) {
  var blob;
  if (file.slice) {
    blob = file.slice(start, end);
  } else if (file.mozSlice) {
    blob = file.mozSlice(start, end);
  } else if (file.webkitSlice) {
    blob = file.webkitSlice(start, end);
  }
  if (isUseToUpload && fileSliceNeedCopy) {
    var reader = new FileReader();
    reader.onload = function (e) {
      blob = null;
      callback(new Blob([reader.result]));
    };
    reader.readAsArrayBuffer(blob);
  } else {
    callback(blob);
  }
};

// 获取文件内容的 MD5
var getBodyMd5 = function getBodyMd5(UploadCheckContentMd5, Body, callback, onProgress) {
  callback = callback || noop;
  if (UploadCheckContentMd5) {
    if (typeof Body === 'string') {
      callback(util.md5(Body, true));
    } else if (Blob && Body instanceof Blob) {
      util.getFileMd5(Body, function (err, md5) {
        callback(md5);
      }, onProgress);
    } else {
      callback();
    }
  } else {
    callback();
  }
};

// 获取文件 md5 值
var md5ChunkSize = 1024 * 1024;
var getFileMd5 = function getFileMd5(blob, callback, onProgress) {
  var size = blob.size;
  var loaded = 0;
  var md5ctx = md5.getCtx();
  var next = function next(start) {
    if (start >= size) {
      var hash = md5ctx.digest('hex');
      callback(null, hash);
      return;
    }
    var end = Math.min(size, start + md5ChunkSize);
    util.fileSlice(blob, start, end, false, function (chunk) {
      readAsBinaryString(chunk, function (content) {
        chunk = null;
        md5ctx = md5ctx.update(content, true);
        loaded += content.length;
        content = null;
        if (onProgress) onProgress({
          loaded: loaded,
          total: size,
          percent: Math.round(loaded / size * 10000) / 10000
        });
        next(start + md5ChunkSize);
      });
    });
  };
  next(0);
};
function clone(obj) {
  return map(obj, function (v) {
    return _typeof(v) === 'object' && v !== null ? clone(v) : v;
  });
}
function attr(obj, name, defaultValue) {
  return obj && name in obj ? obj[name] : defaultValue;
}
function extend(target, source) {
  each(source, function (val, key) {
    target[key] = source[key];
  });
  return target;
}
function isArray(arr) {
  return arr instanceof Array;
}
function isInArray(arr, item) {
  var flag = false;
  for (var i = 0; i < arr.length; i++) {
    if (item === arr[i]) {
      flag = true;
      break;
    }
  }
  return flag;
}
function makeArray(arr) {
  return isArray(arr) ? arr : [arr];
}
function each(obj, fn) {
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      fn(obj[i], i);
    }
  }
}
function map(obj, fn) {
  var o = isArray(obj) ? [] : {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = fn(obj[i], i);
    }
  }
  return o;
}
function filter(obj, fn) {
  var iaArr = isArray(obj);
  var o = iaArr ? [] : {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (fn(obj[i], i)) {
        if (iaArr) {
          o.push(obj[i]);
        } else {
          o[i] = obj[i];
        }
      }
    }
  }
  return o;
}
var b64 = function b64(str) {
  var i,
    len,
    char,
    res = '';
  for (i = 0, len = str.length / 2; i < len; i++) {
    char = parseInt(str[i * 2] + str[i * 2 + 1], 16);
    res += String.fromCharCode(char);
  }
  return btoa(res);
};
var uuid = function uuid() {
  var S4 = function S4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  };
  return S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4();
};
var hasMissingParams = function hasMissingParams(apiName, params) {
  var Bucket = params.Bucket;
  var Region = params.Region;
  var Key = params.Key;
  var Domain = this.options.Domain;
  var checkBucket = !Domain || typeof Domain === 'string' && Domain.indexOf('{Bucket}') > -1;
  var checkRegion = !Domain || typeof Domain === 'string' && Domain.indexOf('{Region}') > -1;
  if (apiName.indexOf('Bucket') > -1 || apiName === 'deleteMultipleObject' || apiName === 'multipartList' || apiName === 'listObjectVersions') {
    if (checkBucket && !Bucket) return 'Bucket';
    if (checkRegion && !Region) return 'Region';
  } else if (apiName.indexOf('Object') > -1 || apiName.indexOf('multipart') > -1 || apiName === 'sliceUploadFile' || apiName === 'abortUploadTask' || apiName === 'uploadFile') {
    if (checkBucket && !Bucket) return 'Bucket';
    if (checkRegion && !Region) return 'Region';
    if (!Key) return 'Key';
  }
  return false;
};
var formatParams = function formatParams(apiName, params) {
  // 复制参数对象
  params = extend({}, params);

  // 统一处理 Headers
  if (apiName !== 'getAuth' && apiName !== 'getV4Auth' && apiName !== 'getObjectUrl') {
    var Headers = params.Headers || {};
    if (params && _typeof(params) === 'object') {
      (function () {
        for (var key in params) {
          if (params.hasOwnProperty(key) && key.indexOf('x-cos-') > -1) {
            Headers[key] = params[key];
          }
        }
      })();
      var headerMap = {
        // params headers
        'x-cos-mfa': 'MFA',
        'Content-MD5': 'ContentMD5',
        'Content-Length': 'ContentLength',
        'Content-Type': 'ContentType',
        Expect: 'Expect',
        Expires: 'Expires',
        'Cache-Control': 'CacheControl',
        'Content-Disposition': 'ContentDisposition',
        'Content-Encoding': 'ContentEncoding',
        Range: 'Range',
        'If-Modified-Since': 'IfModifiedSince',
        'If-Unmodified-Since': 'IfUnmodifiedSince',
        'If-Match': 'IfMatch',
        'If-None-Match': 'IfNoneMatch',
        'x-cos-copy-source': 'CopySource',
        'x-cos-copy-source-Range': 'CopySourceRange',
        'x-cos-metadata-directive': 'MetadataDirective',
        'x-cos-copy-source-If-Modified-Since': 'CopySourceIfModifiedSince',
        'x-cos-copy-source-If-Unmodified-Since': 'CopySourceIfUnmodifiedSince',
        'x-cos-copy-source-If-Match': 'CopySourceIfMatch',
        'x-cos-copy-source-If-None-Match': 'CopySourceIfNoneMatch',
        'x-cos-acl': 'ACL',
        'x-cos-grant-read': 'GrantRead',
        'x-cos-grant-write': 'GrantWrite',
        'x-cos-grant-full-control': 'GrantFullControl',
        'x-cos-grant-read-acp': 'GrantReadAcp',
        'x-cos-grant-write-acp': 'GrantWriteAcp',
        'x-cos-storage-class': 'StorageClass',
        'x-cos-traffic-limit': 'TrafficLimit',
        'x-cos-mime-limit': 'MimeLimit',
        // SSE-C
        'x-cos-server-side-encryption-customer-algorithm': 'SSECustomerAlgorithm',
        'x-cos-server-side-encryption-customer-key': 'SSECustomerKey',
        'x-cos-server-side-encryption-customer-key-MD5': 'SSECustomerKeyMD5',
        // SSE-COS、SSE-KMS
        'x-cos-server-side-encryption': 'ServerSideEncryption',
        'x-cos-server-side-encryption-cos-kms-key-id': 'SSEKMSKeyId',
        'x-cos-server-side-encryption-context': 'SSEContext',
        // 上传时图片处理
        'Pic-Operations': 'PicOperations'
      };
      util.each(headerMap, function (paramKey, headerKey) {
        if (params[paramKey] !== undefined) {
          Headers[headerKey] = params[paramKey];
        }
      });
      params.Headers = clearKey(Headers);
    }
  }
  return params;
};
var apiWrapper = function apiWrapper(apiName, apiFn) {
  return function (params, callback) {
    var self = this;

    // 处理参数
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    // 整理参数格式
    params = formatParams(apiName, params);

    // tracker传递
    var tracker;
    if (self.options.EnableReporter) {
      if (params.calledBySdk === 'sliceUploadFile' || params.calledBySdk === 'sliceCopyFile') {
        // 分块上传内部方法使用sliceUploadFile的子链路
        tracker = params.tracker && params.tracker.generateSubTracker({
          apiName: apiName
        });
      } else if (['uploadFile', 'uploadFiles'].includes(apiName)) {
        // uploadFile、uploadFiles方法在内部处理，此处不处理
        tracker = null;
      } else {
        var fileSize = 0;
        if (params.Body) {
          fileSize = typeof params.Body === 'string' ? params.Body.length : params.Body.size || params.Body.byteLength || 0;
        }
        var accelerate = self.options.UseAccelerate || typeof self.options.Domain === 'string' && self.options.Domain.includes('accelerate.');
        tracker = new Tracker({
          Beacon: self.options.Beacon,
          bucket: params.Bucket,
          region: params.Region,
          apiName: apiName,
          realApi: apiName,
          accelerate: accelerate,
          fileKey: params.Key,
          fileSize: fileSize,
          deepTracker: self.options.DeepTracker,
          customId: self.options.CustomId,
          delay: self.options.TrackerDelay,
          clsReporter: self.options.ClsReporter
        });
      }
    }
    params.tracker = tracker;

    // 代理回调函数
    var formatResult = function formatResult(result) {
      if (result && result.headers) {
        result.headers['x-cos-request-id'] && (result.RequestId = result.headers['x-cos-request-id']);
        result.headers['x-ci-request-id'] && (result.RequestId = result.headers['x-ci-request-id']);
        result.headers['x-cos-version-id'] && (result.VersionId = result.headers['x-cos-version-id']);
        result.headers['x-cos-delete-marker'] && (result.DeleteMarker = result.headers['x-cos-delete-marker']);
      }
      return result;
    };
    var _callback = function _callback(err, data) {
      // 格式化上报参数并上报
      tracker && tracker.report(err, data);
      callback && callback(formatResult(err), formatResult(data));
    };
    var checkParams = function checkParams() {
      if (apiName !== 'getService' && apiName !== 'abortUploadTask') {
        // 判断参数是否完整
        var missingResult = hasMissingParams.call(self, apiName, params);
        if (missingResult) {
          return 'missing param ' + missingResult;
        }
        // 判断 region 格式
        if (params.Region) {
          if (self.options.CompatibilityMode) {
            if (!/^([a-z\d-.]+)$/.test(params.Region)) {
              return 'Region format error.';
            }
          } else {
            if (params.Region.indexOf('cos.') > -1) {
              return 'param Region should not be start with "cos."';
            } else if (!/^([a-z\d-]+)$/.test(params.Region)) {
              return 'Region format error.';
            }
          }
          // 判断 region 格式
          if (!self.options.CompatibilityMode && params.Region.indexOf('-') === -1 && params.Region !== 'yfb' && params.Region !== 'default' && params.Region !== 'accelerate') {
            console.warn('warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224');
          }
        }
        // 兼容不带 AppId 的 Bucket
        if (params.Bucket) {
          if (!/^([a-z\d-]+)-(\d+)$/.test(params.Bucket)) {
            if (params.AppId) {
              params.Bucket = params.Bucket + '-' + params.AppId;
            } else if (self.options.AppId) {
              params.Bucket = params.Bucket + '-' + self.options.AppId;
            } else {
              return 'Bucket should format as "test-1250000000".';
            }
          }
          if (params.AppId) {
            console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).');
            delete params.AppId;
          }
        }
        // 如果 Key 是 / 开头，强制去掉第一个 /
        if (!self.options.UseRawKey && params.Key && params.Key.substr(0, 1) === '/') {
          params.Key = params.Key.substr(1);
        }
      }
    };
    var errMsg = checkParams();
    var isSync = ['getAuth', 'getObjectUrl'].includes(apiName);
    if (typeof Promise === 'function' && !isSync && !callback) {
      return new Promise(function (resolve, reject) {
        callback = function callback(err, data) {
          err ? reject(err) : resolve(data);
        };
        if (errMsg) return _callback(util.error(new Error(errMsg)));
        apiFn.call(self, params, _callback);
      });
    } else {
      if (errMsg) return _callback(util.error(new Error(errMsg)));
      var res = apiFn.call(self, params, _callback);
      if (isSync) return res;
    }
  };
};
var throttleOnProgress = function throttleOnProgress(total, onProgress) {
  var self = this;
  var size0 = 0;
  var size1 = 0;
  var time0 = Date.now();
  var time1;
  var timer;
  function update() {
    timer = 0;
    if (onProgress && typeof onProgress === 'function') {
      time1 = Date.now();
      var speed = Math.max(0, Math.round((size1 - size0) / ((time1 - time0) / 1000) * 100) / 100) || 0;
      var percent;
      if (size1 === 0 && total === 0) {
        percent = 1;
      } else {
        percent = Math.floor(size1 / total * 100) / 100 || 0;
      }
      time0 = time1;
      size0 = size1;
      try {
        onProgress({
          loaded: size1,
          total: total,
          speed: speed,
          percent: percent
        });
      } catch (e) {}
    }
  }
  return function (info, immediately) {
    if (info) {
      size1 = info.loaded;
      total = info.total;
    }
    if (immediately) {
      clearTimeout(timer);
      update();
    } else {
      if (timer) return;
      timer = setTimeout(update, self.options.ProgressInterval);
    }
  };
};
var getFileSize = function getFileSize(api, params, callback) {
  var size;
  if (typeof params.Body === 'string') {
    params.Body = new Blob([params.Body], {
      type: 'text/plain'
    });
  } else if (params.Body instanceof ArrayBuffer) {
    params.Body = new Blob([params.Body]);
  }
  if (params.Body && (params.Body instanceof Blob || params.Body.toString() === '[object File]' || params.Body.toString() === '[object Blob]')) {
    size = params.Body.size;
  } else {
    callback(util.error(new Error('params body format error, Only allow File|Blob|String.')));
    return;
  }
  params.ContentLength = size;
  callback(null, size);
};

// 获取调正的时间戳
var getSkewTime = function getSkewTime(offset) {
  return Date.now() + (offset || 0);
};
var error = function error(err, opt) {
  var sourceErr = err;
  err.message = err.message || null;
  if (typeof opt === 'string') {
    err.error = opt;
    err.message = opt;
  } else if (_typeof(opt) === 'object' && opt !== null) {
    extend(err, opt);
    if (opt.code || opt.name) err.code = opt.code || opt.name;
    if (opt.message) err.message = opt.message;
    if (opt.stack) err.stack = opt.stack;
  }
  if (typeof Object.defineProperty === 'function') {
    Object.defineProperty(err, 'name', {
      writable: true,
      enumerable: false
    });
    Object.defineProperty(err, 'message', {
      enumerable: true
    });
  }
  err.name = opt && opt.name || err.name || err.code || 'Error';
  if (!err.code) err.code = err.name;
  if (!err.error) err.error = clone(sourceErr); // 兼容老的错误格式

  return err;
};
var isWebWorker = function isWebWorker() {
  // 有限判断 worker 环境的 constructor name 其次用 worker 独有的 FileReaderSync 兜底 详细参考 https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers
  return (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' && (globalThis.constructor.name === 'DedicatedWorkerGlobalScope' || globalThis.FileReaderSync);
};
var isNode = function isNode() {
  // 得兜底 web worker 环境中 webpack 用了 process 插件之类的情况
  return (typeof window === "undefined" ? "undefined" : _typeof(window)) !== 'object' && (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && "function" === 'function' && !isWebWorker();
};
var isCIHost = function isCIHost(url) {
  return /^https?:\/\/([^/]+\.)?ci\.[^/]+/.test(url);
};

//判断是否是ios
var isIOS = function () {
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) !== 'object') {
    return false;
  }
  var u = navigator.userAgent;
  var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端
  return isIOS;
}();

// 判断是qq内置浏览器
var isQQ = function () {
  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) !== 'object') {
    return false;
  }
  return /\sQQ/i.test(navigator.userAgent);
}();
var encodeBase64 = function encodeBase64(str, safe) {
  var base64Str = base64.encode(str);
  // 万象使用的安全base64格式需要特殊处理
  if (safe) {
    base64Str = base64Str.replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
  }
  return base64Str;
};
var util = {
  noop: noop,
  formatParams: formatParams,
  apiWrapper: apiWrapper,
  xml2json: xml2json,
  json2xml: json2xml,
  md5: md5,
  clearKey: clearKey,
  fileSlice: fileSlice,
  getBodyMd5: getBodyMd5,
  getFileMd5: getFileMd5,
  b64: b64,
  extend: extend,
  isArray: isArray,
  isInArray: isInArray,
  makeArray: makeArray,
  each: each,
  map: map,
  filter: filter,
  clone: clone,
  attr: attr,
  uuid: uuid,
  camSafeUrlEncode: camSafeUrlEncode,
  throttleOnProgress: throttleOnProgress,
  getFileSize: getFileSize,
  getSkewTime: getSkewTime,
  error: error,
  obj2str: obj2str,
  getAuth: getAuth,
  parseSelectPayload: parseSelectPayload,
  getSourceParams: getSourceParams,
  isBrowser: true,
  isNode: isNode,
  isCIHost: isCIHost,
  isIOS_QQ: isIOS && isQQ,
  encodeBase64: encodeBase64
};
module.exports = util;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ })

/******/ });
});